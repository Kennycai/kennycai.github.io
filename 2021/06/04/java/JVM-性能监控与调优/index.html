<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://kennycai.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）学习记录">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM 学习笔记 - 性能监控与调优">
<meta property="og:url" content="https://kennycai.github.io/2021/06/04/java/JVM-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）学习记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/jmap%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/jmap%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/jstack%E7%A4%BA%E4%BE%8B.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/jcmd%E5%8A%9F%E8%83%BD.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-GUI.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JConsole.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JConsole2.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JConsole3.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JConsole4.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JConsole5.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JProfiler1.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JProfiler2.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JProfiler3.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JProfiler4.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JProfiler5.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JProfiler6.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JProfiler7.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JProfiler-%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JProfiler-%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE2.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JProfiler-%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE3.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JProfiler-%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE4.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JProfiler-cpu%E8%A7%86%E5%9B%BE1.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JProfiler-cpu%E8%A7%86%E5%9B%BE2.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/JProfiler-%E7%BA%BF%E7%A8%8B%E8%A7%86%E5%9B%BE.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/%E6%B5%85%E5%A0%86%E6%B7%B1%E5%A0%86%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/%E6%94%AF%E9%85%8D%E6%A0%91.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F2.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%902.png">
<meta property="og:image" content="https://kennycai.github.io/images/java/jvm/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%903.png">
<meta property="article:published_time" content="2021-06-04T17:00:54.000Z">
<meta property="article:modified_time" content="2025-10-07T15:15:47.911Z">
<meta property="article:author" content="Cai Kenny">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kennycai.github.io/images/java/jvm/jmap%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0.png">

<link rel="canonical" href="https://kennycai.github.io/2021/06/04/java/JVM-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>JVM 学习笔记 - 性能监控与调优 | Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kennycai.github.io/2021/06/04/java/JVM-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cai Kenny">
      <meta itemprop="description" content="A Programmer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM 学习笔记 - 性能监控与调优
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-04 17:00:54" itemprop="dateCreated datePublished" datetime="2021-06-04T17:00:54+00:00">2021-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-07 15:15:47" itemprop="dateModified" datetime="2025-10-07T15:15:47+00:00">2025-10-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a href="https://www.bilibili.com/video/BV1PJ411n7xZ" target="_blank" rel="noopener">尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）</a>学习记录</p>
<a id="more"></a>

<blockquote>
<p>笔记来源：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ" target="_blank" rel="noopener">尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）</a></p>
<p>参考笔记：<a href="https://github.com/vectorxxxx/NOTE_JVM" target="_blank" rel="noopener">vectorxxxx/NOTE_JVM: 尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）学习笔记 (github.com)</a></p>
<p><a href="https://gitee.com/tcl192243051/studyJVM/blob/master/4_性能调优篇/JVM监控及诊断工具-GUI篇.md" target="_blank" rel="noopener">4_性能调优篇/JVM监控及诊断工具-GUI篇.md · Tc.l/学习Java虚拟机笔记 - 码云 - 开源中国 (gitee.com</a></p>
</blockquote>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="性能优化的步骤"><a href="#性能优化的步骤" class="headerlink" title="性能优化的步骤"></a>性能优化的步骤</h2><ol>
<li>性能监控：非侵入方式手机运营性能数据，起到预防作用<ol>
<li>GC频繁</li>
<li>cpu load过高</li>
<li>OOM</li>
<li>内存泄漏</li>
<li>死锁</li>
<li>程序响应时间较长</li>
<li>…</li>
</ol>
</li>
<li>性能分析：侵入方式收i就运行性数据，会影响应用的吞吐量或响应性；很少在生产环境进行，通常是在质量评估、系统测试或者开发环境下进行<ol>
<li>查看堆栈信息等W</li>
<li>查看GC日志</li>
<li>…</li>
</ol>
</li>
<li>性能调优<ol>
<li>增加内存</li>
<li>优化代码</li>
<li>设置JVM参数</li>
<li>设置线程池线程数量</li>
<li>…</li>
</ol>
</li>
</ol>
<h2 id="性能评价-测试指标"><a href="#性能评价-测试指标" class="headerlink" title="性能评价/测试指标"></a>性能评价/测试指标</h2><ol>
<li>听到时间（或响应时间）</li>
<li>吞吐量</li>
<li>并发数（同一时刻，对服务器实际交互的请求数）</li>
<li>内存占用</li>
</ol>
<h1 id="JVM监控及诊断工具-命令行"><a href="#JVM监控及诊断工具-命令行" class="headerlink" title="JVM监控及诊断工具-命令行"></a>JVM监控及诊断工具-命令行</h1><blockquote>
<p>源码：<a href="https://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools" target="_blank" rel="noopener">https://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools</a></p>
</blockquote>
<h2 id="jps-查看Java进程"><a href="#jps-查看Java进程" class="headerlink" title="jps 查看Java进程"></a>jps 查看Java进程</h2><blockquote>
<p> Jps（Java Proecess Status） 查看正在运行的虚拟机进程</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-q：输出应用程序主类的全类名 或 如果进程执行的是jar包，则输出jar完整路径</span><br><span class="line">-m：输出虚拟机进程启动时传递给主类main()的参数</span><br><span class="line">-v：列出虚拟机进程启动时的JVM参数</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果Java进程添加了 -xx:-UsePrefData参数，则jps不会显示该进程</p>
</blockquote>
<h2 id="jstat查看JVM统计信息"><a href="#jstat查看JVM统计信息" class="headerlink" title="jstat查看JVM统计信息"></a>jstat查看JVM统计信息</h2><blockquote>
<p>jstat( JVM Statistics Monitoring TooL):用于监视虛拟机各种运行状态信息的命令行工具。它可以是示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<p>在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题</p>
<p>jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]</p>
<p>示例：jstat -gc -t 14024 1000 20</p>
</blockquote>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li><p>Option</p>
<p><strong>类装载相关的</strong>：</p>
<ul>
<li>-class:显示ClassLoader的相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间等</li>
</ul>
<p><strong>垃圾回收相关的</strong>：</p>
<ul>
<li>-gc: 显示与Gc相关的堆信息。包括Eden区、两个Survivor区、老年代永久代等的容量、已用空间、GC时间合计等信息。</li>
<li>-gccapacity:显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。</li>
<li>-gcutil:显示内容与-gc基本相同，但输出主要关注己使用空间占总空间的百分比。</li>
<li>-gccause:与-gutil功能一样，但是会额外输出导致最后一次或当前正在发生的GC产生的原因</li>
<li>-gcnew:显示新生代GC状况</li>
<li>-gcnewcapacity:显示内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</li>
<li>-geold:显示老年代GC状况</li>
</ul>
<p><strong>JIT相关的</strong>：</p>
<ul>
<li>-compiler: 显示JIT编译器编译过的方法、耗时等信息</li>
<li>-printcompilation:输出已经被JIT编译的方法</li>
</ul>
</li>
<li><p>interval： 用于指定输出统计数据的周期，单位为毫秒。即：查询间隔</p>
</li>
<li><p>count：用于指定查询的总次数</p>
</li>
<li><p>-t：可以在输出信息前加上一个Timestamp列，显示程序的运行时间。单位为秒</p>
<ul>
<li>我们可以比较Java进程的启动时间以及总GC时间(GCT列)，或者两次测量的间隔时间 以及总GC时间的增量，来得出GC时间占运行时间的比例。 如果该比例超过20%,则说明目前堆的压力较大：如果该比例超过90%,则说明堆里几乎没有 可用空间，随时都可能抛出OOM异常。</li>
</ul>
</li>
<li><p>-h：可以在周期性数据输出时，输出多少行数据后输出一个表头信息</p>
</li>
</ul>
<h3 id="jstat判断内存泄漏"><a href="#jstat判断内存泄漏" class="headerlink" title="jstat判断内存泄漏"></a>jstat判断内存泄漏</h3><ol>
<li>在长时间运行的Java程序中，我们可以运行jstat命令连续获取多行性能数据，并取这几行<br>数据中OU列（即已占用的老年代内存）的最小值</li>
<li>然后，我们每隔一段较长的时间重复一次上述操作，来获得多组OU最小值。如果这些值呈上涨趋势。则说明该Java程序的老年代内存己使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在存泄漏。</li>
</ol>
<h2 id="jinfo实时查看-修改JVM参数"><a href="#jinfo实时查看-修改JVM参数" class="headerlink" title="jinfo实时查看,修改JVM参数"></a>jinfo实时查看,修改JVM参数</h2><blockquote>
<p>jinfo(Configuration Info for Java)：查看虚拟机配置参数信思，也可用于调整虚拟机的配置参数</p>
</blockquote>
<p>在很多情况下，Java应用程序不会指定所有的Java虚拟机参数。而此时，开发人员可能不知道某一个具体的Java虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数<br>的默认值。这个查找过程可能是非常艰难的。但有了 jinfo工具，开发人员可以很方便地找到Java虚拟机参数的当前值。</p>
<p>jinfo不仅可以查看运行时某一个Java虚拟机参数的实际取值，甚至可以在运行时修改部分参 数，并使之立即生效。 但是，并非所有参数都支持动态修改。参数只有被标记为manageable的flag可以被实时修改。</p>
<h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><p>查看</p>
<ul>
<li>-sysprops：查看由System.getProperties()取得的参数</li>
<li>-flags：查看曾经赋值过的一些参数</li>
<li>-flag 具体参数：查看某个java进程的</li>
</ul>
<p>修改</p>
<ul>
<li>略。后面补充</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jinfo [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jinfo [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    -flag &lt;name&gt;         to print the value of the named VM flag</span><br><span class="line">    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag</span><br><span class="line">    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value</span><br><span class="line">    -flags               to print VM flags</span><br><span class="line">    -sysprops            to print Java system properties</span><br><span class="line">    &lt;no option&gt;          to print both of the above</span><br><span class="line">    -h | -help           to print this help message</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -XX: -PrintFlagslnitial 查看所有JVM参数启动的初始值</span><br><span class="line">java -XX: +PrintFlagsFinal 查看所有JVM参数的最终值</span><br><span class="line">java -XX: +PrintCommandLineflags 查看那些已经被用户或者JVM设置过的详细的XX参数的名称和值</span><br></pre></td></tr></table></figure>

<h2 id="jmap导出内存映像文件和内存使用情况"><a href="#jmap导出内存映像文件和内存使用情况" class="headerlink" title="jmap导出内存映像文件和内存使用情况"></a>jmap导出内存映像文件和内存使用情况</h2><blockquote>
<p>jmap( JVM Memory Map)：导出内存映像文件&amp;内存使用情况</p>
<p>作用一方面是获取dump文件(堆转储快照文件，二进制文件)， 它还可以获取目标Java进程的内存相关信息，包括Java堆各区域的使用情况、堆中对象的统 计信息、类加载信息等</p>
</blockquote>
<p>基本语法</p>
<ul>
<li>jmap [option] <pid></li>
<li>jmap [option] &lt;executable <core></li>
<li>jmap [option] [server_id@]<remote server IP or hostname></li>
</ul>
<p>其中option包括：</p>
<p><img src="/images/java/jvm/jmap%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0.png" alt="jmap部分参数.png"></p>
<p><img src="/images/java/jvm/jmap%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.png" alt="jmap基本语法.png"></p>
<h3 id="导出内存映射文件"><a href="#导出内存映射文件" class="headerlink" title="导出内存映射文件"></a>导出内存映射文件</h3><p>导出的文件可用 JProfiler 查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">一般来说，使用jmap指令生成dump文件的操作算得上是最常用的jmap命令之一，将堆中所有存活对象导出至一个文件之中。</span><br><span class="line">Heap Dump又叫做堆存储文件，指一个Java进程在某个时间点的内存快照。 Heap Dump在触发内存快照的时候会保存此刻的信息如下</span><br><span class="line"></span><br><span class="line">All Objects</span><br><span class="line">Class, fields, primitive values and references</span><br><span class="line">All Classes</span><br><span class="line">Classloader, name, super class, static fields</span><br><span class="line">Garbage Collection Roots</span><br><span class="line">Objects defined to be reachable by the JVM</span><br><span class="line">Thread Stacks and Local Variables</span><br><span class="line">The call-stacks of threads at the moment of the snapshot, and per-frame</span><br><span class="line">information about local objects</span><br><span class="line">说明</span><br><span class="line">1 通常在写 Heap Dump文件前会触发一次Full GC,所以 heap dump文件里保存的都是Fu116C后留下的对象信息。</span><br><span class="line">2 由于生成dump文件比较耗时，因此大家需要耐心等待，尤其是大内存镜像生成dump文件则需要耗费更长的时间来完成</span><br></pre></td></tr></table></figure>

<ul>
<li><p>手动导出 : 手动直接立即导出</p>
<ul>
<li><code>jmap -dump:format=b,file=导出目录\文件名.hprof pid</code></li>
<li><code>jmap -dump:live,format=b,file=导出目录\文件名.hprof pid</code><ul>
<li>只dump出存活对象的快照,节省dump时间,空间 (一般在手动时使用这种方式)</li>
</ul>
</li>
</ul>
</li>
<li><p>自动导出: 启动程序时需要带参数,发生OOM时自动导出</p>
<ul>
<li><code>-XX:+HeapDumpOnOutOfMemoryError</code></li>
<li><code>-XX:HeapDumpPath=导出目录\文件名.hprof</code></li>
</ul>
</li>
</ul>
<h3 id="显示堆内存相关信息"><a href="#显示堆内存相关信息" class="headerlink" title="显示堆内存相关信息"></a>显示堆内存相关信息</h3><ul>
<li>jmap -heap pid</li>
<li>jmap -histo pid</li>
</ul>
<h3 id="其他作用"><a href="#其他作用" class="headerlink" title="其他作用"></a>其他作用</h3><ul>
<li>jmap -permstat pid：查看系统的ClassLoader信息</li>
<li>jmap -finalizerinfo：查看堆积在finalizer队列中的对象</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>jmap会访问所有对象,为了不会用户线程干扰,jmap会借助安全点,在安全点中所有线程不会改变堆中对象状态,也就是说: <strong>jmap导出的内存快照文件都是在安全点位置的</strong></p>
<p>结果可能出现偏差(比如某对象声明周期在两个安全点,使用live时就无法探知到这些对象)</p>
<p><strong>如果某线程长时间无法到安全点或安全区域,jmap就会等待,而jstat只需要在安全点读取垃圾回收器保存的统计数据</strong></p>
<h2 id="jhat分析dump文件工具"><a href="#jhat分析dump文件工具" class="headerlink" title="jhat分析dump文件工具"></a>jhat分析dump文件工具</h2><blockquote>
<p>Java Heap Analysis Tool:内置微型服务器分析jmap生成的dump文件</p>
<p>jdk9后删除，官方建议使用VisualVM代替</p>
<p>使用: <code>jhat [option] [dumpfile目录]</code>，然后访问localhost:7000查看</p>
</blockquote>
<h3 id="option参数"><a href="#option参数" class="headerlink" title="option参数"></a>option参数</h3><p>![jhat options参数.png](/images/java/jvm/jhat options参数.png)</p>
<h2 id="jstack打印JVM线程快照"><a href="#jstack打印JVM线程快照" class="headerlink" title="jstack打印JVM线程快照"></a>jstack打印JVM线程快照</h2><p><strong>JVM Stack Trace: 生成指定Java进程中当前时刻的线程快照,常用于定位线程出现长时间停顿的原因</strong></p>
<p><strong>格式: <code>jstack option pid</code></strong></p>
<p><img src="/images/java/jvm/jstack%E7%A4%BA%E4%BE%8B.png" alt="jstack示例.png"></p>
<blockquote>
<p>option参数</p>
</blockquote>
<p>![jstack options参数.png](/images/java/jvm/jstack options参数.png)</p>
<h2 id="jcmd多功能命令行"><a href="#jcmd多功能命令行" class="headerlink" title="jcmd多功能命令行"></a>jcmd多功能命令行</h2><p>jcmd可以实现除了jstat外所有指令的功能</p>
<p><img src="/images/java/jvm/jcmd%E5%8A%9F%E8%83%BD.png" alt="jcmd功能.png"></p>
<blockquote>
<p>jcmd -l 类似jps</p>
</blockquote>
<p>![jcmd -l.png](/images/java/jvm/jcmd -l.png)</p>
<blockquote>
<p>jcmd pid help</p>
</blockquote>
<p>![jcmd pid help.png](/images/java/jvm/jcmd pid help.png)</p>
<blockquote>
<p>jcmd pid 具体命令</p>
</blockquote>
<p>![jcmd pid 具体命令.png](/images/java/jvm/jcmd pid 具体命令.png)</p>
<h2 id="jstatd远程主机信息收集"><a href="#jstatd远程主机信息收集" class="headerlink" title="jstatd远程主机信息收集"></a>jstatd远程主机信息收集</h2><p>以上的很多指令都可以连接远程主机查看信息需要搭配jstatd使用</p>
<h1 id="JVM监控及诊断工具-GUI篇"><a href="#JVM监控及诊断工具-GUI篇" class="headerlink" title="JVM监控及诊断工具-GUI篇"></a>JVM监控及诊断工具-GUI篇</h1><p><img src="/images/java/jvm/JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-GUI.png" alt="JVM监控及诊断工具-GUI.png"></p>
<h2 id="工具概述"><a href="#工具概述" class="headerlink" title="工具概述"></a>工具概述</h2><p>使用上一章命令行工具或组合能帮您获取目标Java应用性能相关的基础信息，但它们存在下列局限：</p>
<ul>
<li>无法获取方法级别的分析数据，如方法间的调用关系、各方法的调用次数和调用时间等（这对定位应用性能瓶颈至关重要）。</li>
<li>要求用户登录到目标 Java 应用所在的宿主机上，使用起来不是很方便。</li>
<li>分析数据通过终端输出，结果展示不够直观。</li>
</ul>
<p>为此，JDK提供了一些内存泄漏的分析工具，如jconsole，jvisualvm等，用于辅助开发人员定位问题，但是这些工具很多时候并不足以满足快速定位的需求。所以这里我们介绍的工具相对多一些、丰富一些。</p>
<p><strong>JDK自带的工具</strong></p>
<ul>
<li><p>jconsole：JDK自带的可视化监控工具。查看Java应用程序的运行概况、监控堆信息、永久区（或元空间）使用情况、类加载情况等</p>
</li>
<li><p>Visual VM：Visual VM是一个工具，它提供了一个可视界面，用于查看Java虚拟机上运行的基于Java技术的应用程序的详细信息。</p>
</li>
<li><p>JMC：Java Mission Control，内置Java Flight Recorder。能够以极低的性能开销收集Java虚拟机的性能数据。</p>
</li>
</ul>
<p><strong>第三方工具</strong></p>
<ul>
<li><p>MAT：MAT（Memory Analyzer Tool）是基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</p>
</li>
<li><p>JProfiler：商业软件，需要付费。功能强大。</p>
</li>
</ul>
<h2 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h2><p>jconsole：从Java5开始，在JDK中自带的java监控和管理控制台。用于对JVM中内存、线程和类等的监控，是一个基于JMX（java management extensions）的GUI性能监控工具。</p>
<p>官方地址：<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html</a></p>
<p><img src="/images/java/jvm/JConsole.png" alt="JConsole.png"></p>
<p><img src="/images/java/jvm/JConsole2.png" alt="JConsole2.png"></p>
<p><img src="/images/java/jvm/JConsole3.png" alt="JConsole3.png"></p>
<p><img src="/images/java/jvm/JConsole4.png" alt="JConsole4.png"></p>
<p><img src="/images/java/jvm/JConsole5.png" alt="JConsole5.png"></p>
<h2 id="Visual-VM"><a href="#Visual-VM" class="headerlink" title="Visual VM"></a>Visual VM</h2><p>Visual VM是一个功能强大的多合一故障诊断和性能监控的可视化工具。它集成了多个JDK命令行工具，使用Visual VM可用于显示虚拟机进程及进程的配置和环境信息（jps，jinfo），监视应用程序的CPU、GC、堆、方法区及线程的信息（jstat、jstack）等，甚至代替JConsole。在JDK 6 Update 7以后，Visual VM便作为JDK的一部分发布（VisualVM 在JDK／bin目录下）即：它完全免费。</p>
<p><strong>主要功能：</strong></p>
<ul>
<li>生成/读取堆内存/线程快照</li>
<li>查看JVM参数和系统属性</li>
<li>查看运行中的虚拟机进程</li>
<li>程序资源的实时监控</li>
<li>JMX代理连接、远程环境监控、CPU分析和内存分析</li>
</ul>
<p>官方地址：<a href="https://visualvm.github.io/index.html" target="_blank" rel="noopener">https://visualvm.github.io/index.html</a></p>
<p>![Visual VM.png](/images/java/jvm/Visual VM.png)</p>
<p>![Visual VM2.png](/images/java/jvm/Visual VM2.png)</p>
<p>![Visual VM3.png](/images/java/jvm/Visual VM3.png)</p>
<h2 id="Eclipse-MAT"><a href="#Eclipse-MAT" class="headerlink" title="Eclipse MAT"></a>Eclipse MAT</h2><p>MAT（Memory Analyzer Tool）工具是一款功能强大的Java堆内存分析器。可以用于查找内存泄漏以及查看内存消耗情况。MAT是基于Eclipse开发的，不仅可以单独使用，还可以作为插件的形式嵌入在Eclipse中使用。是一款免费的性能分析工具，使用起来非常方便。</p>
<p>MAT可以分析heap dump文件。在进行内存分析时，只要获得了反映当前设备内存映像的hprof文件，通过MAT打开就可以直观地看到当前的内存信息。一般说来，这些内存信息包含：</p>
<ul>
<li>所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。</li>
<li>所有的类信息，包括classloader、类名称、父类、静态变量等</li>
<li>GCRoot到所有的这些对象的引用路径</li>
<li>线程信息，包括线程的调用栈及此线程的线程局部变量（TLS）</li>
</ul>
<p>MAT 不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如Sun，HP，SAP 所采用的 HPROF 二进制堆存储文件，以及 IBM的 PHD 堆存储文件等都能被很好的解析。</p>
<p>最吸引人的还是能够快速为开发人员生成内存泄漏报表，方便定位问题和分析问题。虽然MAT有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从MAT展现给我们的信息当中通过经验和直觉来判断才能发现。</p>
<p>官方地址： <a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">https://www.eclipse.org/mat/downloads.php</a> </p>
<p>![Eclipse MAT1.png](/images/java/jvm/Eclipse MAT1.png)</p>
<p>![Eclipse MAT2.png](/images/java/jvm/Eclipse MAT2.png)</p>
<p>![Eclipse MAT3.png](/images/java/jvm/Eclipse MAT3.png)</p>
<p>![Eclipse MAT4.png](/images/java/jvm/Eclipse MAT4.png)</p>
<h2 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h2><p>在运行Java的时候有时候想测试运行时占用内存情况，这时候就需要使用测试工具查看了。在eclipse里面有 Eclipse Memory Analyzer tool（MAT）插件可以测试，而在IDEA中也有这么一个插件，就是JProfiler。JProfiler 是由 ej-technologies 公司开发的一款 Java 应用性能诊断工具。功能强大，但是收费。</p>
<p><strong>特点：</strong></p>
<ul>
<li>使用方便、界面操作友好（简单且强大）</li>
<li>对被分析的应用影响小（提供模板）</li>
<li>CPU，Thread，Memory分析功能尤其强大</li>
<li>支持对jdbc，noSql，jsp，servlet，socket等进行分析</li>
<li>支持多种模式（离线，在线）的分析</li>
<li>支持监控本地、远程的JVM</li>
<li>跨平台，拥有多种操作系统的安装版本</li>
</ul>
<p><strong>主要功能：</strong></p>
<ul>
<li>方法调用：对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法</li>
<li>内存分配：通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄露问题，优化内存使用</li>
<li>线程和锁：JProfiler提供多种针对线程和锁的分析视图助您发现多线程问题</li>
<li>高级子系统：许多性能问题都发生在更高的语义级别上。例如，对于JDBC调用，您可能希望找出执行最慢的SQL语句。JProfiler支持对这些子系统进行集成分析</li>
</ul>
<p>官网地址：<a href="https://www.ej-technologies.com/products/jprofiler/overview.html" target="_blank" rel="noopener">https://www.ej-technologies.com/products/jprofiler/overview.html</a></p>
<p><strong>数据采集方式：</strong></p>
<p>JProfier数据采集方式分为两种：Sampling（样本采集）和Instrumentation（重构模式）</p>
<p><strong>Instrumentation</strong>：这是JProfiler全功能模式。在class加载之前，JProfier把相关功能代码写入到需要分析的class的bytecode中，对正在运行的jvm有一定影响。</p>
<ul>
<li>优点：功能强大。在此设置中，调用堆栈信息是准确的。</li>
<li>缺点：若要分析的class较多，则对应用的性能影响较大，CPU开销可能很高（取决于Filter的控制）。因此使用此模式一般配合Filter使用，只对特定的类或包进行分析</li>
</ul>
<p><strong>Sampling</strong>：类似于样本统计，每隔一定时间（5ms）将每个线程栈中方法栈中的信息统计出来。</p>
<ul>
<li>优点：对CPU的开销非常低，对应用影响小（即使你不配置任何Filter）</li>
<li>缺点：一些数据／特性不能提供（例如：方法的调用次数、执行时间）</li>
</ul>
<p>注：JProfiler本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型。因为JProfiler的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是JProfiler的数据采集类型。</p>
<p><strong>遥感监测 Telemetries</strong></p>
<p><img src="/images/java/jvm/JProfiler1.png" alt="JProfiler1.png"></p>
<p><img src="/images/java/jvm/JProfiler2.png" alt="JProfiler2.png"></p>
<p><img src="/images/java/jvm/JProfiler3.png" alt="JProfiler3.png"></p>
<p><img src="/images/java/jvm/JProfiler4.png" alt="JProfiler4.png"></p>
<p><img src="/images/java/jvm/JProfiler5.png" alt="JProfiler5.png"></p>
<p><img src="/images/java/jvm/JProfiler6.png" alt="JProfiler6.png"></p>
<p><img src="/images/java/jvm/JProfiler7.png" alt="JProfiler7.png"></p>
<p><strong>内存视图 Live Memory</strong></p>
<p>Live memory 内存剖析：class／class instance的相关信息。例如对象的个数，大小，对象创建的方法执行栈，对象创建的热点。</p>
<ul>
<li><strong>所有对象 All Objects</strong>：显示所有加载的类的列表和在堆上分配的实例数。只有Java 1.5（JVMTI）才会显示此视图。</li>
<li><strong>记录对象 Record Objects</strong>：查看特定时间段对象的分配，并记录分配的调用堆栈。</li>
<li><strong>分配访问树 Allocation Call Tree</strong>：显示一棵请求树或者方法、类、包或对已选择类有带注释的分配信息的J2EE组件。</li>
<li><strong>分配热点 Allocation Hot Spots</strong>：显示一个列表，包括方法、类、包或分配已选类的J2EE组件。你可以标注当前值并且显示差异值。对于每个热点都可以显示它的跟踪记录树。</li>
<li><strong>类追踪器 Class Tracker</strong>：类跟踪视图可以包含任意数量的图表，显示选定的类和包的实例与时间。</li>
</ul>
<p><img src="/images/java/jvm/JProfiler-%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE.png" alt="JProfiler-内存视图.png"></p>
<p><img src="/images/java/jvm/JProfiler-%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE2.png" alt="JProfiler-内存视图2.png"></p>
<p><strong>堆遍历 heap walker</strong></p>
<p><img src="/images/java/jvm/JProfiler-%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE3.png" alt="JProfiler-内存视图3.png"></p>
<p><img src="/images/java/jvm/JProfiler-%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE4.png" alt="JProfiler-内存视图4.png"></p>
<p><strong>cpu视图 cpu views</strong></p>
<p>JProfiler 提供不同的方法来记录访问树以优化性能和细节。线程或者线程组以及线程状况可以被所有的视图选择。所有的视图都可以聚集到方法、类、包或J2EE组件等不同层上。</p>
<ul>
<li><strong>访问树 Call Tree</strong>：显示一个积累的自顶向下的树，树中包含所有在JVM中已记录的访问队列。JDBC，JMS和JNDI服务请求都被注释在请求树中。请求树可以根据Servlet和JSP对URL的不同需要进行拆分。</li>
<li><strong>热点 Hot Spots</strong>：显示消耗时间最多的方法的列表。对每个热点都能够显示回溯树。该热点可以按照方法请求，JDBC，JMS和JNDI服务请求以及按照URL请求来进行计算。</li>
<li><strong>访问图 Call Graph</strong>：显示一个从已选方法、类、包或J2EE组件开始的访问队列的图。</li>
<li><strong>方法统计 Method Statistis</strong>：显示一段时间内记录的方法的调用时间细节。</li>
</ul>
<p><img src="/images/java/jvm/JProfiler-cpu%E8%A7%86%E5%9B%BE1.png" alt="JProfiler-cpu视图1.png"></p>
<p><img src="/images/java/jvm/JProfiler-cpu%E8%A7%86%E5%9B%BE2.png" alt="JProfiler-cpu视图2.png"></p>
<p><strong>线程视图 threads</strong></p>
<p>JProfiler通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程所管理的方法以树状形式呈现。对线程剖析。</p>
<ul>
<li><strong>线程历史 Thread History</strong>：显示一个与线程活动和线程状态在一起的活动时间表。</li>
<li><strong>线程监控 Thread Monitor</strong>：显示一个列表，包括所有的活动线程以及它们目前的活动状况。</li>
<li><strong>线程转储 Thread Dumps</strong>：显示所有线程的堆栈跟踪。</li>
</ul>
<p>线程分析主要关心三个方面：</p>
<ul>
<li>web容器的线程最大数。比如：Tomcat的线程容量应该略大于最大并发数。</li>
<li>线程阻塞</li>
<li>线程死锁</li>
</ul>
<p><img src="/images/java/jvm/JProfiler-%E7%BA%BF%E7%A8%8B%E8%A7%86%E5%9B%BE.png" alt="JProfiler-线程视图.png"></p>
<p><strong>监控和锁 Monitors ＆Locks</strong></p>
<p>所有线程持有锁的情况以及锁的信息。观察JVM的内部线程并查看状态：</p>
<ul>
<li><strong>死锁探测图表 Current Locking Graph</strong>：显示JVM中的当前死锁图表。</li>
<li><strong>目前使用的监测器 Current Monitors</strong>：显示目前使用的监测器并且包括它们的关联线程。</li>
<li><strong>锁定历史图表 Locking History Graph</strong>：显示记录在JVM中的锁定历史。</li>
<li><strong>历史检测记录 Monitor History</strong>：显示重大的等待事件和阻塞事件的历史记录。</li>
<li><strong>监控器使用统计 Monitor Usage Statistics</strong>：显示分组监测，线程和监测类的统计监测数据</li>
</ul>
<h2 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h2><p>上述工具都必须在服务端项目进程中配置相关的监控参数，然后工具通过远程连接到项目进程，获取相关的数据。这样就会带来一些不便，比如线上环境的网络是隔离的，本地的监控工具根本连不上线上环境。并且类似于Jprofiler这样的商业工具，是需要付费的。</p>
<p>那么有没有一款工具不需要远程连接，也不需要配置监控参数，同时也提供了丰富的性能监控数据呢？</p>
<p>阿里巴巴开源的性能分析神器Arthas应运而生。</p>
<p>Arthas是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。Arthas 支持JDK 6＋，支持Linux／Mac／Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p>
<ul>
<li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li>
<li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li>
<li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li>
<li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li>
<li>是否有一个全局视角来查看系统的运行状况？</li>
<li>有什么办法可以监控到JVM的实时运行状态？</li>
<li>怎么快速定位应用的热点，生成火焰图？</li>
</ul>
<p>官方地址：<a href="https://arthas.aliyun.com/doc/quick-start.html" target="_blank" rel="noopener">https://arthas.aliyun.com/doc/quick-start.html</a></p>
<p>安装方式：如果速度较慢，可以尝试国内的码云Gitee下载。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://io/arthas/arthas-boot.jar</span><br><span class="line">wget https://arthas/gitee/io/arthas-boot.jar</span><br></pre></td></tr></table></figure>

<p>Arthas只是一个java程序，所以可以直接用java -jar运行。</p>
<p>除了在命令行查看外，Arthas目前还支持 Web Console。在成功启动连接进程之后就已经自动启动,可以直接访问 <a href="http://127.0.0.1:8563/" target="_blank" rel="noopener">http://127.0.0.1:8563/</a> 访问，页面上的操作模式和控制台完全一样。</p>
<p><strong>基础指令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">quit/exit 退出当前 Arthas客户端，其他 Arthas喜户端不受影响</span><br><span class="line">stop/shutdown 关闭 Arthas服务端，所有 Arthas客户端全部退出</span><br><span class="line">help 查看命令帮助信息</span><br><span class="line">cat 打印文件内容，和linux里的cat命令类似</span><br><span class="line">echo 打印参数，和linux里的echo命令类似</span><br><span class="line">grep 匹配查找，和linux里的gep命令类似</span><br><span class="line">tee 复制标隹输入到标准输出和指定的文件，和linux里的tee命令类似</span><br><span class="line">pwd 返回当前的工作目录，和linux命令类似</span><br><span class="line">cs 清空当前屏幕区域</span><br><span class="line">session 查看当前会话的信息</span><br><span class="line">reset 重置增强类，将被 Arthas增强过的类全部还原, Arthas服务端关闭时会重置所有增强过的类</span><br><span class="line">version 输出当前目标Java进程所加载的 Arthas版本号</span><br><span class="line">history 打印命令历史</span><br><span class="line">keymap Arthas快捷键列表及自定义快捷键</span><br></pre></td></tr></table></figure>

<p><strong>jvm相关</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dashboard 当前系统的实时数据面板</span><br><span class="line">thread 查看当前JVM的线程堆栈信息</span><br><span class="line">jvm 查看当前JVM的信息</span><br><span class="line">sysprop 查看和修改JVM的系统属性</span><br><span class="line">sysem 查看JVM的环境变量</span><br><span class="line">vmoption 查看和修改JVM里诊断相关的option</span><br><span class="line">perfcounter 查看当前JVM的 Perf Counter信息</span><br><span class="line">logger 查看和修改logger</span><br><span class="line">getstatic 查看类的静态属性</span><br><span class="line">ognl 执行ognl表达式</span><br><span class="line">mbean 查看 Mbean的信息</span><br><span class="line">heapdump dump java heap，类似jmap命令的 heap dump功能</span><br></pre></td></tr></table></figure>

<p><strong>class/classloader相关</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sc 查看JVM已加载的类信息</span><br><span class="line">	-d 输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的Classloader等详细信息。如果一个类被多个Classloader所加载，则会出现多次</span><br><span class="line">	-E 开启正则表达式匹配，默认为通配符匹配</span><br><span class="line">	-f 输出当前类的成员变量信息（需要配合参数-d一起使用）</span><br><span class="line">	-X 指定输出静态变量时属性的遍历深度，默认为0，即直接使用toString输出</span><br><span class="line">sm 查看已加载类的方法信息</span><br><span class="line">	-d 展示每个方法的详细信息</span><br><span class="line">	-E 开启正则表达式匹配,默认为通配符匹配</span><br><span class="line">jad 反编译指定已加载类的源码</span><br><span class="line">mc 内存编译器，内存编译.java文件为.class文件</span><br><span class="line">retransform 加载外部的.class文件, retransform到JVM里</span><br><span class="line">redefine 加载外部的.class文件，redefine到JVM里</span><br><span class="line">dump dump已加载类的byte code到特定目录</span><br><span class="line">classloader 查看classloader的继承树，urts，类加载信息，使用classloader去getResource</span><br><span class="line">	-t 查看classloader的继承树</span><br><span class="line">	-l 按类加载实例查看统计信息</span><br><span class="line">	-c 用classloader对应的hashcode来查看对应的 Jar urls</span><br></pre></td></tr></table></figure>

<p><strong>monitor/watch/trace相关</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">monitor 方法执行监控，调用次数、执行时间、失败率</span><br><span class="line">	-c 统计周期，默认值为120秒</span><br><span class="line">watch 方法执行观测，能观察到的范围为：返回值、抛出异常、入参，通过编写groovy表达式进行对应变量的查看</span><br><span class="line">	-b 在方法调用之前观察(默认关闭)</span><br><span class="line">	-e 在方法异常之后观察(默认关闭)</span><br><span class="line">	-s 在方法返回之后观察(默认关闭)</span><br><span class="line">	-f 在方法结束之后(正常返回和异常返回)观察(默认开启)</span><br><span class="line">	-x 指定输岀结果的属性遍历深度,默认为0</span><br><span class="line">trace 方法内部调用路径,并输出方法路径上的每个节点上耗时</span><br><span class="line">	-n 执行次数限制</span><br><span class="line">stack 输出当前方法被调用的调用路径</span><br><span class="line">tt 方法执行数据的时空隧道,记录下指定方法每次调用的入参和返回信息,并能对这些不同的时间下调用进行观测</span><br></pre></td></tr></table></figure>

<p><strong>其他</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jobs 列出所有job</span><br><span class="line">kill 强制终止任务</span><br><span class="line">fg 将暂停的任务拉到前台执行</span><br><span class="line">bg 将暂停的任务放到后台执行</span><br><span class="line">grep 搜索满足条件的结果</span><br><span class="line">plaintext 将命令的结果去除ANSI颜色</span><br><span class="line">wc 按行统计输出结果</span><br><span class="line">options 查看或设置Arthas全局开关</span><br><span class="line">profiler 使用async-profiler对应用采样，生成火焰图</span><br></pre></td></tr></table></figure>

<h2 id="Java-Misssion-Control"><a href="#Java-Misssion-Control" class="headerlink" title="Java Misssion Control"></a>Java Misssion Control</h2><p>在Oracle收购Sun之前，Oracle的JRockit虚拟机提供了一款叫做 JRockit Mission Control 的虚拟机诊断工具。</p>
<p>在Oracle收购sun之后，Oracle公司同时拥有了Hotspot和 JRockit 两款虚拟机。根据Oracle对于Java的战略，在今后的发展中，会将JRokit的优秀特性移植到Hotspot上。其中一个重要的改进就是在Sun的JDK中加入了JRockit的支持。</p>
<p>在Oracle JDK 7u40之后，Mission Control这款工具己经绑定在Oracle JDK中发布。</p>
<p>自Java11开始，本节介绍的JFR己经开源。但在之前的Java版本，JFR属于Commercial Feature通过Java虚拟机参数-XX:+UnlockCommercialFeatures 开启。</p>
<p>Java Mission Control（简称JMC) ， Java官方提供的性能强劲的工具，是一个用于对 Java应用程序进行管理、监视、概要分析和故障排除的工具套件。它包含一个GUI客户端以及众多用来收集Java虚拟机性能数据的插件如 JMX Console（能够访问用来存放虚拟机齐个于系统运行数据的MXBeans）以及虚拟机内置的高效 profiling 工具 Java Flight Recorder（JFR）。</p>
<p>JMC的另一个优点就是：采用取样，而不是传统的代码植入技术，对应用性能的影响非常非常小，完全可以开着JMC来做压测（唯一影响可能是 full gc 多了）。 </p>
<p> 官方地址：<a href="https://github.com/JDKMissionControl/jmc" target="_blank" rel="noopener">https://github.com/JDKMissionControl/jmc</a></p>
<p>![Java Misssion Control.png](/images/java/jvm/Java Misssion Control.png)</p>
<p><strong>Java Flight Recorder</strong></p>
<p>Java Flight Recorder是JMC的其中一个组件，能够以极低的性能开销收集Java虚拟机的性能数据。与其他工具相比，JFR的性能开销很小，在默认配置下平均低于1%。JFR能够直接访问虚拟机内的敌据并且不会影响虚拟机的优化。因此它非常适用于生产环境下满负荷运行的Java程序。</p>
<p>Java Flight Recorder 和 JDK Mission Control共同创建了一个完整的工具链。JDK Mission Control 可对 Java Flight Recorder 连续收集低水平和详细的运行时信息进行高效、详细的分析。 </p>
<p>当启用时 JFR将记录运行过程中发生的一系列事件。其中包括Java层面的事件如线程事件、锁事件，以及Java虚拟机内部的事件，如新建对象，垃圾回收和即时编译事件。按照发生时机以及持续时间来划分，JFR的事件共有四种类型，它们分别为以下四种：</p>
<ul>
<li><p>瞬时事件（Instant Event) ，用户关心的是它们发生与否，例如异常、线程启动事件。</p>
</li>
<li><p>持续事件(Duration Event) ，用户关心的是它们的持续时间，例如垃圾回收事件。</p>
</li>
</ul>
<ul>
<li><p>计时事件(Timed Event) ，是时长超出指定阈值的持续事件。</p>
</li>
<li><p>取样事件（Sample Event)，是周期性取样的事件。</p>
</li>
</ul>
<p>取样事件的其中一个常见例子便是方法抽样（Method Sampling），即每隔一段时问统计各个线程的栈轨迹。如果在这些抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法 </p>
<p>![Java Flight Recorder.png](/images/java/jvm/Java Flight Recorder.png)</p>
<p>![Java Flight Recorder2.png](/images/java/jvm/Java Flight Recorder2.png)</p>
<p>![Java Flight Recorder3.png](/images/java/jvm/Java Flight Recorder3.png)</p>
<p>![Java Flight Recorder-线程.png](/images/java/jvm/Java Flight Recorder-线程.png)</p>
<p>![Java Flight Recorder-IO.png](/images/java/jvm/Java Flight Recorder-IO.png)</p>
<p>![Java Flight Recorder-系统.png](/images/java/jvm/Java Flight Recorder-系统.png)</p>
<p>![Java Flight Recorder-事件.png](/images/java/jvm/Java Flight Recorder-事件.png)</p>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p><strong>Flame Graphs（火焰图）</strong></p>
<p>在追求极致性能的场景下，了解你的程序运行过程中cpu在干什么很重要，火焰图就是一种非常直观的展示CPU在程序整个生命周期过程中时间分配的工具。火焰图对于现代的程序员不应该陌生，这个工具可以非常直观的显示出调用找中的CPU消耗瓶颈。</p>
<p>网上的关于Java火焰图的讲解大部分来自于Brenden Gregg的博客 <a href="http://new.brendangregg.com/flamegraphs.html" target="_blank" rel="noopener">http://new.brendangregg.com/flamegraphs.html </a></p>
<p>![Flame Graphs（火焰图）.png](/images/java/jvm/Flame Graphs（火焰图）.png)</p>
<p>火焰图，简单通过x轴横条宽度来度量时间指标，y轴代表线程栈的层次。</p>
<p><strong>Tprofiler</strong></p>
<p>案例： 使用JDK自身提供的工具进行JVM调优可以将下 TPS 由2.5提升到20（提升了7倍），并准确 定位系统瓶颈。</p>
<p>系统瓶颈有：应用里释态对象不是太多、有大量的业务线程在频繁创建一些生命周期很长的临时对象，代码里有问题。</p>
<p>那么，如何在海量业务代码里边准确定位这些性能代码？这里使用阿里开源工具 Tprofiler 来定位 这些性能代码，成功解决掉了GC 过于频繁的性能瓶预，并最终在上次优化的基础上将 TPS 再提升了4倍，即提升到100。</p>
<ul>
<li>Tprofiler配置部署、远程操作、 日志阅谈都不太复杂，操作还是很简单的。但是其却是能够 起到一针见血、立竿见影的效果，帮我们解决了GC过于频繁的性能瓶预。</li>
<li>Tprofiler最重要的特性就是能够统汁出你指定时间段内 JVM 的 top method 这些 top method 极有可能就是造成你 JVM 性能瓶颈的元凶。这是其他大多数 JVM 调优工具所不具备的，包括 JRockit Mission Control。JRokit 首席开发者 Marcus Hirt 在其私人博客《 Lom Overhead Method Profiling cith Java Mission Control》下的评论中曾明确指出  JRMC 井不支持 TOP 方法的统计。</li>
</ul>
<p>官方地址：<a href="http://github.com/alibaba/Tprofiler" target="_blank" rel="noopener">http://github.com/alibaba/Tprofiler</a></p>
<p><strong>Btrace</strong></p>
<p>常见的动态追踪工具有BTrace、HouseHD（该项目己经停止开发）、Greys-Anatomy（国人开发 个人开发者）、Byteman（JBoss出品），注意Java运行时追踪工具井不限干这几种，但是这几个是相对比较常用的。 </p>
<p>BTrace是SUN Kenai 云计算开发平台下的一个开源项目，旨在为java提供安全可靠的动态跟踪分析工具。</p>
<p>是一个 Java 平台的安全的动态追踪工具，可以用来动态地追踪一个运行的 Java 程序。BTrace动态调整目标应用程序的类以注入跟踪代码（“字节码跟踪“）。</p>
<p><strong>YourKit</strong></p>
<p><strong>JProbe</strong></p>
<p><strong>Spring Insight</strong></p>
<h1 id="JVM运行时参数"><a href="#JVM运行时参数" class="headerlink" title="JVM运行时参数"></a>JVM运行时参数</h1><h2 id="JVM参数选项"><a href="#JVM参数选项" class="headerlink" title="JVM参数选项"></a>JVM参数选项</h2><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p>
<h3 id="类型一：标准参数选项"><a href="#类型一：标准参数选项" class="headerlink" title="类型一：标准参数选项"></a>类型一：标准参数选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> java -<span class="built_in">help</span></span></span><br><span class="line">用法: java [-options] class [args...]</span><br><span class="line">           (执行类)</span><br><span class="line">   或  java [-options] -jar jarfile [args...]</span><br><span class="line">           (执行 jar 文件)</span><br><span class="line">其中选项包括:</span><br><span class="line">    -d32          使用 32 位数据模型 (如果可用)</span><br><span class="line">    -d64          使用 64 位数据模型 (如果可用)</span><br><span class="line">    -server       选择 "server" VM</span><br><span class="line">                  默认 VM 是 server.</span><br><span class="line"></span><br><span class="line">    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">                  用 ; 分隔的目录, JAR 档案</span><br><span class="line">                  和 ZIP 档案列表, 用于搜索类文件。</span><br><span class="line">    -D&lt;名称&gt;=&lt;值&gt;</span><br><span class="line">                  设置系统属性</span><br><span class="line">    -verbose:[class|gc|jni]</span><br><span class="line">                  启用详细输出</span><br><span class="line">    -version      输出产品版本并退出</span><br><span class="line">    -version:&lt;值&gt;</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  需要指定的版本才能运行</span><br><span class="line">    -showversion  输出产品版本并继续</span><br><span class="line">    -jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  在版本搜索中包括/排除用户专用 JRE</span><br><span class="line">    -? -help      输出此帮助消息</span><br><span class="line">    -X            输出非标准选项的帮助</span><br><span class="line">    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  按指定的粒度启用断言</span><br><span class="line">    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  禁用具有指定粒度的断言</span><br><span class="line">    -esa | -enablesystemassertions</span><br><span class="line">                  启用系统断言</span><br><span class="line">    -dsa | -disablesystemassertions</span><br><span class="line">                  禁用系统断言</span><br><span class="line">    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">                  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help</span><br><span class="line">    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  按完整路径名加载本机代理库</span><br><span class="line">    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br><span class="line">    -splash:&lt;imagepath&gt;</span><br><span class="line">                  使用指定的图像显示启动屏幕</span><br><span class="line">有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。</span><br></pre></td></tr></table></figure>

<p><strong>Server模式和Client模式</strong></p>
<p>Hotspot JVM有两种模式，分别是server和client，分别通过-server和-client模式设置</p>
<ul>
<li>32位系统上，默认使用Client类型的JVM。要想使用Server模式，机器配置至少有2个以上的CPU和2G以上的物理内存。client模式适用于对内存要求较小的桌面应用程序，默认使用Serial串行垃圾收集器</li>
<li>64位系统上，只支持server模式的JVM，适用于需要大内存的应用程序，默认使用并行垃圾收集器</li>
</ul>
<p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html</a></p>
<p>如何知道系统默认使用的是那种模式呢？</p>
<p>通过java -version命令：可以看到Server VM字样，代表当前系统使用是Server模式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> java -version</span></span><br><span class="line">java version "1.8.0_201"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_201-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</span><br></pre></td></tr></table></figure>

<h3 id="类型二：-X参数选项"><a href="#类型二：-X参数选项" class="headerlink" title="类型二：-X参数选项"></a>类型二：-X参数选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> java -X</span></span><br><span class="line">    -Xmixed           混合模式执行 (默认)</span><br><span class="line">    -Xint             仅解释模式执行</span><br><span class="line">    -Xbootclasspath:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      设置搜索路径以引导类和资源</span><br><span class="line">    -Xbootclasspath/a:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      附加在引导类路径末尾</span><br><span class="line">    -Xbootclasspath/p:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      置于引导类路径之前</span><br><span class="line">    -Xdiag            显示附加诊断消息</span><br><span class="line">    -Xnoclassgc       禁用类垃圾收集</span><br><span class="line">    -Xincgc           启用增量垃圾收集</span><br><span class="line">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)</span><br><span class="line">    -Xbatch           禁用后台编译</span><br><span class="line">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class="line">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class="line">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class="line">    -Xprof            输出 cpu 配置文件数据</span><br><span class="line">    -Xfuture          启用最严格的检查, 预期将来的默认值</span><br><span class="line">    -Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)</span><br><span class="line">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class="line">    -Xshare:off       不尝试使用共享类数据</span><br><span class="line">    -Xshare:auto      在可能的情况下使用共享类数据 (默认)</span><br><span class="line">    -Xshare:on        要求使用共享类数据, 否则将失败。</span><br><span class="line">    -XshowSettings    显示所有设置并继续</span><br><span class="line">    -XshowSettings:all</span><br><span class="line">                      显示所有设置并继续</span><br><span class="line">    -XshowSettings:vm 显示所有与 vm 相关的设置并继续</span><br><span class="line">    -XshowSettings:properties</span><br><span class="line">                      显示所有属性设置并继续</span><br><span class="line">    -XshowSettings:locale</span><br><span class="line">                      显示所有与区域设置相关的设置并继续</span><br><span class="line"></span><br><span class="line">-X 选项是非标准选项, 如有更改, 恕不另行通知。</span><br></pre></td></tr></table></figure>

<p>如何知道JVM默认使用的是混合模式呢？</p>
<p>同样地，通过java -version命令：可以看到 mixed mode 字样，代表当前系统使用的是混合模式</p>
<h3 id="类型三：-XX参数选项"><a href="#类型三：-XX参数选项" class="headerlink" title="类型三：-XX参数选项"></a>类型三：-XX参数选项</h3><p><strong>Boolean类型格式</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+&lt;option&gt;  启用option属性</span><br><span class="line">-XX:-&lt;option&gt;  禁用option属性</span><br></pre></td></tr></table></figure>

<p><strong>非Boolean类型格式</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:&lt;option&gt;=&lt;number&gt;  设置option数值，可以带单位如k/K/m/M/g/G</span><br><span class="line">-XX:&lt;option&gt;=&lt;string&gt;  设置option字符值</span><br></pre></td></tr></table></figure>

<h2 id="添加JVM参数选项"><a href="#添加JVM参数选项" class="headerlink" title="添加JVM参数选项"></a>添加JVM参数选项</h2><p>eclipse和idea中配置不必多说，在Run Configurations中VM Options中配置即可，大同小异</p>
<p><strong>运行jar包</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms100m -Xmx100m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -jar demo.jar</span><br></pre></td></tr></table></figure>

<p><strong>Tomcat运行war包</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> linux下catalina.sh添加</span></span><br><span class="line">JAVA_OPTS="-Xms512M -Xmx1024M"</span><br><span class="line"><span class="meta">#</span><span class="bash"> windows下catalina.bat添加</span></span><br><span class="line">set "JAVA_OPTS=-Xms512M -Xmx1024M"</span><br></pre></td></tr></table></figure>

<p><strong>程序运行中</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置Boolean类型参数</span></span><br><span class="line">jinfo -flag [+|-]&lt;name&gt; &lt;pid&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置非Boolean类型参数</span></span><br><span class="line">jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<h2 id="常用的JVM参数选项"><a href="#常用的JVM参数选项" class="headerlink" title="常用的JVM参数选项"></a>常用的JVM参数选项</h2><h3 id="打印设置的XX选项及值"><a href="#打印设置的XX选项及值" class="headerlink" title="打印设置的XX选项及值"></a>打印设置的XX选项及值</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags 程序运行时JVM默认设置或用户手动设置的XX选项</span><br><span class="line">-XX:+PrintFlagsInitial 打印所有XX选项的默认值</span><br><span class="line">-XX:+PrintFlagsFinal 打印所有XX选项的实际值</span><br><span class="line">-XX:+PrintVMOptions 打印JVM的参数</span><br></pre></td></tr></table></figure>

<h3 id="堆、栈、方法区等内存大小设置"><a href="#堆、栈、方法区等内存大小设置" class="headerlink" title="堆、栈、方法区等内存大小设置"></a>堆、栈、方法区等内存大小设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 栈</span></span><br><span class="line">-Xss128k &lt;==&gt; -XX:ThreadStackSize=128k 设置线程栈的大小为128K</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 堆</span></span><br><span class="line">-Xms2048m &lt;==&gt; -XX:InitialHeapSize=2048m 设置JVM初始堆内存为2048M</span><br><span class="line">-Xmx2048m &lt;==&gt; -XX:MaxHeapSize=2048m 设置JVM最大堆内存为2048M</span><br><span class="line">-Xmn2g &lt;==&gt; -XX:NewSize=2g -XX:MaxNewSize=2g 设置年轻代大小为2G</span><br><span class="line">-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8</span><br><span class="line">-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2</span><br><span class="line">-XX:+UseAdaptiveSizePolicy 设置大小比例自适应，默认开启</span><br><span class="line">-XX:PretenureSizeThreadshold=1024 设置让大于此阈值的对象直接分配在老年代，只对Serial、ParNew收集器有效</span><br><span class="line">-XX:MaxTenuringThreshold=15 设置新生代晋升老年代的年龄限制，默认为15</span><br><span class="line">-XX:TargetSurvivorRatio 设置MinorGC结束后Survivor区占用空间的期望比例</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法区</span></span><br><span class="line">-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M</span><br><span class="line">-XX:MaxMetaspaceSize / -XX:MaxPermSize=256m 设置元空间/永久代最大值为256M</span><br><span class="line">-XX:+UseCompressedOops 使用压缩对象</span><br><span class="line">-XX:+UseCompressedClassPointers 使用压缩类指针</span><br><span class="line">-XX:CompressedClassSpaceSize 设置Klass Metaspace的大小，默认1G</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接内存</span></span><br><span class="line">-XX:MaxDirectMemorySize 指定DirectMemory容量，默认等于Java堆最大值</span><br></pre></td></tr></table></figure>

<h3 id="OutOfMemory相关的选项"><a href="#OutOfMemory相关的选项" class="headerlink" title="OutOfMemory相关的选项"></a>OutOfMemory相关的选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件，两者互斥</span><br><span class="line">-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件，两者互斥</span><br><span class="line">-XX:HeapDumpPath=&lt;path&gt; 指定heap转储文件的存储路径，默认当前目录</span><br><span class="line">-XX:OnOutOfMemoryError=&lt;path&gt; 指定可行性程序或脚本的路径，当发生OOM时执行脚本</span><br></pre></td></tr></table></figure>

<h3 id="垃圾收集器相关选项"><a href="#垃圾收集器相关选项" class="headerlink" title="垃圾收集器相关选项"></a>垃圾收集器相关选项</h3><p>首先需了解垃圾收集器之间的搭配使用关系</p>
<ul>
<li>红色虚线表示在jdk8时被Deprecate，jdk9时被删除</li>
<li>绿色虚线表示在jdk14时被Deprecate</li>
<li>绿色虚框表示在jdk9时被Deprecate，jdk14时被删除</li>
</ul>
<p><img src="/images/java/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png" alt="垃圾收集器的组合关系.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Serial回收器</span></span><br><span class="line">-XX:+UseSerialGC  年轻代使用Serial GC， 老年代使用Serial Old GC</span><br><span class="line"><span class="meta">#</span><span class="bash"> ParNew回收器</span></span><br><span class="line">-XX:+UseParNewGC  年轻代使用ParNew GC</span><br><span class="line">-XX:ParallelGCThreads  设置年轻代并行收集器的线程数。</span><br><span class="line">	一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</span><br></pre></td></tr></table></figure>

<p>$$<br>ParallelGCThreads =<br>\begin{cases}<br>CPU_Count &amp; \text (CPU_Count &lt;= 8) \<br>3 + (5 * CPU＿Count / 8) &amp; \text (CPU_Count &gt; 8)<br>\end{cases}<br>$$</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Parallel回收器</span></span><br><span class="line">-XX:+UseParallelGC  年轻代使用 Parallel Scavenge GC，互相激活</span><br><span class="line">-XX:+UseParallelOldGC  老年代使用 Parallel Old GC，互相激活</span><br><span class="line">-XX:ParallelGCThreads</span><br><span class="line">-XX:MaxGCPauseMillis  设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒。</span><br><span class="line">	为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</span><br><span class="line">	对于用户来讲，停顿时间越短体验越好；但是服务器端注重高并发，整体的吞吐量。</span><br><span class="line">	所以服务器端适合Parallel，进行控制。该参数使用需谨慎。</span><br><span class="line">-XX:GCTimeRatio  垃圾收集时间占总时间的比例（1 / (N＋1)），用于衡量吞吐量的大小</span><br><span class="line">	取值范围（0,100），默认值99，也就是垃圾回收时间不超过1％。</span><br><span class="line">	与前一个-XX：MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</span><br><span class="line">-XX:+UseAdaptiveSizePolicy  设置Parallel Scavenge收集器具有自适应调节策略。</span><br><span class="line">	在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。</span><br><span class="line">	在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CMS回收器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC  年轻代使用CMS GC。</span><br><span class="line">	开启该参数后会自动将-XX：＋UseParNewGC打开。即：ParNew（Young区）+ CMS（Old区）+ Serial Old的组合</span><br><span class="line">-XX:CMSInitiatingOccupanyFraction  设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68，DK6及以上版本默认值为92％。</span><br><span class="line">	如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。</span><br><span class="line">	反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。</span><br><span class="line">	因此通过该选项便可以有效降低Fu1l GC的执行次数。</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly  是否动态可调，使CMS一直按CMSInitiatingOccupancyFraction设定的值启动</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection  用于指定在执行完Full GC后对内存空间进行压缩整理</span><br><span class="line">	以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction  设置在执行多少次Full GC后对内存空间进行压缩整理。</span><br><span class="line">-XX:ParallelCMSThreads  设置CMS的线程数量。</span><br><span class="line">	CMS 默认启动的线程数是(ParallelGCThreads＋3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。</span><br><span class="line">	当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</span><br><span class="line">-XX:ConcGCThreads  设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的</span><br><span class="line">-XX:+CMSScavengeBeforeRemark  强制hotspot在cms remark阶段之前做一次minor gc，用于提高remark阶段的速度</span><br><span class="line">-XX:+CMSClassUnloadingEnable  如果有的话，启用回收Perm 区（JDK8之前）</span><br><span class="line">-XX:+CMSParallelInitialEnabled  用于开启CMS initial-mark阶段采用多线程的方式进行标记</span><br><span class="line">	用于提高标记速度，在Java8开始已经默认开启</span><br><span class="line">-XX:+CMSParallelRemarkEnabled  用户开启CMS remark阶段采用多线程的方式进行重新标记，默认开启</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrent</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</span><br><span class="line">	这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期</span><br><span class="line">-XX:+CMSPrecleaningEnabled  指定CMS是否需要进行Pre cleaning阶段</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> G1回收器</span></span><br><span class="line">-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务。</span><br><span class="line">-XX:G1HeapRegionSize 设置每个Region的大小。</span><br><span class="line">	值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</span><br><span class="line">-XX:MaxGCPauseMillis  设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</span><br><span class="line">-XX:ParallelGCThread  设置STW时GC线程数的值。最多设置为8</span><br><span class="line">-XX:ConcGCThreads  设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</span><br><span class="line">-XX:G1NewSizePercent  新生代占用整个堆内存的最小百分比（默认5％）</span><br><span class="line">-XX:G1MaxNewSizePercent  新生代占用整个堆内存的最大百分比（默认60％）</span><br><span class="line">-XX:G1ReservePercent=10  保留内存区域，防止 to space（Survivor中的to区）溢出</span><br></pre></td></tr></table></figure>

<p>怎么选择垃圾回收器？</p>
<ul>
<li>优先让JVM自适应，调整堆的大小</li>
<li>串行收集器：内存小于100M；单核、单机程序，并且没有停顿时间的要求</li>
<li>并行收集器：多CPU、高吞吐量、允许停顿时间超过1秒</li>
<li>并发收集器：多CPU、追求低停顿时间、快速响应（比如延迟不能超过1秒，如互联网应用）</li>
<li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1</li>
</ul>
<p>特别说明：</p>
<ul>
<li>没有最好的收集器，更没有万能的收集器</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ul>
<h3 id="GC日志相关选项"><a href="#GC日志相关选项" class="headerlink" title="GC日志相关选项"></a>GC日志相关选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC &lt;==&gt; -verbose:gc  打印简要日志信息</span><br><span class="line">-XX:+PrintGCDetails            打印详细日志信息</span><br><span class="line">-XX:+PrintGCTimeStamps  打印程序启动到GC发生的时间，搭配-XX:+PrintGCDetails使用</span><br><span class="line">-XX:+PrintGCDateStamps  打印GC发生时的时间戳，搭配-XX:+PrintGCDetails使用</span><br><span class="line">-XX:+PrintHeapAtGC  打印GC前后的堆信息，如下图</span><br><span class="line">-Xloggc:&lt;file&gt; 输出GC导指定路径下的文件中</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+TraceClassLoading  监控类的加载</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime  打印GC时线程的停顿时间</span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime  打印垃圾收集之前应用未中断的执行时间</span><br><span class="line">-XX:+PrintReferenceGC 打印回收了多少种不同引用类型的引用</span><br><span class="line">-XX:+PrintTenuringDistribution  打印JVM在每次MinorGC后当前使用的Survivor中对象的年龄分布</span><br><span class="line">-XX:+UseGCLogFileRotation 启用GC日志文件的自动转储</span><br><span class="line">-XX:NumberOfGCLogFiles=1  设置GC日志文件的循环数目</span><br><span class="line">-XX:GCLogFileSize=1M  设置GC日志文件的大小</span><br></pre></td></tr></table></figure>

<h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DisableExplicitGC  禁用hotspot执行System.gc()，默认禁用</span><br><span class="line">-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]、-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]  指定代码缓存的大小</span><br><span class="line">-XX:+UseCodeCacheFlushing  放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况</span><br><span class="line">-XX:+DoEscapeAnalysis  开启逃逸分析</span><br><span class="line">-XX:+UseBiasedLocking  开启偏向锁</span><br><span class="line">-XX:+UseLargePages  开启使用大页面</span><br><span class="line">-XX:+PrintTLAB  打印TLAB的使用情况</span><br><span class="line">-XX:TLABSize  设置TLAB大小</span><br></pre></td></tr></table></figure>

<h2 id="通过Java代码获取JVM参数"><a href="#通过Java代码获取JVM参数" class="headerlink" title="通过Java代码获取JVM参数"></a>通过Java代码获取JVM参数</h2><p>Java提供了java.lang.management包用于监视和管理Java虚拟机和Java运行时中的其他组件，它允许本地或远程监控和管理运行的Java虚拟机。其中ManagementFactory类较为常用，另外Runtime类可获取内存、CPU核数等相关的数据。通过使用这些api，可以监控应用服务器的堆内存使用情况，设置一些阈值进行报警等处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MemoryMonitor &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MemoryMXBean memorymbean &#x3D; ManagementFactory.getMemoryMXBean();</span><br><span class="line">        MemoryUsage usage &#x3D; memorymbean.getHeapMemoryUsage();</span><br><span class="line">        System.out.println(&quot;INIT HEAP: &quot; + usage.getInit() &#x2F; 1024 &#x2F; 1024 + &quot;m&quot;);</span><br><span class="line">        System.out.println(&quot;MAX HEAP: &quot; + usage.getMax() &#x2F; 1024 &#x2F; 1024 + &quot;m&quot;);</span><br><span class="line">        System.out.println(&quot;USE HEAP: &quot; + usage.getUsed() &#x2F; 1024 &#x2F; 1024 + &quot;m&quot;);</span><br><span class="line">        System.out.println(&quot;\nFull Information:&quot;);</span><br><span class="line">        System.out.println(&quot;Heap Memory Usage: &quot; + memorymbean.getHeapMemoryUsage());</span><br><span class="line">        System.out.println(&quot;Non-Heap Memory Usage: &quot; + memorymbean.getNonHeapMemoryUsage());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;通过java来获取相关系统状态&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;);</span><br><span class="line">        System.out.println(&quot;当前堆内存大小totalMemory &quot; + (int) Runtime.getRuntime().totalMemory() &#x2F; 1024 &#x2F; 1024 + &quot;m&quot;);&#x2F;&#x2F; 当前堆内存大小</span><br><span class="line">        System.out.println(&quot;空闲堆内存大小freeMemory &quot; + (int) Runtime.getRuntime().freeMemory() &#x2F; 1024 &#x2F; 1024 + &quot;m&quot;);&#x2F;&#x2F; 空闲堆内存大小</span><br><span class="line">        System.out.println(&quot;最大可用总堆内存maxMemory &quot; + Runtime.getRuntime().maxMemory() &#x2F; 1024 &#x2F; 1024 + &quot;m&quot;);&#x2F;&#x2F; 最大可用总堆内存大小</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分析GC日志"><a href="#分析GC日志" class="headerlink" title="分析GC日志"></a>分析GC日志</h1><h2 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h2><p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p>
<ul>
<li><p>部分收集（Partial GC）：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li>新生代收集（Minor GC / Young GC）：只是新生代（Eden / S0, S1）的垃圾收集</li>
<li>老年代收集（Major GC / Old GC）：只是老年代的垃圾收集。目前，只有CMS GC会有单独收集老年代的行为。<mark>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</mark></li>
</ul>
</li>
<li><p>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</p>
</li>
<li><p>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。</p>
</li>
</ul>
<h2 id="GC日志分类"><a href="#GC日志分类" class="headerlink" title="GC日志分类"></a>GC日志分类</h2><p><strong>MinorGC</strong></p>
<p>MinorGC（或young GC或YGC）日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">31744</span>K-&gt;<span class="number">2192</span>K (<span class="number">36864</span>K) ] <span class="number">31744</span>K-&gt;<span class="number">2200</span>K (<span class="number">121856</span>K), <span class="number">0.0139308</span> secs] [Times: user=<span class="number">0.05</span> sys=<span class="number">0.01</span>, real=<span class="number">0.01</span> secs]</span><br></pre></td></tr></table></figure>

<p>![Young GC日志分析.png](/images/java/jvm/Young GC日志分析.png)</p>
<p><strong>FullGC</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span> [PSYoungGen: 5104K-&gt;0<span class="title">K</span> <span class="params">(<span class="number">132096</span>K)</span> ] [Par01dGen: 416K-&gt;5453<span class="title">K</span> <span class="params">(<span class="number">50176</span>K)</span> ]5520K-&gt;5453<span class="title">K</span> <span class="params">(<span class="number">182272</span>K)</span>, [Metaspace: 20637K-&gt;20637<span class="title">K</span> <span class="params">(<span class="number">1067008</span>K)</span> ], 0.0245883 secs] [Times: user</span>=<span class="number">0.06</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></table></figure>

<p>![Full GC日志分析.png](/images/java/jvm/Full GC日志分析.png)</p>
<h2 id="GC日志结构剖析"><a href="#GC日志结构剖析" class="headerlink" title="GC日志结构剖析"></a>GC日志结构剖析</h2><p><strong>透过日志看垃圾收集器</strong></p>
<ul>
<li><p>Serial收集器：新生代显示 “[DefNew”，即 Default New Generation</p>
</li>
<li><p>ParNew收集器：新生代显示 “[ParNew”，即 Parallel New Generation</p>
</li>
<li><p>Parallel Scavenge收集器：新生代显示”[PSYoungGen”，JDK1.7使用的即PSYoungGen</p>
</li>
<li><p>Parallel Old收集器：老年代显示”[ParoldGen”</p>
</li>
<li><p>G1收集器：显示”garbage-first heap“</p>
</li>
</ul>
<p><strong>透过日志看GC原因</strong></p>
<ul>
<li>Allocation Failure：表明本次引起GC的原因是因为新生代中没有足够的区域存放需要分配的数据</li>
<li>Metadata GCThreshold：Metaspace区不够用了</li>
<li>FErgonomics：JVM自适应调整导致的GC</li>
<li>System：调用了System.gc()方法</li>
</ul>
<p><strong>透过日志看GC前后情况</strong></p>
<p>通过图示，我们可以发现GC日志格式的规律一般都是：GC前内存占用-＞GC后内存占用（该区域内存总大小）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PSYoungGen: <span class="number">5986</span>K-&gt;<span class="number">696</span>K (<span class="number">8704</span>K) ] <span class="number">5986</span>K-&gt;<span class="number">704</span>K (<span class="number">9216</span>K)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>中括号内：GC回收前年轻代堆大小，回收后大小，（年轻代堆总大小）</p>
</li>
<li><p>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p>
</li>
</ul>
<p><mark>注意</mark>：Minor GC堆内存总容量 = 9/10 年轻代 + 老年代。原因是Survivor区只计算from部分，而JVM默认年轻代中Eden区和Survivor区的比例关系，Eden:S0:S1=8:1:1。</p>
<p><strong>透过日志看GC时间</strong></p>
<p>GC日志中有三个时间：user，sys和real</p>
<ul>
<li>user：进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际CPU 时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示GC线程执行所使用的 CPU 总时间。</li>
<li>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的CPU 时间</li>
<li>real：程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I/O 完成）。对于并行gc，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数。</li>
</ul>
<p>由于多核的原因，一般的GC事件中，real time是小于sys time＋user time的，因为一般是多个线程并发的去做GC，所以real time是要小于sys＋user time的。如果real＞sys＋user的话，则你的应用可能存在下列问题：IO负载非常重或CPU不够用。</p>
<h2 id="GC日志分析工具"><a href="#GC日志分析工具" class="headerlink" title="GC日志分析工具"></a>GC日志分析工具</h2><p><strong>GCEasy</strong></p>
<p>GCEasy是一款在线的GC日志分析器，可以通过GC日志分析进行内存泄露检测、GC暂停原因分析、JVM配置建议优化等功能，大多数功能是免费的。</p>
<p>官网地址：<a href="https://gceasy.io/" target="_blank" rel="noopener">https://gceasy.io/</a></p>
<p><strong>GCViewer</strong></p>
<p>GCViewer是一款离线的GC日志分析器，用于可视化Java VM选项 -verbose:gc 和 .NET生成的数据 -Xloggc:&lt;file&gt;。还可以计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等）。当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用。</p>
<p>源码下载：<a href="https://github.com/chewiebug/GCViewer" target="_blank" rel="noopener">https://github.com/chewiebug/GCViewer</a></p>
<p>运行版本下载：<a href="https://github.com/chewiebug/GCViewer/wiki/Changelog" target="_blank" rel="noopener">https://github.com/chewiebug/GCViewer/wiki/Changelog</a></p>
<p><strong>GChisto</strong></p>
<ul>
<li>官网上没有下载的地方，需要自己从SVN上拉下来编译</li>
<li>不过这个工具似乎没怎么维护了，存在不少bug</li>
</ul>
<p><strong>HPjmeter</strong></p>
<ul>
<li>工具很强大，但是只能打开由以下参数生成的GC log，-verbose:gc  -Xloggc:gc.log。添加其他参数生成的gc.log无法打开</li>
<li>HPjmeter集成了以前的HPjtune功能，可以分析在HP机器上产生的垃圾回收日志文件</li>
</ul>
<h1 id="补充：使用OQL语言查询对象信息"><a href="#补充：使用OQL语言查询对象信息" class="headerlink" title="补充：使用OQL语言查询对象信息"></a>补充：使用OQL语言查询对象信息</h1><p>MAT支持一种类似于SQL的查询语言OQL（Object Query Language）。OQL使用类SQL语法，可以在堆中进行对象的查找和筛选。</p>
<h2 id="SELECT子句"><a href="#SELECT子句" class="headerlink" title="SELECT子句"></a>SELECT子句</h2><p>在MAT中，Select子句的格式与SQL基本一致，用于指定要显示的列。Select子句中可以使用“＊”，查看结果对象的引用实例（相当于outgoing references）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> java.util.Vector v</span><br></pre></td></tr></table></figure>

<p>使用“OBJECTS”关键字，可以将返回结果集中的项以对象的形式显示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> objects v.elementData <span class="keyword">FROM</span> java.util.Vector v</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> OBJECTS s.value <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></table></figure>

<p>在Select子句中，使用“AS RETAINED SET”关键字可以得到所得对象的保留集。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AS</span> RETAINED <span class="keyword">SET</span> *<span class="keyword">FROM</span> com.atguigu.mat.Student</span><br></pre></td></tr></table></figure>

<p>“DISTINCT”关键字用于在结果集中去除重复对象。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> OBJECTS classof(s) <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></table></figure>

<h2 id="FROM子句"><a href="#FROM子句" class="headerlink" title="FROM子句"></a>FROM子句</h2><p>From子句用于指定查询范围，它可以指定类名、正则表达式或者对象地址。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></table></figure>

<p>使用正则表达式，限定搜索范围，输出所有com.atguigu包下所有类的实例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">"com\.atguigu\..*"</span></span><br></pre></td></tr></table></figure>

<p>使用类的地址进行搜索。使用类的地址的好处是可以区分被不同ClassLoader加载的同一种类型。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="number">0x37a0b4d</span></span><br></pre></td></tr></table></figure>

<h2 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h2><p>Where子句用于指定OQL的查询条件。OQL查询将只返回满足Where子句指定条件的对象。Where子句的格式与传统SQL极为相似。</p>
<p>返回长度大于10的char数组。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> Ichar[] s <span class="keyword">WHERE</span> s.@<span class="keyword">length</span>&gt;<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>返回包含“java”子字符串的所有字符串，使用“LIKE”操作符，“LIKE”操作符的操作参数为正则表达式。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> java.lang.String s <span class="keyword">WHERE</span> toString(s) <span class="keyword">LIKE</span> <span class="string">".*java.*"</span></span><br></pre></td></tr></table></figure>

<p>返回所有value域不为null的字符串，使用“＝”操作符。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> java.lang.String s <span class="keyword">where</span> s.value!=<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>返回数组长度大于15，并且深堆大于1000字节的所有Vector对象。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> java.util.Vector v <span class="keyword">WHERE</span> v.elementData.@<span class="keyword">length</span>&gt;<span class="number">15</span> <span class="keyword">AND</span> v.@retainedHeapSize&gt;<span class="number">1000</span></span><br></pre></td></tr></table></figure>

<h2 id="内置对象与方法"><a href="#内置对象与方法" class="headerlink" title="内置对象与方法"></a>内置对象与方法</h2><p>OQL中可以访问堆内对象的属性，也可以访问堆内代理对象的属性。访问堆内对象的属性时，格式如下，其中alias为对象名称：</p>
<p>[ &lt;alias&gt;. ] &lt;field&gt; . &lt;field&gt;. &lt;field&gt;</p>
<p>访问java.io.File对象的path属性，并进一步访问path的value属性：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> toString(f.path.value) <span class="keyword">FROM</span> java.io.File f</span><br></pre></td></tr></table></figure>

<p>显示String对象的内容、objectid和objectAddress。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.toString(),s.@objectId, s.@objectAddress <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></table></figure>

<p>显示java.util.Vector内部数组的长度。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> v.elementData.@<span class="keyword">length</span> <span class="keyword">FROM</span> java.util.Vector v</span><br></pre></td></tr></table></figure>

<p>显示所有的java.util.Vector对象及其子类型</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> INSTANCEOF java.util.Vector</span><br></pre></td></tr></table></figure>

<h1 id="补充：浅堆深堆与内存泄露"><a href="#补充：浅堆深堆与内存泄露" class="headerlink" title="补充：浅堆深堆与内存泄露"></a>补充：浅堆深堆与内存泄露</h1><h2 id="浅堆（Shallow-Heap）"><a href="#浅堆（Shallow-Heap）" class="headerlink" title="浅堆（Shallow Heap）"></a>浅堆（Shallow Heap）</h2><p>浅堆是指一个对象所消耗的内存。在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。根据堆快照格式不同，对象的大小可能会同8字节进行对齐。</p>
<p>以String为例：2个int值共占8字节，对象引用占用4字节，对象头8字节，合计20字节，向8字节对齐，故占24字节。（jdk7中）</p>
<table>
<thead>
<tr>
<th>int</th>
<th>hash32</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td><strong>int</strong></td>
<td><strong>hash</strong></td>
<td><strong>0</strong></td>
</tr>
<tr>
<td><strong>ref</strong></td>
<td><strong>value</strong></td>
<td><strong>C:\Users\Administrat</strong></td>
</tr>
</tbody></table>
<p>这24字节为String对象的浅堆大小。它与String的value实际取值无关，无论字符串长度如何，浅堆大小始终是24字节。</p>
<h2 id="保留集（Retained-Set）"><a href="#保留集（Retained-Set）" class="headerlink" title="保留集（Retained Set）"></a>保留集（Retained Set）</h2><p>对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合（包括对象A本身），即对象A的保留集可以被认为是只能通过对象A被直接或间接访问到的所有对象的集合。通俗地说，就是指仅被对象A所持有的对象的集合。</p>
<h2 id="深堆（Retained-Heap）"><a href="#深堆（Retained-Heap）" class="headerlink" title="深堆（Retained Heap）"></a>深堆（Retained Heap）</h2><p>深堆是指对象的保留集中所有的对象的浅堆大小之和。</p>
<p>注意：浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。</p>
<h2 id="对象的实际大小"><a href="#对象的实际大小" class="headerlink" title="对象的实际大小"></a>对象的实际大小</h2><p>这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，但实际上，这个概念和垃圾回收无关。</p>
<p>下图显示了一个简单的对象引用关系图，对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。</p>
<p><img src="/images/java/jvm/%E6%B5%85%E5%A0%86%E6%B7%B1%E5%A0%86%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.png" alt="浅堆深堆案例分析.png"></p>
<h2 id="支配树（Dominator-Tree）"><a href="#支配树（Dominator-Tree）" class="headerlink" title="支配树（Dominator Tree）"></a>支配树（Dominator Tree）</h2><p>支配树的概念源自图论。MAT提供了一个称为支配树（Dominator Tree）的对象图。支配树体现了对象实例间的支配关系。在对象引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B。如果对象A是离对象B最近的一个支配对象，则认为对象A为对象B的直接支配者。支配树是基于对象间的引用图所建立的，它有以下基本性质：</p>
<ul>
<li>对象A的子树（所有被对象A支配的对象集合）表示对象A的保留集（retained set），即深堆。</li>
<li>如果对象A支配对象B，那么对象A的直接支配者也支配对象B。</li>
<li>支配树的边与对象引用图的边不直接对应。</li>
</ul>
<p>如下图所示：左图表示对象引用图，右图表示左图所对应的支配树。对象A和B由根对象直接支配，由于在到对象C的路径中，可以经过A，也可以经过B，因此对象C的直接支配者也是根对象。对象F与对象D相互引用，因为到对象F的所有路径必然经过对象D，因此，对象D是对象F的直接支配者。而到对象D的所有路径中，必然经过对象C，即使是从对象F到对象D的引用，从根节点出发，也是经过对象C的，所以，对象D的直接支配者为对象C。同理，对象E支配对象G。到达对象H的可以通过对象D，也可以通过对象E，因此对象D和E都不能支配对象H，而经过对象C既可以到达D也可以到达E，因此对象C为对象H的直接支配者。</p>
<p><img src="/images/java/jvm/%E6%94%AF%E9%85%8D%E6%A0%91.png" alt="支配树.png"></p>
<h2 id="内存泄漏（memory-leak）"><a href="#内存泄漏（memory-leak）" class="headerlink" title="内存泄漏（memory leak）"></a>内存泄漏（memory leak）</h2><p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题（让JVM误以为此对象还在引用中，无法回收，造成内存泄漏）。</p>
<p>＞ 是否还被使用？是</p>
<p>＞ 是否还被需要？否</p>
<p><img src="/images/java/jvm/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.png" alt="内存泄漏.png"></p>
<p>严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致00M，也可以叫做宽泛意义上的“内存泄漏”。</p>
<p>如下图，当Y生命周期结束的时候，X依然引用着Y，这时候，垃圾回收期是不会回收对象Y的；如果对象X还引用着生命周期比较短的A、B、C，对象A又引用着对象 a、b、c，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。</p>
<p><img src="/images/java/jvm/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F2.png" alt="内存泄漏2.png"></p>
<p>申请了内存用完了不释放，比如一共有1024M的内存，分配了512M的内存一直不回收，那么可以用的内存只有512M了，仿佛泄露掉了一部分；通俗一点讲的话，内存泄漏就是【占着茅坑不拉shi】</p>
<h2 id="内存溢出（out-of-memory）"><a href="#内存溢出（out-of-memory）" class="headerlink" title="内存溢出（out of memory）"></a>内存溢出（out of memory）</h2><p>申请内存时，没有足够的内存可以使用；通俗一点儿讲，一个厕所就三个坑，有两个站着茅坑不走的（内存泄漏），剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位（内存）就不够了，内存泄漏变成内存溢出了。可见，内存泄漏和内存溢出的关系：内存泄漏的增多，最终会导致内存溢出。</p>
<p><mark>泄漏的分类</mark></p>
<ul>
<li>经常发生：发生内存泄露的代码会被多次执行，每次执行，泄露一块内存；</li>
<li>偶然发生：在某些特定情况下才会发生</li>
<li>一次性：发生内存泄露的方法只会执行一次；</li>
<li>隐式泄漏：一直占着内存不释放，直到执行结束；严格的说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。</li>
</ul>
<h2 id="Java中内存泄露的8种情况"><a href="#Java中内存泄露的8种情况" class="headerlink" title="Java中内存泄露的8种情况"></a>Java中内存泄露的8种情况</h2><h3 id="静态集合类"><a href="#静态集合类" class="headerlink" title="静态集合类"></a>静态集合类</h3><p>静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oomTests</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object obj＝<span class="keyword">new</span> Object();<span class="comment">//局部变量</span></span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式，和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</p>
<h3 id="内部类持有外部类"><a href="#内部类持有外部类" class="headerlink" title="内部类持有外部类"></a>内部类持有外部类</h3><p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p>
<h3 id="各种连接，如数据库连接、网络连接和IO连接等"><a href="#各种连接，如数据库连接、网络连接和IO连接等" class="headerlink" title="各种连接，如数据库连接、网络连接和IO连接等"></a>各种连接，如数据库连接、网络连接和IO连接等</h3><p>在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Connection conn =<span class="keyword">null</span>;</span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        conn =DriverManager.getConnection(<span class="string">"url"</span>,<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line">        Statement stmt =conn.createStatement();</span><br><span class="line">        ResultSet rs =stmt.executeQuery(<span class="string">"...."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>（Exception e）&#123;<span class="comment">//异常日志</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 1．关闭结果集 Statement</span></span><br><span class="line">        <span class="comment">// 2．关闭声明的对象 ResultSet</span></span><br><span class="line">        <span class="comment">// 3．关闭连接 Connection</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量不合理的作用域"><a href="#变量不合理的作用域" class="headerlink" title="变量不合理的作用域"></a>变量不合理的作用域</h3><p>变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        readFromNet();<span class="comment">//从网络中接受数据保存到msg中</span></span><br><span class="line">        saveDB();<span class="comment">//把msg保存到数据库中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面这个伪代码，通过readFromNet方法把接受的消息保存在变量msg中，然后调用saveDB方法把msg的内容保存到数据库中，此时msg已经就没用了，由于msg的生命周期与对象的生命周期相同，此时msg还不能回收，因此造成了内存泄漏。实际上这个msg变量可以放在receiveMsg方法内部，当方法使用完，那么msg的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完msg后，把msg设置为null，这样垃圾回收器也会回收msg的内存空间。</p>
<h3 id="改变哈希值"><a href="#改变哈希值" class="headerlink" title="改变哈希值"></a>改变哈希值</h3><p>改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。</p>
<p>否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。</p>
<p>这也是 String 为什么被设置成了不可变类型，我们可以放心地把 String 存入 HashSet，或者把String 当做 HashMap 的 key 值；</p>
<p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的 hashCode 不可变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeHashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">"AA"</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">"BB"</span>);</span><br><span class="line"></span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line"></span><br><span class="line">        p1.name = <span class="string">"CC"</span>;<span class="comment">//导致了内存的泄漏</span></span><br><span class="line">        set.remove(p1); <span class="comment">//删除失败</span></span><br><span class="line"></span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">"CC"</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">"AA"</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != person.id) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(person.name) : person.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeHashCode1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Point&gt; hs = <span class="keyword">new</span> HashSet&lt;Point&gt;();</span><br><span class="line">        Point cc = <span class="keyword">new</span> Point();</span><br><span class="line">        cc.setX(<span class="number">10</span>);<span class="comment">//hashCode = 41</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line"></span><br><span class="line">        cc.setX(<span class="number">20</span>);<span class="comment">//hashCode = 51  此行为导致了内存的泄漏</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"hs.remove = "</span> + hs.remove(cc));<span class="comment">//false</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line">        System.out.println(<span class="string">"hs.size = "</span> + hs.size());<span class="comment">//size = 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(hs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        result = prime * result + x;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Point other = (Point) obj;</span><br><span class="line">        <span class="keyword">if</span> (x != other.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Point&#123;"</span> +</span><br><span class="line">                <span class="string">"x="</span> + x +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存泄露"><a href="#缓存泄露" class="headerlink" title="缓存泄露"></a>缓存泄露</h3><p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如：之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存（内存）中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p>
<p>对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map wMap = <span class="keyword">new</span> WeakHashMap();</span><br><span class="line">    <span class="keyword">static</span> Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        testWeakHashMap();</span><br><span class="line">        testHashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String ref1 = <span class="keyword">new</span> String(<span class="string">"obejct1"</span>);</span><br><span class="line">        String ref2 = <span class="keyword">new</span> String(<span class="string">"obejct2"</span>);</span><br><span class="line">        String ref3 = <span class="keyword">new</span> String(<span class="string">"obejct3"</span>);</span><br><span class="line">        String ref4 = <span class="keyword">new</span> String(<span class="string">"obejct4"</span>);</span><br><span class="line">        wMap.put(ref1, <span class="string">"cacheObject1"</span>);</span><br><span class="line">        wMap.put(ref2, <span class="string">"cacheObject2"</span>);</span><br><span class="line">        map.put(ref3, <span class="string">"cacheObject3"</span>);</span><br><span class="line">        map.put(ref4, <span class="string">"cacheObject4"</span>);</span><br><span class="line">        System.out.println(<span class="string">"String引用ref1，ref2，ref3，ref4 消失"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"WeakHashMap GC之前"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"WeakHashMap GC之后"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HashMap GC之前"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"HashMap GC之后"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码和图示主演演示WeakHashMap如何自动释放缓存对象，当init函数执行完成后，局部变量字符串引用weakd1，weakd2，d1，d2都会消失，此时只有静态map中保存中对字符串对象的引用，可以看到，调用gc之后，HashMap的没有被回收，而WeakHashMap里面的缓存被回收了。</p>
<h3 id="监听器和其他回调"><a href="#监听器和其他回调" class="headerlink" title="监听器和其他回调"></a>监听器和其他回调</h3><p>内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。</p>
<p>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为WeakHashMap中的键。</p>
<h2 id="内存泄露案例分析"><a href="#内存泄露案例分析" class="headerlink" title="内存泄露案例分析"></a>内存泄露案例分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123; <span class="comment">//入栈</span></span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序并没有明显的错误，但是这段程序有一个内存泄漏，随着GC活动的增加，或者内存占用的不断增加，程序性能的降低就会表现出来，严重时可导致内存泄漏，但是这种失败情况相对较少。</p>
<p>代码的主要问题在pop函数，下面通过这张图示展现。假设这个栈一直增长，增长后如下图所示</p>
<p><img src="/images/java/jvm/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.png" alt="内存泄漏案例分析.png"></p>
<p>当进行大量的pop操作时，由于引用未进行置空，gc是不会释放的，如下图所示</p>
<p><img src="/images/java/jvm/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%902.png" alt="内存泄漏案例分析2.png"></p>
<p>从上图中看以看出，如果栈先增长，再收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些队象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称过期引用，这个内存泄露很隐蔽。</p>
<p>将代码中的pop()方法变成如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    Object result = elements[--size];</span><br><span class="line">    elements[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦引用过期，清空这些引用，将引用置空。</p>
<p><img src="/images/java/jvm/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%903.png" alt="内存泄漏案例分析3.png"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/JVM/" rel="tag"># JVM</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/04/java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/" rel="prev" title="JVM 学习笔记 - 字节码与类的加载器">
      <i class="fa fa-chevron-left"></i> JVM 学习笔记 - 字节码与类的加载器
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/10/database/ES/" rel="next" title="ES">
      ES <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#性能优化的步骤"><span class="nav-number">1.1.</span> <span class="nav-text">性能优化的步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能评价-测试指标"><span class="nav-number">1.2.</span> <span class="nav-text">性能评价&#x2F;测试指标</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM监控及诊断工具-命令行"><span class="nav-number">2.</span> <span class="nav-text">JVM监控及诊断工具-命令行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#jps-查看Java进程"><span class="nav-number">2.1.</span> <span class="nav-text">jps 查看Java进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jstat查看JVM统计信息"><span class="nav-number">2.2.</span> <span class="nav-text">jstat查看JVM统计信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本语法"><span class="nav-number">2.2.1.</span> <span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jstat判断内存泄漏"><span class="nav-number">2.2.2.</span> <span class="nav-text">jstat判断内存泄漏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jinfo实时查看-修改JVM参数"><span class="nav-number">2.3.</span> <span class="nav-text">jinfo实时查看,修改JVM参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本语法-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">基本语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jmap导出内存映像文件和内存使用情况"><span class="nav-number">2.4.</span> <span class="nav-text">jmap导出内存映像文件和内存使用情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#导出内存映射文件"><span class="nav-number">2.4.1.</span> <span class="nav-text">导出内存映射文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显示堆内存相关信息"><span class="nav-number">2.4.2.</span> <span class="nav-text">显示堆内存相关信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他作用"><span class="nav-number">2.4.3.</span> <span class="nav-text">其他作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">2.4.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jhat分析dump文件工具"><span class="nav-number">2.5.</span> <span class="nav-text">jhat分析dump文件工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#option参数"><span class="nav-number">2.5.1.</span> <span class="nav-text">option参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jstack打印JVM线程快照"><span class="nav-number">2.6.</span> <span class="nav-text">jstack打印JVM线程快照</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jcmd多功能命令行"><span class="nav-number">2.7.</span> <span class="nav-text">jcmd多功能命令行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jstatd远程主机信息收集"><span class="nav-number">2.8.</span> <span class="nav-text">jstatd远程主机信息收集</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM监控及诊断工具-GUI篇"><span class="nav-number">3.</span> <span class="nav-text">JVM监控及诊断工具-GUI篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#工具概述"><span class="nav-number">3.1.</span> <span class="nav-text">工具概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JConsole"><span class="nav-number">3.2.</span> <span class="nav-text">JConsole</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Visual-VM"><span class="nav-number">3.3.</span> <span class="nav-text">Visual VM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Eclipse-MAT"><span class="nav-number">3.4.</span> <span class="nav-text">Eclipse MAT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JProfiler"><span class="nav-number">3.5.</span> <span class="nav-text">JProfiler</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arthas"><span class="nav-number">3.6.</span> <span class="nav-text">Arthas</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-Misssion-Control"><span class="nav-number">3.7.</span> <span class="nav-text">Java Misssion Control</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他工具"><span class="nav-number">3.8.</span> <span class="nav-text">其他工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM运行时参数"><span class="nav-number">4.</span> <span class="nav-text">JVM运行时参数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM参数选项"><span class="nav-number">4.1.</span> <span class="nav-text">JVM参数选项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型一：标准参数选项"><span class="nav-number">4.1.1.</span> <span class="nav-text">类型一：标准参数选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型二：-X参数选项"><span class="nav-number">4.1.2.</span> <span class="nav-text">类型二：-X参数选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型三：-XX参数选项"><span class="nav-number">4.1.3.</span> <span class="nav-text">类型三：-XX参数选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加JVM参数选项"><span class="nav-number">4.2.</span> <span class="nav-text">添加JVM参数选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用的JVM参数选项"><span class="nav-number">4.3.</span> <span class="nav-text">常用的JVM参数选项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#打印设置的XX选项及值"><span class="nav-number">4.3.1.</span> <span class="nav-text">打印设置的XX选项及值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆、栈、方法区等内存大小设置"><span class="nav-number">4.3.2.</span> <span class="nav-text">堆、栈、方法区等内存大小设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OutOfMemory相关的选项"><span class="nav-number">4.3.3.</span> <span class="nav-text">OutOfMemory相关的选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾收集器相关选项"><span class="nav-number">4.3.4.</span> <span class="nav-text">垃圾收集器相关选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC日志相关选项"><span class="nav-number">4.3.5.</span> <span class="nav-text">GC日志相关选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他参数"><span class="nav-number">4.3.6.</span> <span class="nav-text">其他参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过Java代码获取JVM参数"><span class="nav-number">4.4.</span> <span class="nav-text">通过Java代码获取JVM参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分析GC日志"><span class="nav-number">5.</span> <span class="nav-text">分析GC日志</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GC分类"><span class="nav-number">5.1.</span> <span class="nav-text">GC分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC日志分类"><span class="nav-number">5.2.</span> <span class="nav-text">GC日志分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC日志结构剖析"><span class="nav-number">5.3.</span> <span class="nav-text">GC日志结构剖析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC日志分析工具"><span class="nav-number">5.4.</span> <span class="nav-text">GC日志分析工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#补充：使用OQL语言查询对象信息"><span class="nav-number">6.</span> <span class="nav-text">补充：使用OQL语言查询对象信息</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SELECT子句"><span class="nav-number">6.1.</span> <span class="nav-text">SELECT子句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FROM子句"><span class="nav-number">6.2.</span> <span class="nav-text">FROM子句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WHERE子句"><span class="nav-number">6.3.</span> <span class="nav-text">WHERE子句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内置对象与方法"><span class="nav-number">6.4.</span> <span class="nav-text">内置对象与方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#补充：浅堆深堆与内存泄露"><span class="nav-number">7.</span> <span class="nav-text">补充：浅堆深堆与内存泄露</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#浅堆（Shallow-Heap）"><span class="nav-number">7.1.</span> <span class="nav-text">浅堆（Shallow Heap）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#保留集（Retained-Set）"><span class="nav-number">7.2.</span> <span class="nav-text">保留集（Retained Set）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深堆（Retained-Heap）"><span class="nav-number">7.3.</span> <span class="nav-text">深堆（Retained Heap）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的实际大小"><span class="nav-number">7.4.</span> <span class="nav-text">对象的实际大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#支配树（Dominator-Tree）"><span class="nav-number">7.5.</span> <span class="nav-text">支配树（Dominator Tree）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄漏（memory-leak）"><span class="nav-number">7.6.</span> <span class="nav-text">内存泄漏（memory leak）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存溢出（out-of-memory）"><span class="nav-number">7.7.</span> <span class="nav-text">内存溢出（out of memory）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中内存泄露的8种情况"><span class="nav-number">7.8.</span> <span class="nav-text">Java中内存泄露的8种情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态集合类"><span class="nav-number">7.8.1.</span> <span class="nav-text">静态集合类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单例模式"><span class="nav-number">7.8.2.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类持有外部类"><span class="nav-number">7.8.3.</span> <span class="nav-text">内部类持有外部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#各种连接，如数据库连接、网络连接和IO连接等"><span class="nav-number">7.8.4.</span> <span class="nav-text">各种连接，如数据库连接、网络连接和IO连接等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量不合理的作用域"><span class="nav-number">7.8.5.</span> <span class="nav-text">变量不合理的作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改变哈希值"><span class="nav-number">7.8.6.</span> <span class="nav-text">改变哈希值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存泄露"><span class="nav-number">7.8.7.</span> <span class="nav-text">缓存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#监听器和其他回调"><span class="nav-number">7.8.8.</span> <span class="nav-text">监听器和其他回调</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄露案例分析"><span class="nav-number">7.9.</span> <span class="nav-text">内存泄露案例分析</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cai Kenny</p>
  <div class="site-description" itemprop="description">A Programmer</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cai Kenny</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
