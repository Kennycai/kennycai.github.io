<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用github page 和 hexo 创建静态博客</title>
    <url>/2019/12/23/blog/</url>
    <content><![CDATA[<h3 id="创建自己的博客，教程见hexo官方文档"><a href="#创建自己的博客，教程见hexo官方文档" class="headerlink" title="创建自己的博客，教程见hexo官方文档"></a>创建自己的博客，教程见<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a></h3><h3 id="安装next主题"><a href="#安装next主题" class="headerlink" title="安装next主题"></a>安装next主题</h3><ul>
<li><a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">next官网</a></li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme<span class="literal">-next</span>/hexo<span class="literal">-theme</span><span class="literal">-next</span> themes/next</span><br></pre></td></tr></table></figure>

<ul>
<li>删除主题目录下的.git .github 文件夹</li>
</ul>
<h3 id="添加category"><a href="#添加category" class="headerlink" title="添加category"></a>添加category</h3><ol>
<li><p>hexo new page categories</p>
</li>
<li><p>在source-&gt;categories-&gt;index.md文件下添加</p>
 <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">type: "categories"</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="添加tag"><a href="#添加tag" class="headerlink" title="添加tag"></a>添加tag</h3><ol>
<li><p>hexo new page tags</p>
</li>
<li><p>在source-&gt;tags-&gt;index.md文件下添加</p>
 <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">type: "tags"</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="添加本地搜索"><a href="#添加本地搜索" class="headerlink" title="添加本地搜索"></a>添加本地搜索</h3><ol>
<li><p>npm install hexo-generator-searchdb –save</p>
</li>
<li><p>编辑项目配置文件：</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">    <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">you</span> <span class="string">github</span> <span class="string">page</span> <span class="string">url</span></span><br></pre></td></tr></table></figure></li>
<li><p>编辑主题配置文件，启用本地搜索功能：</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="自动发布-github-page"><a href="#自动发布-github-page" class="headerlink" title="自动发布 github-page"></a>自动发布 github-page</h3><ol>
<li><p>npm install hexo-deployer-git –save</p>
</li>
<li><p>在配置文件中添加（repo为github page 项目的ssh地址）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/***/***.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>方式一：</p>
<ol>
<li><p>执行脚本</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>方式二，使用github action脚本：</p>
<ol>
<li><p>在电脑中生成公钥（已经有公钥的可以直接使用），一路回车</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa <span class="literal">-b</span> <span class="number">4096</span> <span class="literal">-C</span> <span class="string">"youEmail@163.com"</span> <span class="operator">-f</span> ~/.ssh/github<span class="literal">-actions</span><span class="literal">-deploy</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在用户文件夹.ssh目录打开github-actions-deploy.pub,复制到gitbub -&gt; Settings -&gt; SSH and GPG keys -&gt; New SSH key，名字随意。</p>
</li>
<li><p>创建私有仓库在私有仓库的settings/Secrets下新增<strong>ACCESS_TOKEN</strong>，打开用户文件夹.ssh目录打开github-actions-deploy复制过去（<strong>全部复制</strong>）。</p>
</li>
<li><p>项目根目录下新增<strong>.github/workflows/action.yml</strong></p>
</li>
<li><p>直接将项目push到仓库，自动更新github page</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Deploy</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span> <span class="comment"># See https://github.com/actions/checkout</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">ACCESS_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACCESS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">"$ACCESS_TOKEN"</span> <span class="string">|</span> <span class="string">tr</span> <span class="string">-d</span> <span class="string">'\r'</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">        <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">        <span class="string">ssh-keyscan</span> <span class="string">github.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span>  <span class="string">'you name'</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">'email'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">run</span> <span class="string">clean</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">    <span class="comment"># See https://cli.vuejs.org/zh/guide/deployment.html#github-pages</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">run</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="阅读全文"><a href="#阅读全文" class="headerlink" title="阅读全文"></a>阅读全文</h3><blockquote>
<p> 新版 hexo 去掉了 Auto-excerpt，可以添加插件实现，或者是手动添加 <a id="more"></a></p>
</blockquote>
<ol>
<li><p>使用npm安装hexo-excerpt</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-excerpt --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>在站点配置文件（_config.yml）中添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">excerpt:</span></span><br><span class="line">  <span class="attr">depth:</span> <span class="number">5</span>  </span><br><span class="line">  <span class="attr">excerpt_excludes:</span> <span class="string">[]</span></span><br><span class="line">  <span class="attr">more_excludes:</span> <span class="string">[]</span></span><br><span class="line">  <span class="attr">hideWholePostExcerpts:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>springBoot 持续集成</title>
    <url>/2019/12/23/springBoot-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h1 id="springboot持续集成"><a href="#springboot持续集成" class="headerlink" title="springboot持续集成"></a>springboot持续集成</h1><h2 id="使用Mybatis-Generator-和-ext-文件的形式扩展dao、entity"><a href="#使用Mybatis-Generator-和-ext-文件的形式扩展dao、entity" class="headerlink" title="使用Mybatis Generator 和 ext 文件的形式扩展dao、entity"></a>使用Mybatis Generator 和 ext 文件的形式扩展dao、entity</h2><blockquote>
<p>使用ext文件的目的主要是用于当数据库结构发生变化时可以直接删掉原有的dao、entity、xml文件，用Mybatis Generator重新生成，而无需改动原有的扩展代码</p>
</blockquote>
<p>以User表为例：</p>
<ol>
<li><p>新建UserExt实体类继承User</p>
</li>
<li><p>新建UserExtDao继承UserDao</p>
</li>
<li><p>新建UserExtDao对应的xml文件</p>
<ol>
<li>resultMap 继承父类的 resultMap</li>
<li>编写 <strong>Base_Colum_List</strong> 加入自定义sql</li>
<li>使用时要同时include父类和本文件的 <strong>Base_Colum_List</strong> </li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lr.test.dao.ext.UserExtDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.lr.test.entity.ext.UserExt"</span> <span class="attr">extends</span>=<span class="string">"com.lr.test.dao.UserDao.BaseResultMap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"noAndName"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"noAndName"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"Base_Column_List"</span>&gt;</span></span><br><span class="line">        "test" AS noAndName</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectExtByPrimaryKey"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">        select</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"com.lr.test.dao.UserDao.Base_Column_List"</span>/&gt;</span>,</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span>/&gt;</span></span><br><span class="line">        from user</span><br><span class="line">        where id = #&#123;id,jdbcType=VARCHAR&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意：确保新建的xml目录是spring可扫描到的，如本例的为在springboot可以在配置文件中 mybatis.mapper-locations 添加子目录：</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># springboot可以在配置文件中 mybatis.mapper-locations 添加子目录</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*.xml,classpath:mapper/*/*.xml</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="集成RabbitMQ"><a href="#集成RabbitMQ" class="headerlink" title="集成RabbitMQ"></a>集成RabbitMQ</h3><ul>
<li><p>安装<a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">RabbitMQ</a></p>
</li>
<li><p>启动RabbitMQ管理界面</p>
<ul>
<li><pre><code class="powershell">rabbitMQPath/sbin/rabbitmq<span class="literal">-plugins</span> enable rabbitmq_management
rabbitMQPath/sbin/rabbitmqctl stop
rabbitMQPath/sbin/rabbitmq<span class="literal">-server</span> start</code></pre>
</li>
</ul>
</li>
<li><p>访问<a href="http://localhost:15672/" target="_blank" rel="noopener">RabbitMQ manager</a>，默认账号密码：<strong>guest</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/10/07/the%20first%20post/</url>
    <content><![CDATA[<ul>
<li>the first post with github action</li>
</ul>
]]></content>
      <categories>
        <category>first post</category>
      </categories>
      <tags>
        <tag>first post</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo admin 创建的第一个post</title>
    <url>/2025/10/07/%E7%94%A8hexo-admin-%E5%88%9B%E5%BB%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AApost/</url>
    <content><![CDATA[<p>测试一下</p>
]]></content>
  </entry>
  <entry>
    <title>MongoDB实战-读书笔记</title>
    <url>/2021/09/13/database/mongo/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MongoDB的特点：扩展策略、直观的数据模型。在mongodb中，编程语言定义的对象能被“原封不变”地持久化，消除对象结构和程序映射的复杂性。</p>
<h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>关系型与正规化：对于关系型数据库，数据表本质上是<strong>扁平的</strong>，因此表示多个一对多关系就需要多张表。经常用到的技术是<strong>拆表</strong>，这种技术是<strong>正规化</strong>。</p>
<p>但对于Mongo来说，文档支持嵌套等多种格式，无需事先定义<strong>Schema</strong>。</p>
<h4 id="即时查询"><a href="#即时查询" class="headerlink" title="即时查询"></a>即时查询</h4><p>mysql和mongodb都支持<strong>即时查询</strong>，不同的是：前者依赖正则化的模型；后者假定查询字段是存储与文档中的。</p>
<h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>mongodb支持二级索引，是通过b-tree实现的。</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>通过<strong>副本集</strong>的拓扑结构来提供复制功能，其目的是：<strong>提供数据的冗余</strong>。</p>
<p>副本集的主节点能接受读写操作，但从节点是只读的。主节点出问题，会自动故障转移，选取一个从节点升级为主节点。</p>
<h4 id="写速度和持久性"><a href="#写速度和持久性" class="headerlink" title="写速度和持久性"></a>写速度和持久性</h4><p>写速度：给定时间内，数据库可以处理的插入、更新和删除操作的数量。</p>
<p>持久性：数据库保持上述写操作的结果不改变的，所用的时间长短。</p>
<p>DB领域，<strong>写速度和持久性存在一种相反关系</strong>。很好理解，例如memcached，直接写入内存，写速度非常快，但同时数据完全易失。</p>
<p>在MongoDB中，用户可以选择写入语义，决定是否开启Journaling日志记录，通过这种方式来控制速度和持久性间的平衡。默认所有的写操作都是<strong>fire-and-forget</strong><br> 的，即写操作通过TCP套接字发送，不要求数据库应答。如果用户需要获得应答，可以使用特殊的<strong>安全模式</strong>发起写操作，所有驱动都提供这个安全模式。该模式强制数据库作出应答，确保数据库正确无误地接收到了写操作。安全模式是可配置的，还可用于阻塞操作，直到写操作被复制到特定数量的服务器。对于高容量、低价值的数据（例如点击流和日志），fire-and-forget风格的写操作是很理想的选择。对于重要的数据，则更倾向于安全模式。</p>
<p>mongo中，<strong>Journaling日志</strong>默认开启。所有写操作会被提交到一个只能追加的日志中。以应对故障后的，重启修复服务。</p>
<h4 id="数据库扩展"><a href="#数据库扩展" class="headerlink" title="数据库扩展"></a>数据库扩展</h4><ul>
<li>垂直扩展（向上扩展）：升级硬件，来提高单点性能</li>
<li>水平扩展（向外扩展）：将数据库分布到多台机器，是基于<strong>自动分片</strong>。其中，单独的分片由一个副本集组成，至少有2个节点，保证没有单点失败。</li>
</ul>
<h3 id="核心服务器和工具"><a href="#核心服务器和工具" class="headerlink" title="核心服务器和工具"></a>核心服务器和工具</h3><h4 id="核心服务器"><a href="#核心服务器" class="headerlink" title="核心服务器"></a>核心服务器</h4><p>通过<code>mongod</code>可以运行核心服务器。数据文件存储在<code>/data/db</code>中。如果下载编译mongo的源代码，需要手动创建<code>/data/db</code>，并且为其分配权限。</p>
<p>其中，mongo的<strong>内存管理</strong>是由操作系统来处理的。数据文件通过<code>mmap()</code>系统API，映射成系统的虚拟内存。</p>
<h4 id="lock文件和-ns文件"><a href="#lock文件和-ns文件" class="headerlink" title=".lock文件和.ns文件"></a>.lock文件和.ns文件</h4><p>先来看mongod.lock文件，其中存储了服务器的进程ID。数据库文件本身是依据所属的数据库命名的。garden.ns是第一个生成的文件。文件扩展名ns，表示namespaces，，意即命名空间。数据库中的每个集合和索引都有自己的命名空间，每个命名空间的元数据都存放在这个文件里。默认情况下，.ns文件大小固定在16 MB，大约可以存储24 000个命名空间。也就是说数据库中的索引和集合总数不能超过24 000。我们几乎不可能使用这么多集合与索引，但如果真有需要，可以使用–nssize服务器选项让该文件变得更大一点。</p>
<h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p>是基于JavaScript编写的。所以能看到很多通用的语法，以及输出的格式。</p>
<h4 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h4><ul>
<li><code>mongodump</code>和<code>mongorestore</code>：前者用<code>BSON</code>格式，来备份数据库数据。方便后者恢复。</li>
<li><code>mongoexport</code>和<code>mongoimport</code>：导入导出JSON、CSV和TSV格式数据。</li>
</ul>
<h3 id="Mongo的场景"><a href="#Mongo的场景" class="headerlink" title="Mongo的场景"></a>Mongo的场景</h3><p>适用于<strong>事先无法知晓数据结构</strong>的数据，或者<strong>数据结构经常不确定性较大</strong>的数据。</p>
<p>除此之外，还适用于<strong>与分析相关的场景</strong>。mongo提供一种<strong>固定集合</strong>，常用于日志，特点是<strong>分配的大小固定</strong>，类似于循环队列。</p>
<h2 id="程序编写基础"><a href="#程序编写基础" class="headerlink" title="程序编写基础"></a>程序编写基础</h2><p>mongo驱动的find方法，返回的是<strong>游标对象</strong>，可以理解为迭代器的下标。</p>
<h3 id="驱动工作原理"><a href="#驱动工作原理" class="headerlink" title="驱动工作原理"></a>驱动工作原理</h3><p>主要有3个功能：</p>
<ol>
<li>生成MongoDB对象的ID，它是存储在<code>_id</code>字段中的默认值</li>
<li>驱动会把特定语言的文档表述，和<code>BSON</code>互换</li>
<li>使用TCP套接字与数据库通信</li>
</ol>
<h4 id="对象ID"><a href="#对象ID" class="headerlink" title="对象ID"></a>对象ID</h4><p>在自带的交互式命令行中:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; id = ObjectId()</span><br><span class="line">ObjectId(<span class="string">"5d9413867cc8dacf9247fe3e"</span>)</span><br></pre></td></tr></table></figure>

<p>对于生成的<code>5d9413867cc8dacf9247fe3e</code>:</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>5d941386 ，这4个字节是Unix时间戳，单位秒数</span><br><span class="line"><span class="bullet">- </span>7cc8da，3字节的机器ID</span><br><span class="line"><span class="bullet">- </span>cf92，2字节的进程ID</span><br><span class="line"><span class="bullet">- </span>47fe3e，3字节进程的局部计数器</span><br></pre></td></tr></table></figure>

<h3 id="安全写入模式-Write-Concern"><a href="#安全写入模式-Write-Concern" class="headerlink" title="安全写入模式(Write Concern)"></a>安全写入模式(Write Concern)</h3><p>对所有的写操作（插入、更新或删除）都能开启此模式。以此保证，操作一定在数据库层面生效。</p>
<p>在v4.0中，以insert为例，文档如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.collection.insert(</span><br><span class="line">   &lt;<span class="built_in">document</span> or array <span class="keyword">of</span> documents&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     writeConcern: <span class="xml"><span class="tag">&lt;<span class="name">document</span>&gt;</span>,</span></span><br><span class="line">     ordered: &lt;boolean&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>关于 Write Concern的详细参数，可以看这篇文档：<a href="https://docs.mongodb.com/manual/reference/write-concern/" target="_blank" rel="noopener">Write Concern — MongoDB Manual</a></p>
<p>其中，重要的是<code>w</code> 参数，它可以指定是否使用应答写入。目前默认是1，应答式写入。设置为0，则是非应答式。</p>
<h2 id="面向文档的数据"><a href="#面向文档的数据" class="headerlink" title="面向文档的数据"></a>面向文档的数据</h2><h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>即使使用<code>use</code>切换一个新的数据库，如果没有insert数据，该数据库并不会创建。</p>
<p>mongodb会为数据、集合、索引进行空间分配，并且采取的是<strong>预分配</strong>的方式，每次空间不够的时候，扩充2倍。</p>
<p>通过 <code>db.stats()</code> 可以查看当前db的状态，下面是一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.stats()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"db"</span> : <span class="string">"info"</span>,</span><br><span class="line">    <span class="string">"collections"</span> : <span class="number">3</span>,</span><br><span class="line">    <span class="string">"views"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">"objects"</span> : <span class="number">11</span>,</span><br><span class="line">    <span class="string">"avgObjSize"</span> : <span class="number">255.8181818181818</span>,</span><br><span class="line">    <span class="string">"dataSize"</span> : <span class="number">2814</span>, <span class="comment">// 数据库中BSON对象实际大小</span></span><br><span class="line">    <span class="string">"storageSize"</span> : <span class="number">86016</span>, <span class="comment">// 包含了集合增长的预留空间和未分配的已删除空间</span></span><br><span class="line">    <span class="string">"numExtents"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">"indexes"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="string">"indexSize"</span> : <span class="number">155648</span>, <span class="comment">// 数据库索引大小的空间</span></span><br><span class="line">    <span class="string">"fsUsedSize"</span> : <span class="number">86272356352</span>,</span><br><span class="line">    <span class="string">"fsTotalSize"</span> : <span class="number">250685575168</span>, </span><br><span class="line">    <span class="string">"ok"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子里，fileSize字段标明了为该数据库分配的文件空间的总和，就是简单地把数据库的多个数据文件（<em>\</em>.0和**.1…）的大小加起来。比较有意思的是dataSize和storageSize 两者的差值，前者是数据库中BSON对象的实际大小，后者包含了为集合增长预留的额外空间和未分配的已删除空间。最后，indexSize的值是数据库索引大小的总合。关注总计索引大小是很重要的，当所有用到的索引都能放入内存时，数据库的性能是最好的。</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>1、重命名操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; use test</span><br><span class="line">&gt; db.orders.renameCollection( <span class="string">"orders2014"</span> )</span><br></pre></td></tr></table></figure>

<p>2、固定集合</p>
<p>对应日志统计之类的、<strong>只有最近的数据才有价值</strong>的场景下，可以使用<strong>固定集合</strong>：一旦容量到上限，后续插入会逐步覆盖最先插入的文档。</p>
<p>创建时候，需要同时指定<code>createCollection</code>的capped和size参数：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">db.create<span class="constructor">Collection('<span class="params">logs</span>',&#123; <span class="params">capped</span> : <span class="params">true</span>, <span class="params">size</span> : 5242880 &#125;)</span></span><br></pre></td></tr></table></figure>

<p>为了性能优化，mongo<strong>不会为固定集合创建针对<code>_id</code>的索引</strong>，为此，MongoDB提供了一个特殊的排序操作符，按自然插入顺序返回集合的文档。同时，不能从中删除doc，也不能执行任何更改文档大小的更新操作。</p>
<p>3、键名选择</p>
<p><strong>慎重选择键名</strong>，例如，用<code>dob</code>代替<code>date_of_birth</code>，一个文档可以省下10字节。</p>
<h2 id="查询和聚合"><a href="#查询和聚合" class="headerlink" title="查询和聚合"></a>查询和聚合</h2><h3 id="查询常见技巧"><a href="#查询常见技巧" class="headerlink" title="查询常见技巧"></a>查询常见技巧</h3><p><strong>分页查询</strong>可以通过<code>skip</code>和<code>limit</code>配合使用实现。</p>
<blockquote>
<p>skip 与 limit 的语义很容易理解，这两个查询选项的作用总能满足预期。 但在向 skip 传递很大的值（比如大于10 000的值）时需要注意，因为执行这种查询要扫描和 skip 值等量的文档。例如，假设正根据日期降序对100万个文档进行分页，每页10条结果。这意味着显示第50 000页的查询要跳过500 000个文档，这样做的效率太低了。更好的策略是省略skip ，添加一个范围条件，指明下一结果集从何处开始。如此一来，这条查询：</p>
<p>db.docs.find({}).skip(500000).limit(10).sort({date: -1})</p>
<p> 就变成了：</p>
<p>db.docs.find({date: {$gt: previous_page_date}}).limit(10).sort({date: -1})</p>
<p>第二条查询扫描的文档远少于第一条。唯一的问题是如果每个文档的日期不唯一，相同的文档可能会显示多次。</p>
</blockquote>
<p><strong>空值查询</strong>可以通过驱动的空值字面量实现，比如在node中，想查询<code>logs</code>中不包含<code>name</code>字段的记录：<code>db.logs.find({ name: null })</code>。</p>
<p><strong>减少序列化和网络传输</strong>，可以通过给定find的第二个参数，来选定数据库返回给驱动的文档的字段，比如：<code>db.products.find({}, {_id: 1})</code>。这条命令，只返回文档的<code>_id</code>字段。</p>
<p><strong>复合索引</strong>，复合索引的设定，遵循着「从准确到宽泛」的规则。比如对于订单记录，有着下单人和时间2个字段。应该先为下单人字段设置索引，再为时间字段设置索引。可以理解为前者是精确查找，可以大大缩小查找结果集；后者是范围查找。</p>
<p><strong>嵌套字段查询</strong>，对于负责对象字段的查询，直接通过<code>.</code>运算符即可。例如：<code>db.demos.find({a: {b : 1}})</code>和<code>db.demos.find({&quot;a.b&quot;: 1})</code> 是等效的。</p>
<h3 id="常见查询语言"><a href="#常见查询语言" class="headerlink" title="常见查询语言"></a>常见查询语言</h3><p>MongoDB的查询本质：实例化了一个游标，并获取它的结果集。</p>
<h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>范围操作符用法很简单，但注意：不要在范围查找时候误用<strong>重复搜索键</strong>。</p>
<p>错误：<code>db.users.find({age: { $gte: 0 }, age: { $lte: 30 } })</code></p>
<p>正确：<code>db.users.find({age: {$gte: 0, $lte: 30}})</code></p>
<h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><p>集合操作符一共有3个：<code>$in</code>、<code>$all</code>、<code>$nin</code>。</p>
<p>in和nin是一对，in相当于使用多个OR操作符：<code>db.products.find({&#39;tags&#39;: {$in: [ObjectId(&#39;...&#39;), ObjectId(&#39;...&#39;)]}})</code></p>
<p>all的作用属性，必须是数组形式：<code>db.products.find({tags: {$all: [&#39;a&#39;, &#39;b&#39;]}})</code></p>
<p>⚠️注意：in和all可以利用索引；nin不能利用索引，只能使用<strong>集合扫描</strong>。这和BTree结构有关。</p>
<h4 id="布尔操作"><a href="#布尔操作" class="headerlink" title="布尔操作"></a>布尔操作</h4><p>常见的有：<code>$ne</code>、<code>$not</code>、 <code>$or</code>、 <code>$and</code>、<code>$exists</code>。同样的，<code>$ne</code>不能利用索引。</p>
<p>对于not的使用，如果使用的操作符或者正则表达式不存在否定形式，才配合not。例如大于，就有小于等于操作符。</p>
<p>对于or的使用，or可以<strong>表示不同键的值的关系</strong>，而in只能表示一个键的值的关系。例如：<code>db.products.find({ $or: [{ name: &#39;a&#39; }, { name: &#39;b&#39; }] })</code></p>
<h4 id="子文档"><a href="#子文档" class="headerlink" title="子文档"></a>子文档</h4><p>对于内嵌对象匹配，用<code>.</code>运算符即可，正如前面的嵌套字段查询所述。</p>
<p><strong>不推荐</strong>对于整个对象的查询，需要严格保证查询字段的顺序。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>如果数组中元素是基础对象，那么直接查询即可。mongo识别字段是数组类型，会自动查询字段是否位于其中。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.products.insert(&#123;tags: [<span class="string">'a'</span>, <span class="string">'b'</span>]&#125;)</span></span><br><span class="line">WriteResult(&#123; "nInserted" : 1 &#125;)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.products.find(&#123;tags: <span class="string">'a'</span>&#125;)</span></span><br><span class="line">&#123; "_id" : ObjectId("5d948025da0946c664997712"), "tags" : [ "a", "b" ] &#125;</span><br></pre></td></tr></table></figure>

<p>如果数组中元素是复杂对象，可以借助<code>.</code>运算符进行访问：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.products.insert(&#123;address: [&#123;name: <span class="string">'home'</span>&#125;]&#125;)</span></span><br><span class="line">WriteResult(&#123; "nInserted" : 1 &#125;)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.products.find(&#123;<span class="string">"address.name"</span>: <span class="string">'home'</span>&#125;)</span></span><br><span class="line">&#123; "_id" : ObjectId("5d948055da0946c664997713"), "address" : [ &#123; "name" : "home" &#125; ] &#125;</span><br></pre></td></tr></table></figure>

<p>同样地，你也可以指定针对特定顺序的数组元素：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.products.find(&#123;<span class="string">"address.0.name"</span>: <span class="string">'home'</span>&#125;)</span></span><br><span class="line">&#123; "_id" : ObjectId("5d948055da0946c664997713"), "address" : [ &#123; "name" : "home" &#125; ] &#125;</span><br></pre></td></tr></table></figure>

<p>⚠️如果要同时将<strong>多个条件限制在同一个子文档</strong>上，下面是错误和正确的做法?</p>
<p>错误：<code>db.products.find({&quot;address.name&quot;: &#39;home&#39;, &#39;address.state&#39;: &#39;NY&#39;})</code></p>
<p>正确：<code>db.products.find({address: {$elemMatch: {name: &#39;home&#39;, state: &#39;NY&#39;} }})</code></p>
<h4 id="Javascript查询"><a href="#Javascript查询" class="headerlink" title="Javascript查询"></a>Javascript查询</h4><p>对于一些复杂查询，借助<code>$where</code>可以使用js表达式。还是以刚才的数据为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.products.find(&#123;<span class="variable">$where</span>: <span class="string">"function() &#123;return this.address &amp;&amp; this.address.length&#125;"</span> &#125;)</span></span><br><span class="line">&#123; "_id" : ObjectId("5d948055da0946c664997713"), "address" : [ &#123; "name" : "home" &#125; ] &#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时候，需要启动js解释器和上下文，因此<strong>开销大</strong>。在使用的时候，尽量带上其他标准查询操作，来缩小查询范围。</p>
<p>除此之外，还有注入攻击的可能。主要体现在驱动使用时候，如果后端传给db的字段是没做检验的，可能发生注入攻击。</p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>主要体现在驱动使用上。</p>
<p>如果支持js的正则，那么可以: <code>find({text: /best/i})</code></p>
<p>如果不支持，那么：<code>find({text: {$regex: &#39;best&#39;, $options: &#39;i&#39;}})</code></p>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>通过<code>$type</code>，可以根据指定字段类型进行查询。不同的值，代表不同的类型。请见官方文档。</p>
<h3 id="查询选项"><a href="#查询选项" class="headerlink" title="查询选项"></a>查询选项</h3><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>1、使用选择字段进行返回，降低网络传输：<code>find</code>给定第二个参数。</p>
<p>2、返回保存在结果数组中的某个范围的值：<code>$slice([start, limit])</code>。例如：<code>db.products.find({}, { comments: {$slice: 12}})</code></p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>能够对<strong>多个字段</strong>进行升序/降序排列。例如：<code>db.comments.find().sort({rating: -1, votes: -1})</code></p>
<h4 id="skip和limit"><a href="#skip和limit" class="headerlink" title="skip和limit"></a>skip和limit</h4><p>如果向skip传入很大的值，需要扫描同等数量的文档，浪费资源。</p>
<p>最好的方法是：通过查询条件，缩小要扫描的文档。</p>
<h3 id="聚合指令"><a href="#聚合指令" class="headerlink" title="聚合指令"></a>聚合指令</h3><p>在v2的版本中，mongo只能通过map、reduce等基础操作来支持聚合搜索。但在v3的版本后，mongo本身提供了丰富的聚合阶段(<a href="https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/" target="_blank" rel="noopener">aggregation pipeline</a>)和聚合运算符(<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/" target="_blank" rel="noopener">aggregation operator</a>)。</p>
<p>以<code>$group</code>和<code>$sum</code>为例，插入了a和b两种售卖货物以及价钱：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.sales.find()</span></span><br><span class="line">&#123; "_id" : ObjectId("5d98ca8094ffea590a8a85c6"), "name" : "a", "coin" : 100 &#125;</span><br><span class="line">&#123; "_id" : ObjectId("5d98ca8694ffea590a8a85c7"), "name" : "a", "coin" : 200 &#125;</span><br><span class="line">&#123; "_id" : ObjectId("5d98ca9094ffea590a8a85c8"), "name" : "b", "coin" : 800 &#125;</span><br></pre></td></tr></table></figure>

<p>利用聚合操作，就可以便捷算出每种货物的总价：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.sales.aggregate([&#123; <span class="variable">$group</span>: &#123; _id: <span class="string">"<span class="variable">$name</span>"</span>, total: &#123; <span class="variable">$sum</span>: <span class="string">"<span class="variable">$coin</span>"</span> &#125; &#125; &#125;])</span></span><br><span class="line">&#123; "_id" : "b", "total" : 800 &#125;</span><br><span class="line">&#123; "_id" : "a", "total" : 300 &#125;</span><br></pre></td></tr></table></figure>

<p>最后说一下，聚合的意义在于数据库提供给使用者此种功能以及相关优化。当然，使用者完全可以在逻辑层面查询到需要的集合，代码中进行计算。但对于服务的提供商，完整的服务是必不可少的。</p>
<h2 id="更新、原子操作与删除"><a href="#更新、原子操作与删除" class="headerlink" title="更新、原子操作与删除"></a>更新、原子操作与删除</h2><h3 id="文档更新入门"><a href="#文档更新入门" class="headerlink" title="文档更新入门"></a>文档更新入门</h3><p>文档更新分为：替换更新和针对性更新。相较而言，<strong>针对性更新</strong>具有性能好、传输数据少和允许原子性更新的优点。</p>
<p>利用<code>$set</code>和<code>$push</code>可以针对文档和其中的数组字段进行针对性更新，下面是针对性更新的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.products.update(</span><br><span class="line">   &#123; _id: 100 &#125;,</span><br><span class="line">   &#123; $set:</span><br><span class="line">      &#123;</span><br><span class="line">        quantity: 500</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果是替换更新，遇到增加计数器值之类的场景，在不使用乐观锁的情况下，无法保证原子性更新。因为需要先读出数据，然后再更新。此过程中，可能会有其他并发程序重写字段，从而造成脏数据。</p>
<p>以更新计数器的针对性更新为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.products.update(</span><br><span class="line">   &#123; sku: "abc123" &#125;,</span><br><span class="line">   &#123; $inc: &#123; quantity: -1 &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="电子商务数据模型中的更新"><a href="#电子商务数据模型中的更新" class="headerlink" title="电子商务数据模型中的更新"></a>电子商务数据模型中的更新</h3><h4 id="冗余字段设计"><a href="#冗余字段设计" class="headerlink" title="冗余字段设计"></a>冗余字段设计</h4><p>对于一些常见的结果，比如：总数、平均值等。为了避免每次都<strong>重新聚合运算</strong>，可以在文档中<strong>保存额外的字段缓存</strong>相关数据。</p>
<p>之后的业务查询，仅仅需要查询一次即可。</p>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="$操作符"></a><code>$</code>操作符</h4><p>作用：确定数组中一个要被更新的元素的位置，而不用具体指定该元素在数组中的位置。</p>
<p>如下所示，不需要知道在grades数组中匹配的具体位置，用<code>$</code>指代即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.students.insert([</span><br><span class="line">   &#123; <span class="string">"_id"</span> : <span class="number">1</span>, <span class="string">"grades"</span> : [ <span class="number">85</span>, <span class="number">80</span>, <span class="number">80</span> ] &#125;</span><br><span class="line">])</span><br><span class="line">&gt; db.students.updateOne(</span><br><span class="line">   &#123; <span class="attr">_id</span>: <span class="number">1</span>, <span class="attr">grades</span>: <span class="number">80</span> &#125;,</span><br><span class="line">   &#123; <span class="attr">$set</span>: &#123; <span class="string">"grades.$"</span> : <span class="number">82</span> &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="upsert操作符"><a href="#upsert操作符" class="headerlink" title="upsert操作符"></a><code>upsert</code>操作符</h4><p>作用：如果不存在，则会自动<code>insert</code>。</p>
<p>对于添加到商品到购物车等场景，非常适用。</p>
<h3 id="事务性工作流"><a href="#事务性工作流" class="headerlink" title="事务性工作流"></a>事务性工作流</h3><p>这里主要使用的是<code>findAndModify</code>命令。这个命令，支持传入query参数，来做匹配筛选；支持update，来做针对性更新（原子更新）。最重要的特性是：<strong>可以根据<code>new</code>参数，来返回更新前后的文档数据状态</strong>。</p>
<p>借助可以返回更新文档数据的特性，可以mock一下mongo 4.0之前不支持的事务特性。思路是：</p>
<ol>
<li>获取最初的文档数据</li>
<li>利用findAndModify进行针对性更新，更新字段中需要携带本次的更新标示（比如时间戳）。findAndModify操作符会返回更新后的字段。</li>
<li>将更新后的字段中的更新标示与本地保存的标示做对比，如果不相同，说明有别的端更新了数据，数据发生了污染，为了保证事务原子性的特点，将文档恢复为第1步获得原始数据；如果相同，那么继续进行。</li>
</ol>
<p>在MongoDB 4.0中，就是通过类似第二步的思路，提供了一个seesionID来实现了事务的，保证了事务特性。</p>
<h3 id="更多的更新命令"><a href="#更多的更新命令" class="headerlink" title="更多的更新命令"></a>更多的更新命令</h3><p>update：multi参数不给，默认只更新匹配到的第一个文档。</p>
<p>unset：删除文档中的指定键。</p>
<p>rename：重命名键。</p>
<p>addToSet：数组中不存在时候，才会加入。</p>
<p>pull：删除数组指定位置的元素。</p>
<h3 id="更新本质和优化"><a href="#更新本质和优化" class="headerlink" title="更新本质和优化"></a>更新本质和优化</h3><p>更新分为3种：</p>
<ul>
<li>只改变单值，但BSON文档不变：<code>$inc</code>操作符</li>
<li>改变文档和结构，会重写整个文档：<code>$push</code></li>
<li>改变文档造成空间不够，全部整体迁移到新空间：提前利用<strong>填充因子</strong>来减少影响</li>
</ul>
<h2 id="索引与查询优化"><a href="#索引与查询优化" class="headerlink" title="索引与查询优化"></a>索引与查询优化</h2><p>查询是非常高频的操作，大数据、高频读的场景下，查询的效率会是性能的瓶颈。设置<strong>合适的索引</strong>，可以充分利用数据结构（B数）和物理硬件的优势。</p>
<h3 id="索引理论"><a href="#索引理论" class="headerlink" title="索引理论"></a>索引理论</h3><h4 id="复合索引和分离索引"><a href="#复合索引和分离索引" class="headerlink" title="复合索引和分离索引"></a>复合索引和分离索引</h4><p>一个查询中，要是有多个字段，比如2个字段。分离索引是：查找每个索引的匹配集合，取得这些匹配集合的交集。复合索引是：逐步根据索引的顺序做查询。</p>
<p>比如有一个食谱，我们根据种类和菜名来做索引：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">肉类</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">辣子鸡：第12页</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">鱼肉：第139页</span></span><br></pre></td></tr></table></figure>

<p>⚠️：复合索引中的顺序是非常重要的，如果设置的索引不合适，那么就相当于现行扫描文档。抽象来说，如果有一个针对a-b的复合索引，那么仅针对a的索引就是冗余的。比如例子中，仅针对种类的索引就是冗余的，但是种类索引可以降低扫描时间（和Btree有关）。</p>
<h4 id="索引效率"><a href="#索引效率" class="headerlink" title="索引效率"></a>索引效率</h4><p>正确的索引，也不一定会有快速的查询：<strong>索引和数据集无法全部放入内存</strong>。</p>
<p>如果内存充足，所有使用的数据文件都会载入内存，对应内存发生变化时（比如写操作），结果会异步刷到磁盘上。</p>
<p>如果内存不足，就无法全部装入内存，出现<strong>页错误</strong>，操作系统会频繁访问磁盘读取需要数据。数据集过大时候，任何写操作都要去磁盘，会出现<strong>颠簸情况</strong>，性能下滑。</p>
<p>因此，应该首先保证<strong>索引都能装入内存</strong>，复合索引时，尽量减少键的数量。</p>
<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>在Mongo Version2中，B树仅用于索引。集合存储是双向列表。</p>
<p>对于复合索引的底层结构，以下面为例，是根据姓、名和生日来建立的复合索引。如果要查询(Akroyd, Kirsten, 1978-11-02)的数据，那么会先按照顺序查找，根据第一个索引，找到了只有左侧两个复合要求；再在左侧两个集合中查找第二个索引；直到找到符合要求的数据为止。</p>
<p><img src="/images/database/mongo/%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95.jpg" alt="复合索引.jpg"></p>
<p>参考链接：</p>
<ul>
<li><a href="https://www.zhihu.com/question/268703288" target="_blank" rel="noopener">mysql复合索引的底层数据结构？</a></li>
<li><a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">B树和B+树的插入、删除</a></li>
</ul>
<h4 id="查询计划"><a href="#查询计划" class="headerlink" title="查询计划"></a>查询计划</h4><p>优化器会选择扫描索引项最少的索引。查询首次运行时，优化器会为每个可能有效适用于该查询的索引创建查询计划，随后并行运行各个计划，nscanned值最低的计划胜出。</p>
<p>在发现了一个成功的计划之后，会记录下查询模式（query pattern）、nscanned的值以及索引说明。例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123; pattern:&#123;stock_symbol:'equality',close: 'bound'&#125;, index:&#123;stock_symbol:1&#125;,nscanned:894&#125;</span><br></pre></td></tr></table></figure>

<p>查询模式记录下了每个键的匹配类型(<code>三种范围匹配类型：上界（upper）、下界（lower）以及上下界（upper-and-lower）。查询模式还包含各种排序。</code>)，你正请求对stock_symbol的精确匹配（相等），对close的范围匹配（边界）。只要新的查询匹配此模式，就会使用该索引。<br>但这一信息不应该是永久的，实际情况也是如此。在发生以下事件之后优化器会自动让计划过期。</p>
<ul>
<li><p>对集合执行了100次写操作。</p>
</li>
<li><p>在集合上增加或删除了索引。</p>
</li>
<li><p>虽然使用了缓存的查询计划，但工作量大于预期。此处，“工作量大”的标准是nscanned超过缓存的nscanned值的10倍。</p>
</li>
</ul>
<p>发生最后一种事件时，优化器会立即开始交错执行其他查询计划，也许另一个索引会更高效。</p>
<h3 id="索引实践"><a href="#索引实践" class="headerlink" title="索引实践"></a>索引实践</h3><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><p>根据索引设置时的属性的不同，常见的有：唯一性索引、稀疏索引和多键索引。</p>
<p><strong>唯一性索引</strong></p>
<p>说明：被设置为索引的字段，不能重复出现，否则会报错。</p>
<p>创建方式：<code>db.col.createIndex({name: 1}, {unique: true})</code>。</p>
<p>⚠️：适用于插入数据前先创建索引的情况</p>
<h4 id="稀疏索引"><a href="#稀疏索引" class="headerlink" title="稀疏索引"></a>稀疏索引</h4><p>说明：索引默认是密集型的，是指为集合中每个文档都建立索引。例如前面的例子，即使文档没有name字段，那么查询索引时候，没有name字段的文档匹配null即可。</p>
<p>创建方式：<code>db.col.createIndex({name: 1}, {sparse: true})</code></p>
<p>优点：</p>
<ul>
<li>占用较少的空间</li>
<li>适用于不是为所有文档增加唯一性索引</li>
<li>适用于历史遗留的文档，无法保证字段存在</li>
</ul>
<h4 id="多键索引"><a href="#多键索引" class="headerlink" title="多键索引"></a>多键索引</h4><p>说明：在数组字段上建立索引。mongo中，多键索引是默认开启的。</p>
<p>原理：数组中每个元素，都指向文档。</p>
<h3 id="查询管理"><a href="#查询管理" class="headerlink" title="查询管理"></a>查询管理</h3><h4 id="构建索引"><a href="#构建索引" class="headerlink" title="构建索引"></a>构建索引</h4><p>分为为索引值排序、排序值插入索引中，并且会占用写锁，其他程序无法读写数据库。</p>
<p>在迁移历史数据和索引的时候，先迁移数据再构建集合，比线构建集合再迁移数据 的做法更优秀。</p>
<h4 id="后台索引"><a href="#后台索引" class="headerlink" title="后台索引"></a>后台索引</h4><p>设置background为true。虽然仍会占用写锁，但会停下来，让其他操作读写操作访问数据库。适合在流量最低的时候，完成索引构建。</p>
<h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p>mongodump和mongorestore只能保存集合和索引说明。</p>
<p>如果想备份索引，必须直接备份mongo的数据文件。</p>
<h4 id="压紧删除"><a href="#压紧删除" class="headerlink" title="压紧删除"></a>压紧删除</h4><p>对于删除大量数据，可能造成索引碎片化。解决方法是重建索引或者执行<code>db.col.reIndex()</code>.</p>
<p>应该在子节点执行此命令，再进行节点替换，因为它会占用写锁，造成无法读写操作。</p>
<h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p>两个比较重要的原理，一个是<strong>覆盖索引</strong>，一个<strong>复合键的顺序</strong>。</p>
<p>覆盖索引是指：查询的关键字和索引完全一致。</p>
<p>复合键的顺序遵循：搜索成本由低到高的原则排列。</p>
<h2 id="复制-1"><a href="#复制-1" class="headerlink" title="复制"></a>复制</h2><h3 id="复制概述"><a href="#复制概述" class="headerlink" title="复制概述"></a>复制概述</h3><p>定义：在多台服务器上分布并管理数据库服务器。有2种复制风格：主从复制和副本集（生产环境推荐）。</p>
<p>复制的作用是<strong>冗余</strong>，因为复制是<strong>异步的</strong>，因此任何节点的延迟都不会影响主节点性能。</p>
<p>副本不是备份替代品：备份是某事刻的快照；副本是最新的。</p>
<p>作用：故障转移、均衡读负载。</p>
<h3 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h3><p>最小的副本集由3个节点组成：主节点、从节点、仲裁节点。主从节点是一等的；仲裁节点不复制数据，中立观察。</p>
<p><img src="/images/database/mongo/%E5%89%AF%E6%9C%AC%E9%9B%86.jpg" alt="副本集.jpg"></p>
<p>副本集基于两个机制：oplog和心跳。oplog是记录数据的变更；心跳是检测主节点是否有效。</p>
<p>在副本集中，「提交」是指：数据变动都被复制到从节点。否则就是未提交。</p>
<h4 id="不适合的情况"><a href="#不适合的情况" class="headerlink" title="不适合的情况"></a>不适合的情况</h4><ul>
<li>所分配的硬件无法处理给定的负载。以我上一章里提到的工作集为例，如果使用的工作数据集远大于可用内存，那么向从节点发送随机读请求仍然可能造成大量磁盘访问，导致慢查询。</li>
<li>读写比超过50%。诚然，这个比例有点主观，但将它作为起始值还是挺合适的。此处的问题是主节点上的所有写操作最终也会写入从节点，把读操作导向正在处理大量写入的从节点有时会减缓复制过程，并不会提高读吞吐量。</li>
<li>应用程序要求一致性读。从节点的复制是异步进行的，因此无法保证一定能读到主节点上最新写入的数据。在某些极端情况下，从节点可能延迟几个小时。</li>
</ul>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a><del>主从复制</del></h3><p>不推荐，副本集才是正道，原因如下：</p>
<ul>
<li>故障转移手动操作（没有仲裁节点）</li>
<li>oplog只存在主节点</li>
</ul>
<h3 id="写关注和读拓展"><a href="#写关注和读拓展" class="headerlink" title="写关注和读拓展"></a>写关注和读拓展</h3><p><a href="https://docs.mongodb.com/manual/reference/write-concern/" target="_blank" rel="noopener">Write Concern — MongoDB Manual</a>：设置<code>writeConcern</code>参数，通过属性设置来指定wtimeout、w。</p>
<p>读拓展：单台服务器无法承受程序的读负载，将查询分配到副本上。</p>
<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>这是一个有意思的概念，尤其是「复制」对比的时候。复制是指数据都保存在单机上，向其他副本迁移，理论上所有主从节点数据是一致的；分片是指由于空间有限，单机承受不了数据量，同一个数据库分布在不同的数据库上，这些数据库形成了一个宏观意义上的节点。</p>
<p><img src="/images/database/mongo/%E5%88%86%E7%89%87.jpg" alt="分片.jpg"></p>
<h3 id="mongos路由器"><a href="#mongos路由器" class="headerlink" title="mongos路由器"></a>mongos路由器</h3><p>mongos 进程是一个路由器，将所有的读写请求指引到合适的分片上。</p>
<h3 id="拆分和迁移"><a href="#拆分和迁移" class="headerlink" title="拆分和迁移"></a>拆分和迁移</h3><p>分片一开始只有一个块，块的大小达到阈值时进行拆分，默认的块的最大块尺寸是64MB或者100000个文档，先达成那个标准就以那个标准为准。</p>
<p>迁移是由名为均衡器（balancer）的软件进程管理的，它的任务就是确保数据在各个分片中保持均匀分布。通过跟踪各分片上块的数量，就能实现这个功能。虽然均衡的触发会随总数据量的不同而变化，但是通常来说，当集群中拥有块最多的分片与拥有块最少的分片的块数差大于8时，均衡器就会发起一次均衡处理。在均衡过程中，块会从块较多的分片迁移到块较少的分片上，直到两个分片的块数大致相等为止。</p>
<h3 id="分片查询类型"><a href="#分片查询类型" class="headerlink" title="分片查询类型"></a>分片查询类型</h3><p>如果查询包含分片键，那么mongos通过块数据能很快定位哪个分片包含查询的结果集。这称为针对性查询（targeted query）。<br>但是，如果分片键不是查询的一部分，那么查询计划器就不得不访问所有分片来完成查询。这称为全局查询或分散/聚集查询</p>
<h3 id="分片和索引"><a href="#分片和索引" class="headerlink" title="分片和索引"></a>分片和索引</h3><p>每个分片都维护了自己的索引。这点应该是显而易见的，当你在分片集合上声明索引时，每个分片都会为它那部分集合构建独立的索引。</p>
<p>分片集合只允许在_id字段和分片键上添加唯一性索引。其他地方不行，因为这需要在分片间进行通信，实施起来很复杂，而且相信这么做速度也很慢，没有实现的价值。</p>
<h3 id="理想的分片键"><a href="#理想的分片键" class="headerlink" title="理想的分片键"></a>理想的分片键</h3><ul>
<li>将插入数据均匀分布到各个分片上；（分布性差的分片键会抵消掉分片的一个好处：将插入的负载自动分布到不同机器上。例如：按照升序的BSON id，就是一个分布性很差的键，每次插入都集中在很小的范围内）</li>
<li>保证CRUD操作能够利用局部性；（太分散的话，如果数据量太大导致索引无法全部装入内存造成索引频繁的进行页交换会损失性能）</li>
<li>有足够的粒度进行块拆分。（例如：如果按照用户id分片，但是一个用户可能有很多数据，那一个分片可能无法进行拆分，这就不够细粒度）</li>
</ul>
<h2 id="基本配置选项"><a href="#基本配置选项" class="headerlink" title="基本配置选项"></a>基本配置选项</h2><p>–dbpath<br> 　指向存放数据文件的目录路径，默认是/data/db。<br>–logpath<br> 　指向日志输出文件的路径。日志默认会输出在标准输出（stdout）里。<br>–port<br> 　MongoDB监听的端口；如果没有指定，则设置为27017。<br>–rest<br> 　该标志将开启简单REST接口，增强服务器的默认Web控制台。Web控制台总是运行在服务器监听端口之上的第1000个端口。因此，如果服务器在监听localhost的27017端口，那么Web控制台就在<a href="http://localhost:28017/。请花些时间研究Web控制台及其发布的命令，因为你能从中发现不少线上MongoDB服务器的信息。" target="_blank" rel="noopener">http://localhost:28017/。请花些时间研究Web控制台及其发布的命令，因为你能从中发现不少线上MongoDB服务器的信息。</a><br>–fork<br> 　让进程以守护进程方式运行。请注意，fork只能用在Unix类的系统上。需要类似功能的Windows用户请查看指南，了解如何以Windows服务的方式运行MongoDB。可以在mongodb.org找到这些指南。那些都是最重要的MongoDB启动标志，以下是在命令行中使用它们的例子：<br>$ mongod –dbpath /var/local/mongodb –logpath /var/log/mongodb.log –port 27018 –rest –fork</p>
<p>请注意，你也可以在一个配置文件中指定全部这些选项。创建一个新的文本文件（称为mongodb.conf），内容如下：<br>dbpath=/var/local/mongodb<br>logpath=/var/log/mongodb.log<br>port=27018<br>rest=true<br>fork=true</p>
<p>在调用mongod时，通过-f选项来使用配置文件：<br>$ mongod -f mongodb.conf</p>
<p>如果连接上了一个MongoDB服务器，想知道启动时用了哪些选项，可以运行getCmdLineOpts命令获得一份启动选项列表：</p>
<blockquote>
<p>use admin<br>db.runCommand({getCmdLineOpts: 1})</p>
</blockquote>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm 学习笔记</title>
    <url>/2021/04/03/algorithm/algorithm/</url>
    <content><![CDATA[<h1 id="算法概念"><a href="#算法概念" class="headerlink" title="算法概念"></a>算法概念</h1><p>常数时间的操作：一个操作如果和数据量没有关系，每次都是 固定时间内完成的操作，叫做常数操作。</p>
<p>时间复杂度为一个算法流程中，常数操作数量的指标。常用O（读作big O）来表示。具体来说，在常数操作数量的表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果记为f(N)，那么时间复杂度为O(f(N))。 </p>
<p>评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是常数项时间。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/2021/06/13/database/mysql/</url>
    <content><![CDATA[<p>笔记来源：<a href="https://www.bilibili.com/video/BV12b411K7Zu?p=179" target="_blank" rel="noopener">MySQL_基础+高级篇- 数据库 -sql -mysql教程_mysql视频_mysql入门_尚硅谷_哔哩哔哩_bilibili</a></p>
<p>参考笔记：<a href="http://lihengxu.cn/2021/03/12/MySQL高级/#5-主从复制⭐" target="_blank" rel="noopener">MySQL高级 - LihengXu’s Blog</a></p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis设计与实现-读书笔记</title>
    <url>/2021/07/28/database/redisbooks/</url>
    <content><![CDATA[<h2 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h2><h3 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h3><blockquote>
<p>Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。</p>
</blockquote>
<p>通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</p>
<ul>
<li><p>空间预分配</p>
</li>
<li><p>惰性释放</p>
</li>
</ul>
<p>与此同时，SDS也提供了相应的API，让我们可以在有需要时，真正地释放SDS的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2021/06/12/java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>笔记来源：<a href="https://www.bilibili.com/video/BV1LJ411z7vY?p=1" target="_blank" rel="noopener">【狂神说Java】网络编程实战讲解_哔哩哔哩_bilibili</a></p>
</blockquote>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>客户端</p>
<ol>
<li>连接Socket服务器</li>
<li>发送消息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建一个Socket链接</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建一个输出流</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.读取文件流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"A梦.jpg"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.写文件</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知服务器，我已经传输完成了</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确定服务器接受完毕，才能够断开连接</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buffer2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len2;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">while</span> ((len2 = is.read(buffer2)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer, <span class="number">0</span>, len2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.关闭流</span></span><br><span class="line">        fis.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器</p>
<ol>
<li>建立服务的端口 ServerSocket</li>
<li>等待用户的链接 accept</li>
<li>接受用户的消息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServerDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建服务</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</span><br><span class="line">        <span class="comment">// 2.监听客户端的链接</span></span><br><span class="line">        Socket socket = serverSocket.accept(); <span class="comment">// 阻塞式监听，会一直等待客户端连接</span></span><br><span class="line">        <span class="comment">// 3.获取输入</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 4.文件输出</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"receive2.jpg"</span>)); <span class="comment">//管道流</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知客户端我接受完毕了</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">"我接收完毕了"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><blockquote>
<p>聊天室实现</p>
</blockquote>
<p>接收代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkReceiver</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    DatagramSocket socket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sourcePort;</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkReceiver</span><span class="params">(<span class="keyword">int</span> sourcePort, String from)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sourcePort = sourcePort;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            socket = <span class="keyword">new</span> DatagramSocket(<span class="keyword">this</span>.sourcePort);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] container = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(container, <span class="number">0</span>, container.length);</span><br><span class="line"></span><br><span class="line">                socket.receive(packet);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 断开连接</span></span><br><span class="line">                <span class="keyword">byte</span>[] data = packet.getData();</span><br><span class="line">                String receiveData = <span class="keyword">new</span> String(data, <span class="number">0</span>, packet.getLength());</span><br><span class="line">                System.out.println(from + <span class="string">": "</span> + receiveData);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (receiveData.equalsIgnoreCase(<span class="string">"bye"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkSend</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    DatagramSocket socket = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sourcePort;</span><br><span class="line">    <span class="keyword">private</span> String toIP;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> toPort;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkSend</span><span class="params">(<span class="keyword">int</span> sourcePort, String toIP, <span class="keyword">int</span> toPort)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sourcePort = sourcePort;</span><br><span class="line">        <span class="keyword">this</span>.toIP = toIP;</span><br><span class="line">        <span class="keyword">this</span>.toPort = toPort;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            socket = <span class="keyword">new</span> DatagramSocket(sourcePort);</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                String msg = reader.readLine();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//                                                                                         new InetSocketAddress("localhost", port)</span></span><br><span class="line">                DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(msg.getBytes(), <span class="number">0</span>, msg.getBytes().length, <span class="keyword">new</span> InetSocketAddress(<span class="keyword">this</span>.toIP, <span class="keyword">this</span>.toPort));</span><br><span class="line"></span><br><span class="line">                socket.send(packet);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (msg.equalsIgnoreCase(<span class="string">"bye"</span>))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多线程同时开启发送、接收：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkStudent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkSend(<span class="number">9000</span>, <span class="string">"localhost"</span>, <span class="number">9001</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkReceiver(<span class="number">9002</span>, <span class="string">"老师"</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkTeacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkSend(<span class="number">6666</span>, <span class="string">"localhost"</span>, <span class="number">9002</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkReceiver(<span class="number">9001</span>, <span class="string">"学生"</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://localhost:8080/helloworld/index.jsp?username=123&amp;password=123"</span>);</span><br><span class="line">        System.out.println(url.getProtocol());  <span class="comment">// 协议	http</span></span><br><span class="line">        System.out.println(url.getHost());  <span class="comment">// 主机IP		localhost</span></span><br><span class="line">        System.out.println(url.getPort());  <span class="comment">// 端口		8080</span></span><br><span class="line">        System.out.println(url.getPath());  <span class="comment">// 全路径	    /helloworld/index.jsp</span></span><br><span class="line">        System.out.println(url.getFile());  <span class="comment">// 文件		/helloworld/index.jsp?username=123&amp;password=123</span></span><br><span class="line">        System.out.println(url.getQuery());  <span class="comment">// 参数		username=123&amp;password=123</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDown</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 下载地址</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"https://m10.music.126.net/20200331234653/63b1656b6203fd5693194c6f8b3de8ef/yyaac/obj/wonDkMOGw6XDiTHCmMOi/1941677162/d674/a146/6699/e8b65b7574b1f94e065d312e52135d6d.m4a"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 连接到这个资源</span></span><br><span class="line">        HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection();</span><br><span class="line"></span><br><span class="line">        InputStream inputStream = urlConnection.getInputStream();</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"d.m4a"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fos.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        urlConnection.disconnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Transaction</title>
    <url>/2021/06/26/java/transaction/</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://lugavin.github.io/2018/04/30/javaee/transaction/" target="_blank" rel="noopener">Spring Transaction | Gavin’s blog</a></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring 最成功、最吸引人的地方莫过于轻量级的声明式事务管理，Spring 的声明式事务管理是基于接口代理或动态字节码技术通过 AOP 来实现的：</p>
<ul>
<li>对于基于接口动态代理的 AOP 事务增强来说，由于接口的方法是 public 的，这就要求实现类的实现方法必须是 public 的（不能是 protected、private），同时不能使用 static 的修饰符，所以，可以实施接口动态代理的方法只能是使用 <code>public</code> 或 <code>public final</code> 修饰符的方法，其它方法不可能被动态代理，相应的也就不能实施 AOP 增强，也就不能进行 Spring 事务增强了；</li>
<li>基于 CGLib 字节码动态代理的方案是通过扩展被增强类、动态创建子类的方式进行 AOP 增强植入的，由于使用 final、static、private 修饰符的方法都不能被子类覆盖，相应的，这些方法将不能被实施 AOP 增强，所以，必须特别注意这些修饰符的使用，以免不小心成为事务管理的漏网之鱼。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">动态代理策略</th>
<th align="left">不能被事务增强的方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基于接口的动态代理</td>
<td align="left">除 public 外的其它所有的方法, 此外 public static 也不能被增强</td>
</tr>
<tr>
<td align="left">基于CGLib的动态代理</td>
<td align="left">private、static、final 修饰的方法</td>
</tr>
</tbody></table>
<h2 id="注解事务注意事项"><a href="#注解事务注意事项" class="headerlink" title="注解事务注意事项"></a>注解事务注意事项</h2><ol>
<li>声明式事务有<code>基于@Transactional注解（更灵活）</code>和<code>基于XML配置（事务方法命名要遵循指定的规则）</code>两种方式，若这两种方式同时存在，为避免执行两次AOP切面，被<code>@Transactional</code>注解标注的方法命名不能与XML配置方式中的事务方法命名规则相同。</li>
<li>默认情况下，如果在事务中抛出了运行时异常或者Error，则 Spring 将回滚事务；除此之外，Spring不会回滚事务；如果在事务中抛出其他类型的异常，并期望 Spring 能够回滚事务，可以指定 rollbackFor。</li>
<li>注解<code>@Transactional</code>的事务超时时间 timeout 默认值为-1（表示永不超时）；所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。</li>
<li>注解<code>@Transactional</code>只有应用到<code>public</code>方法，才能进行事务管理。</li>
<li>在Spring的AOP代理下，只有目标方法由外部调用，目标方法才由Spring生成的代理对象来管理，这会造成自调用问题。若同一类中的其他没有<code>@Transactional</code>注解的方法内部调用有<code>@Transactional</code>注解的方法，有<code>@Transactional</code>注解的方法的事务被忽略，不会发生回滚。</li>
<li>注解<code>@Transactional</code>只能应用到<code>public</code>方法和自调用问题，是由于使用Spring AOP代理造成的，为解决这两个问题，使用AspectJ取代Spring AOP代理。</li>
</ol>
<h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><table>
<thead>
<tr>
<th align="left">事务传播行为</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PROPAGATION_REQUIRED</td>
<td align="left">如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中（默认的事务传播行为）</td>
</tr>
<tr>
<td align="left">PROPAGATION_REQUIRES_NEW</td>
<td align="left">新建事务，如果当前存在事务，把当前事务挂起</td>
</tr>
<tr>
<td align="left">PROPAGATION_NESTED</td>
<td align="left">如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作</td>
</tr>
<tr>
<td align="left">PROPAGATION_SUPPORTS</td>
<td align="left">支持当前事务，如果当前没有事务，就以非事务方式执行</td>
</tr>
<tr>
<td align="left">PROPAGATION_NOT_SUPPORTED</td>
<td align="left">以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</td>
</tr>
<tr>
<td align="left">PROPAGATION_MANDATORY</td>
<td align="left">使用当前的事务，如果当前没有事务，就抛出异常</td>
</tr>
<tr>
<td align="left">PROPAGATION_NEVER</td>
<td align="left">以非事务方式执行，如果当前存在事务，则抛出异常</td>
</tr>
</tbody></table>
<p>其中比较容易混淆的是前三种，下面通过代码对这三种传播行为进行详细解释：</p>
<h3 id="PROPAGATION-REQUIRED"><a href="#PROPAGATION-REQUIRED" class="headerlink" title="PROPAGATION_REQUIRED"></a>PROPAGATION_REQUIRED</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ServiceA &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(ServiceA.class);</span><br><span class="line"></span><br><span class="line">    private final ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    public ServiceA(ServiceB serviceB) &#123;</span><br><span class="line">        this.serviceB &#x3D; serviceB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        doSomething();</span><br><span class="line">        serviceB.execute();</span><br><span class="line">        doSomethingElse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doSomething() &#123;</span><br><span class="line">        LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceA.doSomething() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doSomethingElse() &#123;</span><br><span class="line">        LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceA.doSomethingElse() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class ServiceB &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(ServiceB.class);</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceB.execute() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Creating new transaction with name [ServiceA.execute]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT; &#39;&#39;</span><br><span class="line">Acquired Connection for JDBC transaction</span><br><span class="line">Switching JDBC Connection to manual commit</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceA.doSomething() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Participating in existing transaction</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceB.execute() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceA.doSomethingElse() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Initiating transaction commit</span><br><span class="line">Committing JDBC transaction</span><br><span class="line">Releasing JDBC Connection after transaction</span><br><span class="line">Returning JDBC Connection to DataSource</span><br></pre></td></tr></table></figure>



<p>模拟伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection conn &#x3D; DataSourceUtils.getConnection(dataSource);</span><br><span class="line">try &#123;</span><br><span class="line">    serviceA.execute();</span><br><span class="line">    conn.commit();</span><br><span class="line">&#125; catch (RuntimeException ex) &#123;</span><br><span class="line">    conn.rollback();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    DataSourceUtils.releaseConnection(conn, dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PROPAGATION-REQUIRES-NEW"><a href="#PROPAGATION-REQUIRES-NEW" class="headerlink" title="PROPAGATION_REQUIRES_NEW"></a>PROPAGATION_REQUIRES_NEW</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ServiceA &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(ServiceA.class);</span><br><span class="line"></span><br><span class="line">    private final ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    public ServiceA(ServiceB serviceB) &#123;</span><br><span class="line">        this.serviceB &#x3D; serviceB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        doSomething();</span><br><span class="line">        serviceB.execute();</span><br><span class="line">        doSomethingElse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doSomething() &#123;</span><br><span class="line">        LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceA.doSomething() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doSomethingElse() &#123;</span><br><span class="line">        LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceA.doSomethingElse() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class ServiceB &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(ServiceB.class);</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceB.execute() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Creating new transaction with name [ServiceA.execute]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT; &#39;&#39;</span><br><span class="line">Acquired Connection  JDBC transaction</span><br><span class="line">Switching JDBC Connection to manual commit</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceA.doSomething() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Suspending current transaction, creating new transaction with name [ServiceB.execute]</span><br><span class="line">Acquired Connection for JDBC transaction</span><br><span class="line">Switching JDBC Connection to manual commit</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceB.execute() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Initiating transaction commit</span><br><span class="line">Committing JDBC transaction</span><br><span class="line">Releasing JDBC Connection after transaction</span><br><span class="line">Returning JDBC Connection to DataSource</span><br><span class="line">Resuming suspended transaction after completion of inner transaction</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceA.doSomethingElse() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Initiating transaction commit</span><br><span class="line">Committing JDBC transaction</span><br><span class="line">Releasing JDBC Connection after transaction</span><br><span class="line">Returning JDBC Connection to DataSource</span><br></pre></td></tr></table></figure>



<p>模拟伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TransactionalManager tm &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    tm &#x3D; getTransactionalManager();</span><br><span class="line">    tm.begin(); &#x2F;&#x2F; 开启第一个新事务</span><br><span class="line">    Transactional ts1 &#x3D; getTransactional();</span><br><span class="line">    serviceA.doSomething();</span><br><span class="line">    tm.suspend(); &#x2F;&#x2F; 挂起当前事务</span><br><span class="line">    try &#123;</span><br><span class="line">        tm.begin(); &#x2F;&#x2F; 开启第二个新事务</span><br><span class="line">        Transactional ts2 &#x3D; getTransactional();</span><br><span class="line">        serviceB.execute();</span><br><span class="line">        ts2.commit();</span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        ts2.rollback(); &#x2F;&#x2F; 回滚第二个事务</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 释放资源</span><br><span class="line">    &#125;</span><br><span class="line">    tm.resume(ts1); &#x2F;&#x2F; 恢复第一个事务</span><br><span class="line">    serviceA.doSomethingElse();</span><br><span class="line">    ts1.commit();</span><br><span class="line">&#125; catch (RuntimeException ex) &#123;</span><br><span class="line">    ts1.rollback(); &#x2F;&#x2F; 回滚第一个事务</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; 释放资源</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PROPAGATION-NESTED"><a href="#PROPAGATION-NESTED" class="headerlink" title="PROPAGATION_NESTED"></a>PROPAGATION_NESTED</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ServiceA &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(ServiceA.class);</span><br><span class="line"></span><br><span class="line">    private final ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    public ServiceA(ServiceB serviceB) &#123;</span><br><span class="line">        this.serviceB &#x3D; serviceB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        doSomething();</span><br><span class="line">        serviceB.execute();</span><br><span class="line">        doSomethingElse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doSomething() &#123;</span><br><span class="line">        LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceA.doSomething() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doSomethingElse() &#123;</span><br><span class="line">        LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceA.doSomethingElse() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class ServiceB &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(ServiceB.class);</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.NESTED)</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceB.execute() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Creating new transaction with name [ServiceA.execute]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT; &#39;&#39;</span><br><span class="line">Acquired Connection for JDBC transaction</span><br><span class="line">Switching JDBC Connection to manual commit</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceA.doSomething() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Creating nested transaction with name [ServiceB.execute]</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceB.execute() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Releasing transaction savepoint</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Invoke serviceA.doSomethingElse() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Initiating transaction commit</span><br><span class="line">Committing JDBC transaction</span><br><span class="line">Releasing JDBC Connection after transaction</span><br><span class="line">Returning JDBC Connection to DataSource</span><br></pre></td></tr></table></figure>



<p>模拟伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection conn &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    conn &#x3D; getConnection();</span><br><span class="line">    conn.setAutoCommit(false);</span><br><span class="line">    serviceA.doSomething();</span><br><span class="line">    Savepoint savepoint &#x3D; conn.setSavepoint();</span><br><span class="line">    try &#123;</span><br><span class="line">        serviceB.execute();</span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        conn.rollback(savepoint);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 释放资源</span><br><span class="line">    &#125;</span><br><span class="line">    serviceA.doSomethingElse();</span><br><span class="line">    conn.commit();</span><br><span class="line">&#125; catch (RuntimeException ex) &#123;</span><br><span class="line">    conn.rollback();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; 释放资源</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><h3 id="四种事务隔离级别"><a href="#四种事务隔离级别" class="headerlink" title="四种事务隔离级别"></a>四种事务隔离级别</h3><ul>
<li>未提交读（READ-UNCOMMITTED）：可能读取到其他会话中未提交事务修改的数据</li>
<li>已提交读（READ-COMMITTED）：<strong>只能读取到已经提交的数据（Oracle等多数数据库默认都是该级别）</strong></li>
<li>可重复读（REPEATABLE-READ）：<strong>在同一事务内的查询都是与事务开始时刻一致（MySQL默认级别）</strong></li>
<li>可串行化（SERIALIZABLE）：完全串行化地读，每次读都要获得表级共享锁，读写相互都会阻塞</li>
</ul>
<h3 id="三种读类型"><a href="#三种读类型" class="headerlink" title="三种读类型"></a>三种读类型</h3><ul>
<li>脏读（DIRTY READ）：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问同一数据，然后使用了该数据。</li>
</ul>
<p><img src="/images/java/transaction/transaction-isolation-ru.png" alt="READ-UNCOMMITTED"></p>
<p><img src="/images/java/transaction/transaction-isolation-rc.png" alt="READ-COMMITTED"></p>
<ul>
<li>不可重复读（NON-REPEATABLE READ）：是指在一个事务内，多次读同一数据，在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</li>
</ul>
<p><img src="/images/java/transaction/transaction-isolation-nrr.png" alt="NON-REPEATABLE-READ"></p>
<p><img src="/images/java/transaction/transaction-isolation-rr.png" alt="REPEATABLE-READ"></p>
<ul>
<li>幻读（PHANTOM READ）：第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">未提交读</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">已提交读（解决脏读）</td>
<td align="left">N</td>
<td align="left">Y</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">可重复读（解决不可重复读）</td>
<td align="left">N</td>
<td align="left">N</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left">可串行化（解决幻读）</td>
<td align="left">N</td>
<td align="left">N</td>
<td align="left">N</td>
</tr>
</tbody></table>
<blockquote>
<p>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 <code>COMMIT</code> 操作。因此要显式地开启一个事务务须使用命令 <code>BEGIN</code> 或 <code>START TRANSACTION</code>或者执行命令 <code>SET AUTOCOMMIT = 0</code> 用来禁止使用当前会话的自动提交。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT @@global.tx_isolation, @@session.tx_isolation, @@session.autocommit;</span><br><span class="line">SET @@global.tx_isolation &#x3D; &#39;REPEATABLE-READ&#39;;</span><br><span class="line">SET @@session.tx_isolation &#x3D; &#39;READ-COMMITTED&#39;;</span><br><span class="line">SET AUTOCOMMIT &#x3D; 0; -- 禁止自动提交</span><br><span class="line">SET AUTOCOMMIT &#x3D; 1; -- 开启自动提交</span><br></pre></td></tr></table></figure>

<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li><p>单条DML语句是否要加事务？</p>
<blockquote>
<p>DML语句默认就是一个事务的，是原子操作，所以单条DML语句是不需要显式开启事务的。如果对一张表进行了多次 INSERT/UPDATE/DELETE 操作，那么就需要添加事务。准确地说，应该是一次任务中如果有多次 INSERT/UPDATE/DELETE 操作，并且这些操作彼此是不可分割的，要么全部成功要么全部失败，那么就需要使用事务进行管理。特别地，当这个任务中只有一次 INSERT/UPDATE/DELETE 操作时，可以不用显式地声明事务，毕竟一旦报错，数据肯定是没有入库。</p>
</blockquote>
</li>
<li><p>查询语句是否要加事务？</p>
<blockquote>
<p>如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持SQL执行期间的读一致性；如果你一次执行多条查询语句，例如统计查询、报表查询，在这种场景下，多条查询SQL必须保证整体的读一致性，否则，在前条SQL查询之后，后条SQL查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。</p>
</blockquote>
</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-spring-ts1/index.html" target="_blank" rel="noopener">陈雄华. <em>Spring 事务管理高级应用难点剖析</em></a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html" target="_blank" rel="noopener">刘万振.<em>透彻的掌握 Spring 中@transactional 的使用</em></a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-ts1.html" target="_blank" rel="noopener">Mark Richards.<em>了解事务陷阱</em></a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架</title>
    <url>/2021/03/24/java/Colletions/</url>
    <content><![CDATA[<h1 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h1><p><img src="C:/Users/kenny/AppData/Roaming/Typora/typora-user-images/image-20210614162502241.png" alt="image-20210614162502241"></p>
<p><img src="C:/Users/kenny/AppData/Roaming/Typora/typora-user-images/image-20210614162607931.png" alt="image-20210614162607931"></p>
<h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><h3 id="Java集合概述"><a href="#Java集合概述" class="headerlink" title="Java集合概述"></a>Java集合概述</h3><p>在Java中除了以 <code>Map</code> 结尾的类之外，其他类都实现了  <code>Collection</code> 接口并且，以 <code>Map</code> 结尾的类都是实现了 <code>Map</code> 。</p>
<p><img src="/images/java/java-collection-hierarchy.png" alt="Collection"></p>
<h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul>
<li><code>ArrayList</code>: <code>Object[]</code> 数组</li>
<li><code>Vector</code>: <code>Object[]</code> 数组</li>
<li><code>LinkedList</code>: 双向链表</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul>
<li><code>HashSet</code> （无序、唯一）：基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>：<code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>：（有序，唯一）： 红黑树(自平衡的排序二叉树)</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><ul>
<li>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 <strong>10</strong>（JDK8）</li>
<li>ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）（在1.5倍容量仍然小于最小需要容量的情况下则取最小需要容量）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">     <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">     <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">     <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">     <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">     <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">     <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">     <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">         newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">     <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">     elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="System-arraycopy-和-Arrays-copyOf-方法"><a href="#System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="System.arraycopy() 和 Arrays.copyOf()方法"></a>System.arraycopy() 和 Arrays.copyOf()方法</h4><ul>
<li>ArrayList 中大量调用了这两个方法。比如：扩容操作以及add(int index, E element)、toArray() 等方法中都用到了该方法！<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Arrays.copyOf()方法主要是为了给原有数组扩容<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"> <span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">     <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="联系-amp-amp-区别"><a href="#联系-amp-amp-区别" class="headerlink" title="联系&amp;&amp;区别"></a>联系&amp;&amp;区别</h5><p>联系：<br>看两者源代码可以发现 copyOf()内部实际调用了 System.arraycopy() 方法</p>
<p>区别：<br>arraycopy() 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 copyOf() 是系统自动在内部新建一个数组，并返回该数组。</p>
<h4 id="未初始化足够容量的情况下，最好在-add-大量元素之前用-ensureCapacity-方法，以减少增量重新分配的次数"><a href="#未初始化足够容量的情况下，最好在-add-大量元素之前用-ensureCapacity-方法，以减少增量重新分配的次数" class="headerlink" title="未初始化足够容量的情况下，最好在 add 大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数"></a>未初始化足够容量的情况下，最好在 add 大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数</h4><h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h3><h4 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor"></a>tableSizeFor</h4><ul>
<li>tableSizeFor的功能（不考虑大于最大容量的情况）是返回大于输入参数且最近的2的整数次幂的数。比如10，则返回16。该算法源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详解如下：</p>
<p>先来分析有关n位操作部分：先来假设n的二进制为01xxx…xxx。接着<br>对n右移1位：001xx…xxx，再位或：011xx…xxx<br>对n右移2为：00011…xxx，再位或：01111…xxx<br>此时前面已经有四个1了，再右移4位且位或可得8个1<br>同理，有8个1，右移8位肯定会让后八位也为1。<br>综上可得，该算法让最高位的1后面的位全变为1。<br>最后再让结果n+1，即得到了2的整数次幂的值了。</p>
<p>现在回来看看第一条语句：<br>int n = cap - 1;<br>　　让cap-1再赋值给n的目的是另找到的目标值大于或等于原值。例如二进制1000，十进制数值为8。如果不对它减1而直接操作，将得到答案10000，即16。显然不是结果。减1后二进制为111，再进行操作则会得到原来的数值1000，即8。</p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><ul>
<li>JDK1.8 ConcurrentHashMap 采用的是Node 数组 + 链表 / 红黑树的方式（与HashMap结构类似），并采用 CAS 和 synchronized 来保证并发安全。synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。<br><img src="/images/java/java8_ConcurrentHashMap.png" alt="JDK1.8 的 ConcurrentHashMap"></li>
<li>JDK1.7 ConcurrentHashMap 底层采用 分段的数组+链表 实现，对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。<br><img src="/images/java/ConcurrentHashMap%E5%88%86%E6%AE%B5%E9%94%81-jdk1.7.jpg" alt="JDK1.7 的 ConcurrentHashMap"></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2021/04/16/tools/git/</url>
    <content><![CDATA[<h1 id="Git-概念"><a href="#Git-概念" class="headerlink" title="Git 概念"></a>Git 概念</h1><ul>
<li><p>工作区：文件区</p>
</li>
<li><p>暂存区：暂时存放</p>
</li>
<li><p>本地库（版本库）： Git 的版本库</p>
</li>
<li><p>LF &amp;&amp; CRLF：CRLF, LF 是用来表示文本换行的方式。CR(Carriage Return) 代表回车，对应字符 <code>&#39;\r&#39;</code>；LF(Line Feed) 代表换行，对应字符 <code>&#39;\n&#39;</code>。由于历史原因，不同的操作系统文本使用的换行符各不相同。主流的操作系统一般使用CRLF或者LF作为其文本的换行符。其中，Windows 系统使用的是 CRLF,  Unix系统(包括Linux, MacOS近些年的版本) 使用的是LF。</p>
</li>
</ul>
<h1 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git  命令"></a>Git  命令</h1><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>配置个人的用户名称和电子邮件地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --global 是否全局设置，添加了</span></span><br><span class="line">git config [--global] user.name "name"</span><br><span class="line">git config [--global] user.email "email"</span><br></pre></td></tr></table></figure>

<p>##　基本命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化git本地仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝一份远程仓库</span></span><br><span class="line">git clone</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  将工作区的新建、修改添加到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把文件从暂存区域移除</span></span><br><span class="line">git rm --cached .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将暂存区的内容提交到本地库（版本库）</span></span><br><span class="line">git commit -m "message"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在暂存区的文件可以使用这个命令进行提交</span></span><br><span class="line">git commit -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送到远程库</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 状态查看，查看工作区、暂存区状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接远程仓库</span></span><br><span class="line">git remote add origin https://github.com/xxx/xxx.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地仓库分支重命名</span></span><br><span class="line">git branch -m master main</span><br></pre></td></tr></table></figure>

<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><ul>
<li><p>查看日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit d8837177c5a03c51b53e9505a8ee5e8c3deba64e (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: Name &lt;test.github.com&gt;</span><br><span class="line">Date:   Thu Apr 15 11:05:01 2021 +0800</span><br><span class="line"></span><br><span class="line">    Update Docker.md</span><br></pre></td></tr></table></figure>

<blockquote>
<p>操作方式</p>
<p>空格：向下翻页</p>
<p>b：向上翻页</p>
<p>q：退出</p>
</blockquote>
</li>
<li><p>单行模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">d8837177c5a03c51b53e9505a8ee5e8c3deba64e (HEAD -&gt; master, origin/master, origin/HEAD) Update Docker.md</span><br><span class="line">74f4d8ad90cd49068d9701577ab02ad841f08c9c Update Docker.md</span><br></pre></td></tr></table></figure>
</li>
<li><p>reflog</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br><span class="line">d883717 (HEAD -&gt; master, origin/master, origin/HEAD) HEAD@&#123;0&#125;: pull: Fast-forward</span><br></pre></td></tr></table></figure>

<blockquote>
<p>HEAD@{0} 表示移动到当前版本需要多少步</p>
</blockquote>
</li>
</ul>
<h2 id="版本前进、后退"><a href="#版本前进、后退" class="headerlink" title="版本前进、后退"></a>版本前进、后退</h2><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><h2 id="Git-fatal-refusing-to-merge-unrelated-histories解决"><a href="#Git-fatal-refusing-to-merge-unrelated-histories解决" class="headerlink" title="Git :fatal: refusing to merge unrelated histories解决"></a>Git :fatal: refusing to merge unrelated histories解决</h2><p>把本地仓库和Github上关联以后，git pull origin main 时，git feach提醒fatal: refusing to merge unrelated histories</p>
<p>原因是两个分支是两个不同的版本，具有不同的提交历史</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br><span class="line">可以允许不相关历史提，强制合并，确实解决了这个问题，感谢网友</span><br></pre></td></tr></table></figure>

<h2 id="Failed-to-connect-to-github-com-port-443-Timed-out"><a href="#Failed-to-connect-to-github-com-port-443-Timed-out" class="headerlink" title="Failed to connect to github.com port 443: Timed out"></a>Failed to connect to github.com port 443: Timed out</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>git bash 执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br></pre></td></tr></table></figure>

<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>![image-20210527124353470](/images/tools/git/connect Time Out问题.png)</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习笔记</title>
    <url>/2021/04/03/tools/docker/</url>
    <content><![CDATA[<blockquote>
<p>docker中文教程：<a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">docker-practice</a></p>
<p>docker官方文档：<a href="https://docs.docker.com/" target="_blank" rel="noopener">docker doc</a></p>
</blockquote>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 卸载旧版本</span></span><br><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新apt软件包索引并安装软件包，以允许apt通过HTTPS使用存储库</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加Docker的官方GPG密钥</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加docker库</span></span><br><span class="line">echo \</span><br><span class="line">  "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="line"><span class="meta">  $</span><span class="bash">(lsb_release -cs) stable<span class="string">" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装docker引擎</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动docker</span></span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试docker</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<h2 id="Ubuntu-WSL安装"><a href="#Ubuntu-WSL安装" class="headerlink" title="Ubuntu-WSL安装"></a>Ubuntu-WSL安装</h2><h3 id="docker-in-window-安装"><a href="#docker-in-window-安装" class="headerlink" title="docker in window 安装"></a>docker in window 安装</h3><ul>
<li>下载docker for window</li>
<li>配置公开没有TLS的守护进程<br><img src="/images/tools/docker/docker-in-window-settings.png" alt="docker-in-window-settings"></li>
</ul>
<h3 id="WSL-Ubuntu-Docker-设置"><a href="#WSL-Ubuntu-Docker-设置" class="headerlink" title="WSL Ubuntu Docker 设置"></a>WSL Ubuntu Docker 设置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新apt软件包索引并安装软件包，以允许apt通过HTTPS使用存储库</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加Docker的官方GPG密钥</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加docker库</span></span><br><span class="line">echo \</span><br><span class="line">  "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="line"><span class="meta">  $</span><span class="bash">(lsb_release -cs) stable<span class="string">" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装docker引擎</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置允许非root用户访问（如果不设置则在执行脚本时可能会遇到权限错误）：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo usermod -aG docker <span class="variable">$USER</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过以下命令将WSL Docker连接至Windows下的Docker Dameon </span></span><br><span class="line">`echo "export DOCKER_HOST=tcp://localhost:2375" &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试docker</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>

<h1 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h1><h2 id="Docker-镜像命令"><a href="#Docker-镜像命令" class="headerlink" title="Docker 镜像命令"></a>Docker 镜像命令</h2><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search IMAGE</span><br></pre></td></tr></table></figure>

<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull</span><br></pre></td></tr></table></figure>

<h3 id="查看已下载镜像列表"><a href="#查看已下载镜像列表" class="headerlink" title="查看已下载镜像列表"></a>查看已下载镜像列表</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi</span><br></pre></td></tr></table></figure>


<h2 id="Docker-容器命令"><a href="#Docker-容器命令" class="headerlink" title="Docker 容器命令"></a>Docker 容器命令</h2><h3 id="新建容器并运行"><a href="#新建容器并运行" class="headerlink" title="新建容器并运行"></a>新建容器并运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker run IMAGE [COMMOND] [ARG...]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数</span></span><br><span class="line">--name  name 别名</span><br><span class="line">-d      后台方式运行</span><br><span class="line">-it     交互式运行，进入容器查看内容</span><br><span class="line">-p      指定容器端口 -p 8080:8080</span><br><span class="line">docker run centos</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建并运行容器，然后进入容器终端</span></span><br><span class="line">docker run -i -t  --name test centos /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~$ docker run -it centos /bin/bash</span><br><span class="line">[root@a86442f09d0a /]#</span><br></pre></td></tr></table></figure>

<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit 推出交互式节目，容器停止运行</span><br><span class="line">Ctrl + P 然后 ctrl + Q 退出交互式界面，容器在后台运行。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@a86442f09d0a /]# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a 查看所有容器</span><br><span class="line">-q 只列出容器id</span><br><span class="line">docker ps -aq</span><br></pre></td></tr></table></figure>

<h3 id="移除容器"><a href="#移除容器" class="headerlink" title="移除容器"></a>移除容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-f 强制移除</span><br><span class="line"><span class="meta">$</span><span class="bash">(docker ps -aq) 将所有容器id作为参数传给rm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">docker rm -f $(docker ps -aq)  # 删除所有容器</span><br><span class="line">docker rm 容器id				  # 删除指定容器，不能删除正在进行的容器</span><br><span class="line">docker ps -aq|xargs docker rm  # 删除所有容器</span><br></pre></td></tr></table></figure>

<h3 id="启动和停止容器"><a href="#启动和停止容器" class="headerlink" title="启动和停止容器"></a>启动和停止容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start 容器id		# 启动容器</span><br><span class="line">docker restart 容器id		# 重启容器</span><br><span class="line">docker stop 容器id		# 停止当前正在运行容器</span><br><span class="line">docker kill 容器id		# 强制停止容器</span><br></pre></td></tr></table></figure>



<h2 id="容器其他命令"><a href="#容器其他命令" class="headerlink" title="容器其他命令"></a>容器其他命令</h2><h3 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker run -d 镜像名	需要有一个前台进程，docker发现没有应用，就会自动停止</span></span><br></pre></td></tr></table></figure>

<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker logs -f -t --tail number</span></span><br><span class="line">--tail 查看多少条日志</span><br><span class="line">-t	   显示时间戳</span><br></pre></td></tr></table></figure>

<h3 id="查看容器进程信息"><a href="#查看容器进程信息" class="headerlink" title="查看容器进程信息"></a>查看容器进程信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker top</span><br><span class="line">kennycai@DESKTOP-M38LAH7:~$ docker top c31b06ca04f6</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                2539                2519                0                   03:44               ?                   00:00:00            /bin/bash</span><br></pre></td></tr></table></figure>

<h3 id="查看镜像元数据"><a href="#查看镜像元数据" class="headerlink" title="查看镜像元数据"></a>查看镜像元数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>

<h3 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器id /bin/bash	# 进入容器后开启一个新的终端，打开一个新的命令行</span><br><span class="line">kennycai@DESKTOP-M38LAH7:~$ docker exec -it c31b06ca04f6 /bin/bash</span><br><span class="line">[root@c31b06ca04f6 /]#</span><br><span class="line"></span><br><span class="line">docker attach 容器id				# 进入容器当前正在执行的终端</span><br><span class="line">kennycai@DESKTOP-M38LAH7:~$ docker attach c31b06ca04f6</span><br><span class="line">[root@c31b06ca04f6 /]#</span><br></pre></td></tr></table></figure>

<h3 id="容器内的文件拷贝到容器外"><a href="#容器内的文件拷贝到容器外" class="headerlink" title="容器内的文件拷贝到容器外"></a>容器内的文件拷贝到容器外</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器id:容器目录文件 主机目录</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/tools/docker/docker.jpg" alt="Docker"></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="部署nginx"><a href="#部署nginx" class="headerlink" title="部署nginx"></a>部署nginx</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行镜像</span></span><br><span class="line">-d 后台运行</span><br><span class="line">--name 别名</span><br><span class="line">-p 端口映射</span><br><span class="line">docker run -d --name nginx-test -p 3344:80 nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入nginx</span></span><br><span class="line">docker exec -it nginx-test /bin/bash</span><br></pre></td></tr></table></figure>

<h3 id="部署tomcat"><a href="#部署tomcat" class="headerlink" title="部署tomcat"></a>部署tomcat</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker run -it --rm tomcat 用完即删除容器 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取镜像</span></span><br><span class="line">docker pull tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行镜像</span></span><br><span class="line">-d 后台运行</span><br><span class="line">--name 别名</span><br><span class="line">-p 端口映射</span><br><span class="line">docker run -d --name tomcat-test -p 8080:8080 tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入tomcat</span></span><br><span class="line">docker exec -it tomcat-test /bin/bash</span><br></pre></td></tr></table></figure>

<h3 id="部署es-kibana"><a href="#部署es-kibana" class="headerlink" title="部署es+kibana"></a>部署es+kibana</h3><h1 id="Docker-镜像讲解"><a href="#Docker-镜像讲解" class="headerlink" title="Docker 镜像讲解"></a>Docker 镜像讲解</h1><h2 id="UninoFS（联合文件系统）"><a href="#UninoFS（联合文件系统）" class="headerlink" title="UninoFS（联合文件系统）"></a>UninoFS（联合文件系统）</h2><p>UninoFS：是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，UninoFS文件系统是docker镜像的基础，镜像可以通过分层来实现的，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。<br>特性：一次同时加载多个文件系统，但是从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会保函所有底层的文件和目录。</p>
<h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><p>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统（UinnioFS）<br>（系统启动需要引导加载）黑屏-开机-显示屏幕 –加载<br>Bootfs（boot file system）主要包括bootloader和kernel，bootloader主要时引导加载kernal，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs，这一层与我们典型的Linux系统时一样的，包含boot加载器和内核，当boot加载完成之后整个内核都在内存中了，此时内存的使用权已有bootfs转交给内核，此时也会卸载bootfs。<br>Rootfs（root file system）在bootfs之上，包含的就是典型的linux系统中的/dev /proc /bin /etc 等标准目录和文件，rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos<br>对于一个精简的OS(内核)，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host（主机的）的Kernel,自己只需要提供rootfs就可以了，由此可见对于不同的linux发行版，bootfs基本时一致的，因此不同的发行版可以公用bootfs</p>
<h2 id="分层的原理"><a href="#分层的原理" class="headerlink" title="分层的原理"></a>分层的原理</h2><p>所有的docker镜像都起始于一个基础镜像层，当进行修改或者增加新的内容时，就会在当前镜像层之上，创建新的镜像层，比如：假设基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层，如果在该镜像中添加python包，就会在基础镜像层之上创建第二个镜像层，如果继续添加一个安全补丁，就会创建第三个镜像层，该镜像当前已经包含3个镜像层。<br>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要！<br>注意：假如在docker中又添加了python的最新版本，这时，docker并不会新增加一层，而是用最新版本的python替换了原来的旧版本python！</p>
<h2 id="提交镜像"><a href="#提交镜像" class="headerlink" title="提交镜像"></a>提交镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit -m='描述' -a='作者' 容器id 容器名:版本</span><br></pre></td></tr></table></figure>



<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><p>容器数据卷提供了容器的持久化和同步操作！容器间也可以共享数据！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-v localpath:dockpath</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器删除，本地数据不会丢失</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:docker run -d -v F://workspace/dockerwolumn5:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure>

<h2 id="匿名挂载、具名挂载、指定路径挂载"><a href="#匿名挂载、具名挂载、指定路径挂载" class="headerlink" title="匿名挂载、具名挂载、指定路径挂载"></a>匿名挂载、具名挂载、指定路径挂载</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-v 容器内路径			# 匿名挂载</span><br><span class="line">-v 具名:容器内路径		   # 具名挂载	</span><br><span class="line">-v /宿主机路径:容器内路径  # 指定路径挂载</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载 测试</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~$ docker run -d -v /var/lib/mysql mysql:5.7</span><br><span class="line">f28c24a185056025f0590862559d7cacaabf22e5e476f89b99f400a1193d18e7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 具名挂载 测试</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~$ docker run -d -v name:/var/lib/mysql mysql:5.7</span><br><span class="line">f28c24a185056025f0590862559d7cacaabf22e5e476f89b99f400a1193d18e7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器卷</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~$ docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     8c45c1a0a7e6e0aa91a2f71fdf2a2f231bba25976e1e0cb541f7a05e753658fa</span><br><span class="line">local     9e20887c8eb3b6204706894316fd4f7c645f11959237721c1f46dbb997697008</span><br><span class="line">local     name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看容器卷信息</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~$ docker volume inspect 9e20887c8eb3b6204706894316fd4f7c645f11959237721c1f46dbb997697008</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "CreatedAt": "2021-03-23T13:31:36Z",</span><br><span class="line">        "Driver": "local",</span><br><span class="line">        "Labels": null,</span><br><span class="line">        "Mountpoint": "/var/lib/docker/volumes/9e20887c8eb3b6204706894316fd4f7c645f11959237721c1f46dbb997697008/_data",</span><br><span class="line">        "Name": "9e20887c8eb3b6204706894316fd4f7c645f11959237721c1f46dbb997697008",</span><br><span class="line">        "Options": null,</span><br><span class="line">        "Scope": "local"</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：docker in window 用的是虚拟机技术，容器卷的位置在浏览器访问以下指令可以进入.vhdx中 <code>\\wsl$\docker-desktop-data\version-pack-data\community\docker\volumes\</code> 查看</p>
</blockquote>
<p><img src="/images/tools/docker/WSL-l-v.png" alt="WSL-l-v"></p>
<p><img src="/images/tools/docker/WSL-volume-path.png" alt="WSL-volume-path.png"></p>
<p>扩展</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 容器内路径:ro rw 改变独写权限</span></span><br><span class="line">ro readonly  # 只读</span><br><span class="line">rw readwrite # 可读可写</span><br><span class="line"><span class="meta">#</span><span class="bash"> 一旦设置了容器权限，容器对挂载出来的内容就有了限定</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ro 只能通过宿主机改变，容器内部无法操作，默认rw</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~$ docker run -d -v name:/var/lib/mysql:ro mysql:5.7</span><br><span class="line">kennycai@DESKTOP-M38LAH7:~$ docker run -d -v name:/var/lib/mysql:rw mysql:5.7</span><br></pre></td></tr></table></figure>

<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><p>dockerfile 是用来构建docker镜像的文件</p>
<p>构建过程：</p>
<ol>
<li>构建一个dockerfile文件</li>
<li>docker build 构建成一个镜像</li>
<li>docker run 运行镜像</li>
<li>docker push 发布镜像（DockerHub，阿里云镜像仓库）</li>
</ol>
<h2 id="DockerFile构建过程"><a href="#DockerFile构建过程" class="headerlink" title="DockerFile构建过程"></a>DockerFile构建过程</h2><ol>
<li>每个报类关键字（指令）都是大写字母</li>
<li>执行从上到下的顺序</li>
<li>#表示注释</li>
<li>每一个指令都会创建提交一个新的镜像层。</li>
</ol>
<p>DokckerFile：构建文件，定义了一切的步骤，源代码</p>
<p>DockerImages：通过DockerFile 构建生成的镜像，最终发布和运行的产品</p>
<p>Docker容器：容器是镜像运行起来的服务</p>
<h2 id="DockerFile指令"><a href="#DockerFile指令" class="headerlink" title="DockerFile指令"></a>DockerFile指令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM			# 基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER  	# 镜像是谁写的，姓名+邮件</span><br><span class="line">RUN				# 镜像构建的时候需要运行的命令</span><br><span class="line">ADD				# 添加内容</span><br><span class="line">WORKDIR			# 镜像的工作目录</span><br><span class="line">VOLUME			# 挂载的目录</span><br><span class="line">EXPOSE			# 暴露端口</span><br><span class="line">CMD				# 指定容器启动的时间要运行的命令，只有最后一个会生效，可被替代。(例如 CMD ["ls"，"-a"])，docker run -l，会替换成docker run -l</span><br><span class="line">ENTRYPOINT		# 指定这个容器启动的时候要运行的命令。(例如 CMD ["ls"，"-a"])，docker run -l，会替换成docker run ls -al</span><br><span class="line">ONBUILD			# 当构建一个被继承的 DockerFile时会运行 ONBUILD 的命令。</span><br><span class="line">COPY			# 类似ADD，将文件拷贝到镜像中</span><br><span class="line">ENV				# 构建时设置环境变量</span><br></pre></td></tr></table></figure>

<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编写dockerFile</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ cat dockerfile-centos</span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER kennycai&lt;qq.qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV WORKPATH /usr/local</span><br><span class="line">WORKDIR $WORKPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $WORKPATH</span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> build</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker build -f dockerfile-centos -t mycentos:0.1 .</span><br><span class="line">[+] Building 33.0s (8/8) FINISHED</span><br><span class="line"> =&gt; [internal] load build definition from dockerfile-centos                                            0.2s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 236B                                                                   0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                      0.2s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                        0.0s</span><br><span class="line"> =&gt; [internal] load metadata for docker.io/library/centos:latest                                       0.0s</span><br><span class="line"> =&gt; [1/4] FROM docker.io/library/centos                                                                0.1s</span><br><span class="line"> =&gt; [2/4] WORKDIR /usr/local                                                                           0.2s</span><br><span class="line"> =&gt; [3/4] RUN yum -y install vim                                                                       27.8s</span><br><span class="line"> =&gt; [4/4] RUN yum -y install net-tools                                                                 3.3s</span><br><span class="line"> =&gt; exporting to image                                                                                 0.9s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                0.9s</span><br><span class="line"> =&gt; =&gt; writing image sha256:01ffa757ed9ba3fba11c1a3e325e06799692207793f4e98b3820b2664a2d2062           0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/mycentos:0.1                                                        0.0s</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker run -it mycentos:0.1</span><br></pre></td></tr></table></figure>

<h2 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a>docker history</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker <span class="built_in">history</span></span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker history 01ffa757ed9b</span><br><span class="line">IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT</span><br><span class="line">01ffa757ed9b   3 minutes ago   CMD ["/bin/sh" "-c" "/bin/bash"]                0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      3 minutes ago   CMD ["/bin/sh" "-c" "echo $WORKPATH"]           0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      3 minutes ago   EXPOSE map[80/tcp:&#123;&#125;]                           0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      3 minutes ago   RUN /bin/sh -c yum -y install net-tools # bu…   14.4MB    buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      3 minutes ago   RUN /bin/sh -c yum -y install vim # buildkit    58.1MB    buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      4 minutes ago   WORKDIR /usr/local                              0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      4 minutes ago   ENV WORKPATH=/usr/local                         0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      4 minutes ago   MAINTAINER kennycai&lt;qq.qq.com&gt;                  0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      4 months ago    /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B</span><br><span class="line">&lt;missing&gt;      4 months ago    /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B</span><br><span class="line">&lt;missing&gt;      4 months ago    /bin/sh -c #(nop) ADD file:bd7a2aed6ede423b7…   209MB</span><br></pre></td></tr></table></figure>

<h2 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h2><ol>
<li>注册Docker Hub账号</li>
<li>docker login -u</li>
<li>docker push username/镜像名:版本号</li>
</ol>
<h3 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br></pre></td></tr></table></figure>

<h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker run -d -P --name tomcat01 tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器的内部网络地址</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker exec -it tomcat01 ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: sit0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/sit 0.0.0.0 brd 0.0.0.0</span><br><span class="line">89: eth0@if90: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="meta">#</span><span class="bash"> linux 可以ping通容器内部</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理</p>
</blockquote>
<ol>
<li>每启动一个容器，docker就会给容器创建一个 ip，只要安装了 docker，就会有一个网卡 <code>docker0</code>。使用的时 <code>evth-pair</code> 技术</li>
</ol>
<p><img src="/images/tools/docker/docker%E7%BD%91%E7%BB%9C%E6%88%AA%E5%9B%BE.png" alt="docker网络截图"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 容器的网卡都是一对对的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> evth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 正因为有这个特性，evth-pair 充当一个桥梁，连接各种虚拟网络设备</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：tomcat01 和 tomcat02 是共用的一个路由器，docker0</p>
<p>Docker使用的是Linux的桥接，宿主机中是一个Docker容器的网桥，docker0</p>
</blockquote>
<p><img src="/images/tools/docker/docker%E7%BD%91%E7%BB%9C%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.png" alt="docker网络桥接模式"></p>
<p><img src="/images/tools/docker/docker%E7%BD%91%E7%BB%9C%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F2.png" alt="docker网络桥接模式2"></p>
<h2 id="容器互联：–link（不建议使用）"><a href="#容器互联：–link（不建议使用）" class="headerlink" title="容器互联：–link（不建议使用）"></a>容器互联：–link（不建议使用）</h2><p>通过–link可以实现容器间通过服务名ping通</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker run -d -P --name tomcat03 --link tomcat01 tomcat</span><br><span class="line">b8be16b2097be91464061eff924238e3e13759c0320cd64b883bfca4dc472417</span><br><span class="line"></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker exec -it tomcat03 ping tomcat01</span><br><span class="line">PING tomcat01 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat01 (172.17.0.2): icmp_seq=1 ttl=64 time=1.32 ms</span><br><span class="line">64 bytes from tomcat01 (172.17.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line">64 bytes from tomcat01 (172.17.0.2): icmp_seq=3 ttl=64 time=0.083 ms</span><br><span class="line">64 bytes from tomcat01 (172.17.0.2): icmp_seq=4 ttl=64 time=0.055 ms</span><br><span class="line">64 bytes from tomcat01 (172.17.0.2): icmp_seq=5 ttl=64 time=0.062 ms</span><br><span class="line">...</span><br><span class="line">^C</span><br><span class="line">--- tomcat01 ping statistics ---</span><br><span class="line">23 packets transmitted, 23 received, 0% packet loss, time 897ms</span><br><span class="line">rtt min/avg/max/mdev = 0.052/0.126/1.317/0.256 ms</span><br></pre></td></tr></table></figure>

<p>实现原理：–link就是在hosts配置中增加了一个tomcat01的配置 <code>172.17.0.2      tomcat01 7eecf4a94460</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看hosts配置</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker exec -it tomcat03 cat /etc/hosts</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">172.17.0.2      tomcat01 7eecf4a94460</span><br><span class="line">172.17.0.3      b8be16b2097b</span><br></pre></td></tr></table></figure>



<h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><p>![docker网络-docker network ls](/images/tools/docker/docker网络-docker network ls.png)</p>
<p><strong>网络模式</strong></p>
<p>bridge：桥接 docker默认</p>
<p>none： 不配置网络</p>
<p>host： 和宿主机共享网络</p>
<p>container：容器网络连通（局限性大）</p>
<p><strong>自定义网络</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --subnet			子网</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --gateway			网关</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --driver	bridge 	桥接模式</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">6807b08beb858a3d12e62b1dee81cf1c94a197053953a65a17b4d4d95f98e605</span><br><span class="line"></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">9ea2081e8adc   bridge    bridge    local</span><br><span class="line">24f027fd73ea   host      host      local</span><br><span class="line">6807b08beb85   mynet     bridge    local</span><br><span class="line">a302044f08b8   none      null      local</span><br></pre></td></tr></table></figure>

<p><strong>将服务创建在自己的网络中</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 --net 指定网络</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker run -d -P --name tomcat-net-01 --net mynet tomcat</span><br><span class="line">28fd86ce9ed4d8a00071eba3acfe93fd967672fda76c939d0fdc8587e47d22c4</span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker run -d -P --name tomcat-net-02 --net mynet tomcat</span><br><span class="line">b94e30b9a734f6ae71e6624971dfca5d8448013376e71000201564510179ab56</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看mynet信息</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker network inspect mynet</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "Name": "mynet",</span><br><span class="line">        "Id": "6807b08beb858a3d12e62b1dee81cf1c94a197053953a65a17b4d4d95f98e605",</span><br><span class="line">        "Created": "2021-04-11T03:55:18.2507775Z",</span><br><span class="line">        "Scope": "local",</span><br><span class="line">        "Driver": "bridge",</span><br><span class="line">        "EnableIPv6": false,</span><br><span class="line">        "IPAM": &#123;</span><br><span class="line">            "Driver": "default",</span><br><span class="line">            "Options": &#123;&#125;,</span><br><span class="line">            "Config": [</span><br><span class="line">                &#123;</span><br><span class="line">                    "Subnet": "192.168.0.0/16",</span><br><span class="line">                    "Gateway": "192.168.0.1"</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        "Internal": false,</span><br><span class="line">        "Attachable": false,</span><br><span class="line">        "Ingress": false,</span><br><span class="line">        "ConfigFrom": &#123;</span><br><span class="line">            "Network": ""</span><br><span class="line">        &#125;,</span><br><span class="line">        "ConfigOnly": false,</span><br><span class="line">        "Containers": &#123;</span><br><span class="line">            "28fd86ce9ed4d8a00071eba3acfe93fd967672fda76c939d0fdc8587e47d22c4": &#123;</span><br><span class="line">                "Name": "tomcat-net-01",</span><br><span class="line">                "EndpointID": "24c8810aa28a69360e47fd183d40d6aa32b4cc3437434627476e54e93d928ae8",</span><br><span class="line">                "MacAddress": "02:42:c0:a8:00:02",</span><br><span class="line">                "IPv4Address": "192.168.0.2/16",</span><br><span class="line">                "IPv6Address": ""</span><br><span class="line">            &#125;,</span><br><span class="line">            "b94e30b9a734f6ae71e6624971dfca5d8448013376e71000201564510179ab56": &#123;</span><br><span class="line">                "Name": "tomcat-net-02",</span><br><span class="line">                "EndpointID": "c07247228ae8d9e6da8001638ecfadc3e362f368f7f5db42a841e152a153dad2",</span><br><span class="line">                "MacAddress": "02:42:c0:a8:00:03",</span><br><span class="line">                "IPv4Address": "192.168.0.3/16",</span><br><span class="line">                "IPv6Address": ""</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "Options": &#123;&#125;,</span><br><span class="line">        "Labels": &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># tomcat-net-01 和 tomcat-net-02 可以通过服务名互相ping通，不需要使用--link</span></span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker exec -it tomcat-net-01 ping tomcat-net-02</span><br><span class="line">PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.231 ms</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.062 ms</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.066 ms</span><br><span class="line">^C</span><br><span class="line">--- tomcat-net-02 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 51ms</span><br><span class="line">rtt min/avg/max/mdev = 0.062/0.119/0.231/0.079 ms</span><br><span class="line"></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker exec -it tomcat-net-02 ping tomcat-net-01</span><br><span class="line">PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.411 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.062 ms</span><br><span class="line">^C</span><br><span class="line">--- tomcat-net-01 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 3ms</span><br><span class="line">rtt min/avg/max/mdev = 0.062/0.236/0.411/0.175 ms</span><br></pre></td></tr></table></figure>

<h2 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h2><p>不同的两个网络间的容器连接的问题，如docker0网络下的tomcat01访问mynet</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建两个在docker0的容器</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker run -d -P --name tomcat02 tomcat</span><br><span class="line">ef7273a12c8c6becae8450a3ec728e7753a6e7adc9ad9fe73f814c04c0c741a9</span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker run -d -P --name tomcat01 tomcat</span><br><span class="line">27150369994eb0933dabd7bf4a889b31c7b5d146d7e0bd80adf81521da87b80b</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> tomcat01连接mynet网络</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker network connect mynet tomcat01</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看mynet信息，containers中多了一个tomcat01</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker network inspect mynet</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "Name": "mynet",</span><br><span class="line">        "Id": "6807b08beb858a3d12e62b1dee81cf1c94a197053953a65a17b4d4d95f98e605",</span><br><span class="line">        "Created": "2021-04-11T03:55:18.2507775Z",</span><br><span class="line">        "Scope": "local",</span><br><span class="line">        "Driver": "bridge",</span><br><span class="line">        "EnableIPv6": false,</span><br><span class="line">        "IPAM": &#123;</span><br><span class="line">            "Driver": "default",</span><br><span class="line">            "Options": &#123;&#125;,</span><br><span class="line">            "Config": [</span><br><span class="line">                &#123;</span><br><span class="line">                    "Subnet": "192.168.0.0/16",</span><br><span class="line">                    "Gateway": "192.168.0.1"</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        "Internal": false,</span><br><span class="line">        "Attachable": false,</span><br><span class="line">        "Ingress": false,</span><br><span class="line">        "ConfigFrom": &#123;</span><br><span class="line">            "Network": ""</span><br><span class="line">        &#125;,</span><br><span class="line">        "ConfigOnly": false,</span><br><span class="line">        "Containers": &#123;</span><br><span class="line">            "27150369994eb0933dabd7bf4a889b31c7b5d146d7e0bd80adf81521da87b80b": &#123;</span><br><span class="line">                "Name": "tomcat01",</span><br><span class="line">                "EndpointID": "9addff770af1f15cba77c92cf95658b3f5877e697c6f653b503e681d3cf47552",</span><br><span class="line">                "MacAddress": "02:42:c0:a8:00:04",</span><br><span class="line">                "IPv4Address": "192.168.0.4/16",</span><br><span class="line">                "IPv6Address": ""</span><br><span class="line">            &#125;,</span><br><span class="line">            "28fd86ce9ed4d8a00071eba3acfe93fd967672fda76c939d0fdc8587e47d22c4": &#123;</span><br><span class="line">                "Name": "tomcat-net-01",</span><br><span class="line">                "EndpointID": "24c8810aa28a69360e47fd183d40d6aa32b4cc3437434627476e54e93d928ae8",</span><br><span class="line">                "MacAddress": "02:42:c0:a8:00:02",</span><br><span class="line">                "IPv4Address": "192.168.0.2/16",</span><br><span class="line">                "IPv6Address": ""</span><br><span class="line">            &#125;,</span><br><span class="line">            "b94e30b9a734f6ae71e6624971dfca5d8448013376e71000201564510179ab56": &#123;</span><br><span class="line">                "Name": "tomcat-net-02",</span><br><span class="line">                "EndpointID": "c07247228ae8d9e6da8001638ecfadc3e362f368f7f5db42a841e152a153dad2",</span><br><span class="line">                "MacAddress": "02:42:c0:a8:00:03",</span><br><span class="line">                "IPv4Address": "192.168.0.3/16",</span><br><span class="line">                "IPv6Address": ""</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "Options": &#123;&#125;,</span><br><span class="line">        "Labels": &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ping测试</span></span><br><span class="line">kennycai@DESKTOP-M38LAH7:~/dockerfile$ docker exec -it tomcat01 ping tomcat-net-01</span><br><span class="line">PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=1.18 ms</span><br><span class="line">^C</span><br><span class="line">--- tomcat-net-01 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 1.177/1.177/1.177/0.000 ms</span><br></pre></td></tr></table></figure>



<h1 id="SpringBoot微服务打包Docker镜像"><a href="#SpringBoot微服务打包Docker镜像" class="headerlink" title="SpringBoot微服务打包Docker镜像"></a>SpringBoot微服务打包Docker镜像</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 构建一个spring boot项目</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打包应用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编写dockerfiles</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将dockerfiles和.jar用docker build打包</span></span><br><span class="line">docker build -t springboot .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发布</span></span><br><span class="line">docker run -d -P --name springbootTest springboot</span><br></pre></td></tr></table></figure>

<p><img src="/images/tools/docker/docker%E9%83%A8%E7%BD%B2springboot-dockfiles.png" alt="docker部署springboot-dockfiles"></p>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker Compose 来轻松高效的管理容器，定义运行多个容器</p>
<blockquote>
<p>官方文档</p>
</blockquote>
<p>Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see <a href="https://docs.docker.com/compose/#features" target="_blank" rel="noopener">the list of features</a>.</p>
<p>Compose works in all environments: production, staging, development, testing, as well as CI workflows. You can learn more about each case in <a href="https://docs.docker.com/compose/#common-use-cases" target="_blank" rel="noopener">Common Use Cases</a>.</p>
<p>Using Compose is basically a three-step process:</p>
<ol>
<li>Define your app’s environment with a <code>Dockerfile</code> so it can be reproduced anywhere.</li>
<li>Define the services that make up your app in <code>docker-compose.yml</code> so they can be run together in an isolated environment.</li>
<li>Run <code>docker compose up</code> and the <a href="https://docs.docker.com/compose/cli-command/" target="_blank" rel="noopener">Docker compose command</a> starts and runs your entire app. You can alternatively run <code>docker-compose up</code> using the docker-compose binary.</li>
</ol>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>在WSL中使用docker-compose</p>
<ol>
<li><p><a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank" rel="noopener">升级WSL -&gt; WSL2</a></p>
</li>
<li><p>设置docker</p>
<p><img src="/images/tools/docker/WSL%E8%AE%BE%E7%BD%AEdocker-compose.png" alt="WSL设置docker-compose"></p>
</li>
</ol>
<h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><p><a href="https://docs.docker.com/compose/gettingstarted/" target="_blank" rel="noopener">https://docs.docker.com/compose/gettingstarted/</a></p>
<h1 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h1><p>集群方式的部署。</p>
<blockquote>
<p>通过 hyper-v 和 docker-machine 测试 Docker Swarm</p>
</blockquote>
<ol>
<li><p>win10家庭版安装 <code>hyper-v</code>，创建 <code>hyper.cmd</code>并执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pushd "%~dp0"</span><br><span class="line"></span><br><span class="line">dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt</span><br><span class="line"></span><br><span class="line">for /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i"</span><br><span class="line"></span><br><span class="line">del hyper-v.txt</span><br><span class="line"></span><br><span class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL</span><br></pre></td></tr></table></figure>
</li>
<li><p>git bash 安装 <a href="https://github.com/docker/machine/releases/" target="_blank" rel="noopener">docker-machine</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [[ ! -d "$HOME/bin" ]]; then mkdir -p "$HOME/bin"; fi &amp;&amp; \</span><br><span class="line">curl -L https://github.com/docker/machine/releases/download/v0.16.2/docker-machine-Windows-x86_64.exe &gt; "$HOME/bin/docker-machine.exe" &amp;&amp; \</span><br><span class="line">chmod +x "$HOME/bin/docker-machine.exe"</span><br></pre></td></tr></table></figure>
</li>
<li><p>在管理员模式下的 <code>PowerShell</code>通过 <code>docker-machine</code> 启动多个docker服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.\docker-machine.exe create -d hyperv --hyperv-virtual-switch "Docker Switch" docker01</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Swarm集群搭建"><a href="#Swarm集群搭建" class="headerlink" title="Swarm集群搭建"></a>Swarm集群搭建</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker swarm init --advertise-addr 192.168.0.116</span><br><span class="line">Swarm initialized: current node (fb5pef6fmfrwlrkppxinzvbnd) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join --token SWMTKN-1-0lmn5xnc14rmu20jcli9fo90puoru690w1es1bj3ejdvyq1x7d-d1aducb67lur4jry8bkvzxzll 192.168.0.116:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># centos02加入节点，出现问题</span></span></span><br><span class="line">[root@localhost ~]# docker swarm join --token SWMTKN-1-0lmn5xnc14rmu20jcli9fo90puoru690w1es1bj3ejdvyq1x7d-d1aducb67lur4jry8bkvzxzll 192.168.0.116:2377</span><br><span class="line">Error response from daemon: rpc error: code = Unavailable desc = connection error: desc = "transport: Error while dialing dial tcp 192.168.0.116:2377: connect: no route to host"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># centos关闭防火墙</span></span></span><br><span class="line">[root@localhost ~]# systemctl status firewalld.service</span><br><span class="line">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor p&gt;</span><br><span class="line">   Active: active (running) since Wed 2021-04-14 10:42:15 EDT; 9h ago</span><br><span class="line">     Docs: man:firewalld(1)</span><br><span class="line"> Main PID: 827 (firewalld)</span><br><span class="line">    Tasks: 3 (limit: 10970)</span><br><span class="line">   Memory: 31.5M</span><br><span class="line">   CGroup: /system.slice/firewalld.service</span><br><span class="line">           └─827 /usr/libexec/platform-python -s /usr/sbin/firewalld --nofork -&gt;</span><br><span class="line"></span><br><span class="line">4月 14 20:06:35 localhost.localdomain firewalld[827]: WARNING: COMMAND_FAILED: &gt;</span><br><span class="line">4月 14 20:06:35 localhost.localdomain firewalld[827]: WARNING: COMMAND_FAILED: &gt;</span><br><span class="line">4月 14 20:06:35 localhost.localdomain firewalld[827]: WARNING: COMMAND_FAILED: &gt;</span><br><span class="line">4月 14 20:06:35 localhost.localdomain firewalld[827]: WARNING: COMMAND_FAILED: &gt;</span><br><span class="line">4月 14 20:06:35 localhost.localdomain firewalld[827]: WARNING: COMMAND_FAILED: &gt;</span><br><span class="line">4月 14 20:06:36 localhost.localdomain firewalld[827]: WARNING: COMMAND_FAILED: &gt;</span><br><span class="line">4月 14 20:06:47 localhost.localdomain firewalld[827]: WARNING: COMMAND_FAILED: &gt;</span><br><span class="line">4月 14 20:06:47 localhost.localdomain firewalld[827]: WARNING: COMMAND_FAILED: &gt;</span><br><span class="line">4月 14 20:06:48 localhost.localdomain firewalld[827]: WARNING: COMMAND_FAILED: &gt;</span><br><span class="line">4月 14 20:20:29 localhost.localdomain firewalld[827]: WARNING: COMMAND_FAILED: &gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 停止防火墙</span></span></span><br><span class="line">[root@localhost ~]# systemctl stop firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 永久停止</span></span></span><br><span class="line">[root@localhost ~]# systemctl disable firewalld.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># centos02加入节点</span></span></span><br><span class="line">[root@localhost ~]# docker swarm join --token SWMTKN-1-0lmn5xnc14rmu20jcli9fo90puoru690w1es1bj3ejdvyq1x7d-d1aducb67lur4jry8bkvzxzll 192.168.0.116:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">centos01</span></span><br><span class="line">[root@localhost ~]# docker node ls</span><br><span class="line">ID                            HOSTNAME                STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">fb5pef6fmfrwlrkppxinzvbnd *   localhost.localdomain   Ready     Active         Leader           20.10.6</span><br><span class="line">ns60lgtjv513aq9z5qtoye907     localhost.localdomain   Ready     Active                          20.10.6</span><br></pre></td></tr></table></figure>

<h2 id="Raft一致性协议"><a href="#Raft一致性协议" class="headerlink" title="Raft一致性协议"></a>Raft一致性协议</h2><h2 id="Swarm集群弹性创建服务"><a href="#Swarm集群弹性创建服务" class="headerlink" title="Swarm集群弹性创建服务"></a>Swarm集群弹性创建服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker01</span></span><br><span class="line">[root@localhost ~]# docker service create -p 8080:80 --name my-nginx nginx</span><br><span class="line">nmynl6p33cl4jqoano3fpzn3j</span><br><span class="line">overall progress: 1 out of 1 tasks</span><br><span class="line">1/1: running</span><br><span class="line">verify: Service converged</span><br><span class="line"></span><br><span class="line">Usage:  docker service ps [OPTIONS] SERVICE [SERVICE...]</span><br><span class="line"></span><br><span class="line">List the tasks of one or more services</span><br><span class="line">[root@localhost ~]# docker service ls</span><br><span class="line">ID             NAME       MODE         REPLICAS   IMAGE          PORTS</span><br><span class="line">nmynl6p33cl4   my-nginx   replicated   1/1        nginx:latest   *:8080-&gt;80/tcp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动三个服务</span></span><br><span class="line">[root@localhost ~]# docker service update --replicas 3 my-nginx</span><br><span class="line">my-nginx</span><br><span class="line">overall progress: 3 out of 3 tasks</span><br><span class="line">1/3: running</span><br><span class="line">2/3: running</span><br><span class="line">3/3: running</span><br><span class="line">verify: Service converged</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS     NAMES</span><br><span class="line">1804a322cd1d   nginx:latest   "/docker-entrypoint.…"   25 seconds ago   Up 17 seconds   80/tcp    my-nginx.3.jz21l94iade4ftama01afs2h8</span><br><span class="line">ccf3c9dc75db   nginx:latest   "/docker-entrypoint.…"   25 seconds ago   Up 18 seconds   80/tcp    my-nginx.2.p70k9b4bxznsog17wo1lrsui6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> centos02</span></span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS     NAMES</span><br><span class="line">b0483ca45a0f   nginx:latest   "/docker-entrypoint.…"   3 minutes ago   Up 3 minutes   80/tcp    my-nginx.1.pukcavrwqugxs47p91g0ttxee</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> centos01</span></span><br><span class="line">[root@localhost ~]# docker service scale my-nginx=5</span><br><span class="line">my-nginx scaled to 5</span><br><span class="line">overall progress: 5 out of 5 tasks</span><br><span class="line">1/5: running   [==================================================&gt;]</span><br><span class="line">2/5: running   [==================================================&gt;]</span><br><span class="line">3/5: running   [==================================================&gt;]</span><br><span class="line">4/5: running   [==================================================&gt;]</span><br><span class="line">5/5: running   [==================================================&gt;]</span><br><span class="line">verify: Service converged</span><br></pre></td></tr></table></figure>

<p>访问nginx <a href="http://192.168.0.115:8080/" target="_blank" rel="noopener">http://192.168.0.115:8080/</a>  <a href="http://192.168.0.116:8080/" target="_blank" rel="noopener">http://192.168.0.116:8080/</a></p>
<p>![docker-swarm niginx启动成功]((/images/tools/docker/docker-swarm niginx启动成功.png)</p>
<h1 id="Docker-Stack"><a href="#Docker-Stack" class="headerlink" title="Docker Stack"></a>Docker Stack</h1><p>集群版docker-compose</p>
<h1 id="Docker-Secret"><a href="#Docker-Secret" class="headerlink" title="Docker Secret"></a>Docker Secret</h1><p>安全配置，存储密钥</p>
<h1 id="Docker-Config"><a href="#Docker-Config" class="headerlink" title="Docker Config"></a>Docker Config</h1><p>存储配置</p>
<h1 id="常用环境"><a href="#常用环境" class="headerlink" title="常用环境"></a>常用环境</h1><h2 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h2><p><a href="/resources/tools/docker/docker-ES.7z">docker-ES.7z</a></p>
<blockquote>
<p>logstash.conf</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode &#x3D;&gt; &quot;server&quot;</span><br><span class="line">    host &#x3D;&gt; &quot;0.0.0.0&quot;</span><br><span class="line">    port &#x3D;&gt; 4560</span><br><span class="line">    codec &#x3D;&gt; json_lines</span><br><span class="line">    type &#x3D;&gt; &quot;debug&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode &#x3D;&gt; &quot;server&quot;</span><br><span class="line">    host &#x3D;&gt; &quot;0.0.0.0&quot;</span><br><span class="line">    port &#x3D;&gt; 4561</span><br><span class="line">    codec &#x3D;&gt; json_lines</span><br><span class="line">    type &#x3D;&gt; &quot;error&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode &#x3D;&gt; &quot;server&quot;</span><br><span class="line">    host &#x3D;&gt; &quot;0.0.0.0&quot;</span><br><span class="line">    port &#x3D;&gt; 4562</span><br><span class="line">    codec &#x3D;&gt; json_lines</span><br><span class="line">    type &#x3D;&gt; &quot;business&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode &#x3D;&gt; &quot;server&quot;</span><br><span class="line">    host &#x3D;&gt; &quot;0.0.0.0&quot;</span><br><span class="line">    port &#x3D;&gt; 4563</span><br><span class="line">    codec &#x3D;&gt; json_lines</span><br><span class="line">    type &#x3D;&gt; &quot;record&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter&#123;</span><br><span class="line">  if [type] &#x3D;&#x3D; &quot;record&quot; &#123;</span><br><span class="line">    mutate &#123;</span><br><span class="line">      remove_field &#x3D;&gt; &quot;port&quot;</span><br><span class="line">      remove_field &#x3D;&gt; &quot;host&quot;</span><br><span class="line">      remove_field &#x3D;&gt; &quot;@version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    json &#123;</span><br><span class="line">      source &#x3D;&gt; &quot;message&quot;</span><br><span class="line">      remove_field &#x3D;&gt; [&quot;message&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts &#x3D;&gt; &quot;elasticsearch:9200&quot;</span><br><span class="line">    index &#x3D;&gt; &quot;mall-%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>docker-compose.yml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.13.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"cluster.name=elasticsearch"</span> <span class="comment">#设置集群名称为elasticsearch</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"discovery.type=single-node"</span> <span class="comment">#以单一节点模式启动</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span> <span class="comment">#设置使用jvm内存大小</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">D:\workspace\env\docker\elasticsearch\plugins:/usr/share/elasticsearch/plugins</span> <span class="comment">#插件文件挂载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">D:\workspace\env\docker\elasticsearch\data:/usr/share/elasticsearch/data</span> <span class="comment">#数据文件挂载</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9300</span><span class="string">:9300</span></span><br><span class="line">  <span class="attr">logstash:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">logstash:7.13.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">logstash</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">D:\workspace\env\docker\logstash\logstash.conf:/usr/share/logstash/pipeline/logstash.conf</span> <span class="comment">#挂载logstash的配置文件</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch</span> <span class="comment">#kibana在elasticsearch启动之后再启动</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">4560</span><span class="string">:4560</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">4561</span><span class="string">:4561</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">4562</span><span class="string">:4562</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">4563</span><span class="string">:4563</span></span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kibana:7.13.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch</span> <span class="comment">#kibana在elasticsearch启动之后再启动</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"elasticsearch.hosts=http://elasticsearch:9200"</span> <span class="comment">#设置访问elasticsearch的地址</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">5601</span><span class="string">:5601</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">        <span class="attr">external:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">net-env</span></span><br></pre></td></tr></table></figure>

<p>进入docker-compose文件目录 docker compose up -d</p>
<h3 id="logstash-安装不成功"><a href="#logstash-安装不成功" class="headerlink" title="logstash(安装不成功)"></a>logstash(安装不成功)</h3><blockquote>
<p>需要安装<code>json_lines</code>插件，并重新启动。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it logstash /bin/bash</span><br><span class="line">logstash-plugin install logstash-codec-json_lines</span><br><span class="line">docker restart logstash</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA</title>
    <url>/2021/04/16/tools/idea/</url>
    <content><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><h2 id="下载源代码报错提示Connection-refused-to-host-127-0-0-1"><a href="#下载源代码报错提示Connection-refused-to-host-127-0-0-1" class="headerlink" title="下载源代码报错提示Connection refused to host: 127.0.0.1"></a>下载源代码报错提示Connection refused to host: 127.0.0.1</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java.lang.RuntimeException: Cannot reconnect.</span><br><span class="line">    at org.jetbrains.idea.maven.server.RemoteObjectWrapper.perform(RemoteObjectWrapper.java:82)</span><br><span class="line">    at org.jetbrains.idea.maven.server.MavenEmbedderWrapper.customizeForResolve(MavenEmbedderWrapper.java:52)</span><br><span class="line">    at org.jetbrains.idea.maven.project.MavenProjectResolver.downloadSourcesAndJavadocs(MavenProjectResolver.java:253)</span><br><span class="line">    at org.jetbrains.idea.maven.project.MavenProjectsProcessorArtifactsDownloadingTask.perform(MavenProjectsProcessorArtifactsDownloadingTask.java:40)</span><br><span class="line">    at org.jetbrains.idea.maven.project.MavenProjectsProcessor.doProcessPendingTasks(MavenProjectsProcessor.java:145)</span><br><span class="line">    at org.jetbrains.idea.maven.project.MavenProjectsProcessor.access$000(MavenProjectsProcessor.java:36)</span><br><span class="line">    at org.jetbrains.idea.maven.project.MavenProjectsProcessor$1.run(MavenProjectsProcessor.java:114)</span><br><span class="line">    at org.jetbrains.idea.maven.utils.MavenUtil.lambda$runInBackground$5(MavenUtil.java:500)</span><br><span class="line">    at com.intellij.util.RunnableCallable.call(RunnableCallable.java:20)</span><br><span class="line">    at com.intellij.util.RunnableCallable.call(RunnableCallable.java:11)</span><br><span class="line">    at com.intellij.openapi.application.impl.ApplicationImpl$1.call(ApplicationImpl.java:268)</span><br><span class="line">    at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)</span><br><span class="line">    at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)</span><br><span class="line">    at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)</span><br><span class="line">    at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:668)</span><br><span class="line">    at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:665)</span><br><span class="line">    at java.base/java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">    at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1.run(Executors.java:665)</span><br><span class="line">    at java.base/java.lang.Thread.run(Thread.java:834)</span><br><span class="line">Caused by: java.rmi.ConnectException: Connection refused to host: 127.0.0.1; nested exception is: </span><br><span class="line">    java.net.ConnectException: Connection refused: connect</span><br><span class="line">    at java.rmi/sun.rmi.transport.tcp.TCPEndpoint.newSocket(TCPEndpoint.java:623)</span><br><span class="line">    at java.rmi/sun.rmi.transport.tcp.TCPChannel.createConnection(TCPChannel.java:209)</span><br><span class="line">    at java.rmi/sun.rmi.transport.tcp.TCPChannel.newConnection(TCPChannel.java:196)</span><br><span class="line">    at java.rmi/sun.rmi.server.UnicastRef.invoke(UnicastRef.java:132)</span><br><span class="line">    at java.rmi/java.rmi.server.RemoteObjectInvocationHandler.invokeRemoteMethod(RemoteObjectInvocationHandler.java:217)</span><br><span class="line">    at java.rmi/java.rmi.server.RemoteObjectInvocationHandler.invoke(RemoteObjectInvocationHandler.java:162)</span><br><span class="line">    at com.sun.proxy.$Proxy148.createEmbedder(Unknown Source)</span><br><span class="line">    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">    at java.base/java.lang.reflect.Method.invoke(Method.java:566)</span><br><span class="line">    at com.intellij.execution.rmi.RemoteUtil.invokeRemote(RemoteUtil.java:155)</span><br><span class="line">    at com.intellij.execution.rmi.RemoteUtil.access$400(RemoteUtil.java:25)</span><br><span class="line">    at com.intellij.execution.rmi.RemoteUtil$1.lambda$invoke$0(RemoteUtil.java:139)</span><br><span class="line">    at com.intellij.openapi.util.ClassLoaderUtil.computeWithClassLoader(ClassLoaderUtil.java:31)</span><br><span class="line">    at com.intellij.execution.rmi.RemoteUtil.executeWithClassLoader(RemoteUtil.java:207)</span><br><span class="line">    at com.intellij.execution.rmi.RemoteUtil$1.invoke(RemoteUtil.java:139)</span><br><span class="line">    at com.sun.proxy.$Proxy148.createEmbedder(Unknown Source)</span><br><span class="line">    at org.jetbrains.idea.maven.server.MavenServerConnector.createEmbedder(MavenServerConnector.java:187)</span><br><span class="line">    at org.jetbrains.idea.maven.server.MavenServerManager$2.create(MavenServerManager.java:397)</span><br><span class="line">    at org.jetbrains.idea.maven.server.MavenServerManager$2.create(MavenServerManager.java:385)</span><br><span class="line">    at org.jetbrains.idea.maven.server.RemoteObjectWrapper.getOrCreateWrappee(RemoteObjectWrapper.java:41)</span><br><span class="line">    at org.jetbrains.idea.maven.server.MavenEmbedderWrapper.doCustomize(MavenEmbedderWrapper.java:93)</span><br><span class="line">    at org.jetbrains.idea.maven.server.MavenEmbedderWrapper.lambda$customizeForResolve$0(MavenEmbedderWrapper.java:53)</span><br><span class="line">    at org.jetbrains.idea.maven.server.RemoteObjectWrapper.perform(RemoteObjectWrapper.java:76)</span><br><span class="line">    ... 18 more</span><br><span class="line">Caused by: java.net.ConnectException: Connection refused: connect</span><br><span class="line">    at java.base/java.net.PlainSocketImpl.connect0(Native Method)</span><br><span class="line">    at java.base/java.net.PlainSocketImpl.socketConnect(PlainSocketImpl.java:101)</span><br><span class="line">    at java.base/java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:399)</span><br><span class="line">    at java.base/java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:242)</span><br><span class="line">    at java.base/java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:224)</span><br><span class="line">    at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:403)</span><br><span class="line">    at java.base/java.net.Socket.connect(Socket.java:609)</span><br><span class="line">    at java.base/java.net.Socket.connect(Socket.java:558)</span><br><span class="line">    at java.base/java.net.Socket.&lt;init&gt;(Socket.java:454)</span><br><span class="line">    at java.base/java.net.Socket.&lt;init&gt;(Socket.java:231)</span><br><span class="line">    at com.intellij.execution.rmi.RemoteServer$1.createSocket(RemoteServer.java:121)</span><br><span class="line">    at java.rmi/sun.rmi.transport.tcp.TCPEndpoint.newSocket(TCPEndpoint.java:617)</span><br><span class="line">    ... 42 more</span><br></pre></td></tr></table></figure>

<p>解决：设置正确jdk就行。</p>
<p>![Maven-Connection refused.png](/images/tools/idea/Maven-Connection refused.png)</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2021/06/10/database/redis/</url>
    <content><![CDATA[<h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><blockquote>
<p>简介</p>
</blockquote>
<p>NoSQL，泛指非关系型的数据库。随着互联网<a href="https://baike.baidu.com/item/web2.0/97695" target="_blank" rel="noopener">web2.0</a>网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的<a href="https://baike.baidu.com/item/SNS/10242" target="_blank" rel="noopener">SNS</a>类型的web2.0纯<a href="https://baike.baidu.com/item/动态网" target="_blank" rel="noopener">动态网</a>站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。</p>
<blockquote>
<p>特点</p>
</blockquote>
<ol>
<li>方便扩展</li>
<li>大数据量高性能</li>
<li>数据类型是多样型的！（不需要事先设计数据库！随取随用！如果是数据量十分大的表，很多人就无法设计了！）</li>
</ol>
<p>redis默认16个数据库，默认使用0号数据库用select 切换</p>
<p>单线程 + 多路io复用</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>redis默认有16个数据库，默认使用的是第0个，可以使用 select 进行切换数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; DBSIZE</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<h2 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h2><p><code>shutdown</code></p>
<h2 id="清除当前数据库"><a href="#清除当前数据库" class="headerlink" title="清除当前数据库"></a>清除当前数据库</h2><p><code>flushdb</code></p>
<h2 id="清除全部数据库的内容"><a href="#清除全部数据库的内容" class="headerlink" title="清除全部数据库的内容"></a>清除全部数据库的内容</h2><p><code>FLUSHALL</code></p>
<h2 id="查看所有key"><a href="#查看所有key" class="headerlink" title="查看所有key"></a>查看所有key</h2><p><code>KEYS *</code></p>
<h2 id="Redis速度快的原因"><a href="#Redis速度快的原因" class="headerlink" title="Redis速度快的原因"></a>Redis速度快的原因</h2><blockquote>
<p>Redis是单线程的</p>
</blockquote>
<p>核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个CPU上的，在内存情况下，这 就是最佳的方案！</p>
<h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> user 1           <span class="comment"># 设置</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get user             <span class="comment"># 获取</span></span><br><span class="line"><span class="string">"1"</span></span><br><span class="line">127.0.0.1:6379&gt; DEL user 1           <span class="comment"># 移除当前的key</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SETEX user 10 val    <span class="comment"># 设置超时时间</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE user 10       <span class="comment"># 设置超时时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl user	         <span class="comment"># 查看当前key的剩余时间</span></span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> user	         <span class="comment"># 查看当前key的类型</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; EXISTS user          <span class="comment"># 判断某一个key是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; APPEND user 1        <span class="comment"># 追加字符串，如果当前key不存在，就相当于setkey</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; STRLEN user</span><br><span class="line">(<span class="built_in">integer</span>) 2					         <span class="comment"># 获取字符串的长</span></span><br><span class="line">127.0.0.1:6379&gt; INCR num	         <span class="comment"># 自增1</span></span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; DECR num	         <span class="comment"># 自减1</span></span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">127.0.0.1:6379&gt; INCRBY num 10        <span class="comment"># 设置步长，指定增量</span></span><br><span class="line">(<span class="built_in">integer</span>) 22</span><br><span class="line">127.0.0.1:6379&gt; GETRANGE user 0 3    <span class="comment"># 截取字符串 [0,3]</span></span><br><span class="line"><span class="string">"kenn"</span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE user 0 -1   <span class="comment"># 获取全部的字符串 和 get key是一样的</span></span><br><span class="line"><span class="string">"kennycai"</span></span><br><span class="line">127.0.0.1:6379&gt; SETRANGE user 5 1    <span class="comment"># 替换指定位置开始的字符串</span></span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; GET user</span><br><span class="line"><span class="string">"kenny1ai"</span></span><br><span class="line">127.0.0.1:6379&gt; SETNX user 1	     <span class="comment"># 如果mykey存在，创建失败！</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; MSET user1 1 user2 2 <span class="comment"># 同时设置多个值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MGET user1 user2	 <span class="comment">#同时获取多个值</span></span><br><span class="line">1) <span class="string">"1"</span></span><br><span class="line">2) <span class="string">"2"</span></span><br><span class="line"><span class="comment"># 先获取再设置</span></span><br><span class="line">127.0.0.1:6379&gt; getset db 1			 </span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">"1"</span></span><br><span class="line">127.0.0.1:6379&gt; getset db 2</span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><blockquote>
<p>list 实际上是一个链表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPUSH list one			<span class="comment"># 将一个值或者多个值，插入到列表头部 （左）</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1		<span class="comment"># 从左到右输出区间内的值</span></span><br><span class="line">1) <span class="string">"two"</span></span><br><span class="line">2) <span class="string">"one"</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 1</span><br><span class="line">1) <span class="string">"two"</span></span><br><span class="line">2) <span class="string">"one"</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 0</span><br><span class="line">1) <span class="string">"two"</span></span><br><span class="line">127.0.0.1:6379&gt; RPUSH list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1	    <span class="comment"># 将一个值或者多个值，插入到列表尾部 （右）</span></span><br><span class="line">1) <span class="string">"two"</span></span><br><span class="line">2) <span class="string">"one"</span></span><br><span class="line">3) <span class="string">"three"</span></span><br><span class="line">127.0.0.1:6379&gt; LLEN list				<span class="comment"># 获取长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; LINDEX list 1			<span class="comment"># 通过下标获得 list 中的某一个值</span></span><br><span class="line"><span class="string">"one"</span></span><br><span class="line">127.0.0.1:6379&gt; LPOP list				<span class="comment"># 从头部弹出一个值</span></span><br><span class="line"><span class="string">"two"</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1					</span><br><span class="line">1) <span class="string">"one"</span></span><br><span class="line">2) <span class="string">"three"</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP list				<span class="comment"># 从尾部弹出一个值     </span></span><br><span class="line"><span class="string">"three"</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">"one"</span></span><br><span class="line">127.0.0.1:6379&gt; LREM list 1 one			<span class="comment"># 移除list集合中指定个数的value，精确匹配</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">"three"</span></span><br><span class="line">2) <span class="string">"two"</span></span><br><span class="line">3) <span class="string">"one"</span></span><br><span class="line">127.0.0.1:6379&gt; LTRIM list 0 1			<span class="comment"># 通过下标截取指定的长度，这个list已经被改变了，截断了只剩下截取的元素！</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">"three"</span></span><br><span class="line">2) <span class="string">"two"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list2 four</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH list2 list	<span class="comment"># 移除列表的最后一个元素，将他移动到新的列表中</span></span><br><span class="line"><span class="string">"four"</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">"four"</span></span><br><span class="line">2) <span class="string">"three"</span></span><br><span class="line">3) <span class="string">"two"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; RPUSH list five			<span class="comment"># 在队尾插入元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">"four"</span></span><br><span class="line">2) <span class="string">"three"</span></span><br><span class="line">3) <span class="string">"two"</span></span><br><span class="line">4) <span class="string">"five"</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP list 1				<span class="comment"># 将队尾元素弹出</span></span><br><span class="line">1) <span class="string">"five"</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">"four"</span></span><br><span class="line">2) <span class="string">"three"</span></span><br><span class="line">3) <span class="string">"two"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LSET list 0 fours		<span class="comment"># 如果存在，更新当前下标的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LSET list 3 fours		<span class="comment"># 如果不存在，则会报错！</span></span><br><span class="line">(error) ERR index out of range</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将某个具体的value插入到列把你中某个元素的前面或者后面！</span></span><br><span class="line">127.0.0.1:6379&gt; LINSERT list before three beforethree</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">"fours"</span></span><br><span class="line">2) <span class="string">"beforefour"</span></span><br><span class="line">3) <span class="string">"beforethree"</span></span><br><span class="line">4) <span class="string">"three"</span></span><br><span class="line">5) <span class="string">"two"</span></span><br><span class="line">127.0.0.1:6379&gt; LINSERT list after three afterthree</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">"fours"</span></span><br><span class="line">2) <span class="string">"beforefour"</span></span><br><span class="line">3) <span class="string">"beforethree"</span></span><br><span class="line">4) <span class="string">"three"</span></span><br><span class="line">5) <span class="string">"afterthree"</span></span><br><span class="line">6) <span class="string">"two"</span></span><br></pre></td></tr></table></figure>

<h2 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h2><blockquote>
<p>不能重复的列表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">"hello"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># set集合中添加元素</span></span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">"world"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 查看指定set的所有值</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">"world"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line"><span class="comment"># 判断某一个值是不是在set集合中！</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset hello1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">########################################### ##############################</span></span><br><span class="line">127.0.0.1:6379&gt; scard myset <span class="comment"># 获取set集合中 内容元素个数！</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; srem myset hello <span class="comment"># 移除set集合中的指定元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">"world"</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="built_in">set</span> 无序不重复集合。抽随机！</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset <span class="comment"># 随机抽选出一个元素</span></span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">"world"</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 2 <span class="comment"># 随机抽选出指定个数的元素</span></span><br><span class="line">1) <span class="string">"world"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">随机删除key！</span><br><span class="line">127.0.0.1:6379&gt; SPOP myset 1	<span class="comment"># 随机删除一些set集合中的元素！</span></span><br><span class="line">1) <span class="string">"world"</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">将一个指定的值，移动到另外一个<span class="built_in">set</span>集合！</span><br><span class="line">127.0.0.1:6379&gt; SMOVE myset myset22 hello  <span class="comment"># 将一个指定的值，移动到另外一个set集合！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset22</span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">数字集合类：</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">"world"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset22</span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">127.0.0.1:6379&gt; SDIFF myset myset22		<span class="comment"># 差集</span></span><br><span class="line">1) <span class="string">"world"</span></span><br><span class="line">127.0.0.1:6379&gt; SINTER myset myset22	<span class="comment"># 交集</span></span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">127.0.0.1:6379&gt; SUNION myset myset22	<span class="comment"># 并集</span></span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">2) <span class="string">"world"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用：共同关注，共同爱好，二度好友，推荐好友</p>
</blockquote>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><blockquote>
<p>Map</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash field1 hello <span class="comment"># set一个具体 key-vlaue</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash field1 <span class="comment"># 获取一个字段值</span></span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line">127.0.0.1:6379&gt; HMSET myhash field1 hello feild2 world</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># set多个 key-vlaue</span></span><br><span class="line">127.0.0.1:6379&gt; hmget myhash field1 field2</span><br><span class="line"><span class="comment"># 获取多个字段值</span></span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">2) <span class="string">"world"</span></span><br><span class="line">127.0.0.1:6379&gt; HGETALL myhash	<span class="comment"># 获取全部的数据</span></span><br><span class="line">1) <span class="string">"field1"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line">3) <span class="string">"feild2"</span></span><br><span class="line">4) <span class="string">"world"</span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash field1 <span class="comment"># 删除hash指定key字段！对应的value值也就消失了！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">"field2"</span></span><br><span class="line">2) <span class="string">"world"</span></span><br><span class="line"><span class="comment">######################### ###############################################</span></span><br><span class="line">127.0.0.1:6379&gt; HGETALL myhash</span><br><span class="line">1) <span class="string">"field2"</span></span><br><span class="line">2) <span class="string">"world"</span></span><br><span class="line">3) <span class="string">"field1"</span></span><br><span class="line">4) <span class="string">"hello"</span></span><br><span class="line">127.0.0.1:6379&gt; hlen myhash <span class="comment"># 获取hash表的字段数量！</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash field1 <span class="comment"># 判断hash中指定字段是否存在！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash field3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment"># 只获得所有field</span></span><br><span class="line"><span class="comment"># 只获得所有value</span></span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash <span class="comment"># 只获得所有field</span></span><br><span class="line">1) <span class="string">"field2"</span></span><br><span class="line">2) <span class="string">"field1"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hvals myhash <span class="comment"># 只获得所有value</span></span><br><span class="line">1) <span class="string">"world"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash field3 5</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash field3 1 	<span class="comment">#指定增量！</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash field3 -1 	<span class="comment">#指定增量！</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field4 hello <span class="comment"># 如果不存在则可以设置</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field4 world <span class="comment"># 如果存在则不能设置</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<h2 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myset 1 one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 添加 个值</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 two 3 three</span><br><span class="line"><span class="comment"># 添加多个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myset 0 -1</span><br><span class="line">1) <span class="string">"one"</span></span><br><span class="line">2) <span class="string">"two"</span></span><br><span class="line">3) <span class="string">"three"</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 2500 xiaohong <span class="comment"># 添加三个用户</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 5000 zhangsan</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 500 wangwu</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># ZRANGEBYSCORE key min max</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf <span class="comment"># 显示全部的用户 从小到大！</span></span><br><span class="line">1) <span class="string">"wangwu"</span></span><br><span class="line">2) <span class="string">"xiaohong"</span></span><br><span class="line">3) <span class="string">"zhangsan"</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 <span class="comment"># 从大到进行排序！</span></span><br><span class="line">1) <span class="string">"zhangsan"</span></span><br><span class="line">2) <span class="string">"wangwu"</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores <span class="comment"># 显示全部的用户并且附带成绩</span></span><br><span class="line">1) <span class="string">"wangwu"</span></span><br><span class="line">2) <span class="string">"500"</span></span><br><span class="line">3) <span class="string">"xiaohong"</span></span><br><span class="line">4) <span class="string">"2500"</span></span><br><span class="line">5) <span class="string">"zhangsan"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores <span class="comment"># 显示工资小于2500员工的升序排序！</span></span><br><span class="line">1) <span class="string">"wangwu"</span></span><br><span class="line">2) <span class="string">"500"</span></span><br><span class="line">3) <span class="string">"xiaohong"</span></span><br><span class="line">4) <span class="string">"2500"</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment"># 移除rem中的元素</span></span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">"wangwu"</span></span><br><span class="line">2) <span class="string">"xiaohong"</span></span><br><span class="line">3) <span class="string">"zhangsan"</span></span><br><span class="line">127.0.0.1:6379&gt; zrem salary xiaohong</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 移除有序集合中的指定元素</span></span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">"wangwu"</span></span><br><span class="line">2) <span class="string">"zhangsan"</span></span><br><span class="line">127.0.0.1:6379&gt; zcard salary <span class="comment"># 获取有序集合中的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 world 3 kuangshen</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 3 <span class="comment"># 获取指定区间的成员数量！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>

<h1 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h1><h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h2><blockquote>
<p>基数（不重复的元素）</p>
</blockquote>
<blockquote>
<p>示例：<strong>网页的</strong> <strong>UV</strong> <strong>（一个人访问一个网站多次，但是还是算作一个人！）</strong></p>
<p>传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 !这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFadd mykey a b c d e f g h i j</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 创建第一组元素 mykey</span></span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey <span class="comment"># 统计 mykey 元素的基数数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; PFadd mykey2 i j z x c v b n m</span><br><span class="line"><span class="comment"># 创建第二组元素 mykey2</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey2</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2 <span class="comment"># 合并两组 mykey mykey2 =&gt; mykey3 并集</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey3 <span class="comment"># 看并集的数量！</span></span><br><span class="line">(<span class="built_in">integer</span>) 15</span><br></pre></td></tr></table></figure>

<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><blockquote>
<p>位存储</p>
<p>统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用Bitmaps！</p>
<p>Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETBIT sign 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT sign 1 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT sign 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT sign 4 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT sign 5 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT sign 6 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># 查看某一天是否有打卡！</span></span><br><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 6</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># 统计操作，统计 打卡的天数！</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount sign <span class="comment"># 统计这周的打卡记录，就可以看到是否有全勤！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<h2 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h2><blockquote>
<p>这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人！</p>
<p>官方文档：<a href="https://www.redis.net.cn/order/3685.html" target="_blank" rel="noopener">https://www.redis.net.cn/order/3685.html</a></p>
</blockquote>
<blockquote>
<p>getadd</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># getadd 添加地理位置</span></span><br><span class="line"><span class="comment"># 规则：两级无法直接添加，我们一般会下载城市数据，直接通 java程序一次性导入！</span></span><br><span class="line"><span class="comment"># 有效的经度从-180度到180度。</span></span><br><span class="line"><span class="comment"># 有效的纬度从-85.05112878度到85.05112878度。</span></span><br><span class="line"><span class="comment"># 当坐标位置超出上述指定范围时，该命令将会返回一个错误。</span></span><br><span class="line"><span class="comment"># 127.0.0.1:6379&gt; geoadd china:city 39.90 116.40 beijin</span></span><br><span class="line">(error) ERR invalid longitude,latitude pair 39.900000,116.400000</span><br><span class="line"><span class="comment"># 参数 key 值（）</span></span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ge dd china:city 106.50 29.53 chongqi 114.05 22.52 shengzhen</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GEOPOS </p>
</blockquote>
<p>获得当前定位：一定是一个坐标值！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEOPOS china:city beijing <span class="comment"># 获取指定的城市的经度和纬度！</span></span><br><span class="line">1) 1) <span class="string">"116.39999896287918091"</span></span><br><span class="line">2) <span class="string">"39.90000009167092543"</span></span><br><span class="line">127.0.0.1:6379&gt; GEOPOS china:city beijing chongqi</span><br><span class="line">1) 1) <span class="string">"116.39999896287918091"</span></span><br><span class="line">2) <span class="string">"39.90000009167092543"</span></span><br><span class="line">2) 1) <span class="string">"106.49999767541885376"</span></span><br><span class="line">2) <span class="string">"29.52999957900659211"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>GEODIST</p>
</blockquote>
<p>两人之间的距离！</p>
<p>单位：</p>
<ul>
<li><p><strong>m</strong> 表示单位为米。</p>
</li>
<li><p><strong>km</strong> 表示单位为千米。</p>
</li>
<li><p><strong>mi</strong> 表示单位为英里。</p>
</li>
<li><p><strong>ft</strong> 表示单位为英尺。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km <span class="comment"># 查看上海到北京的直线距离</span></span><br><span class="line"><span class="string">"1067.3788"</span></span><br><span class="line">127.0.0.1:6379&gt; GEODIST china:city beijing chongqi km <span class="comment"># 查看重庆到北京的直线距离</span></span><br><span class="line"><span class="string">"1464.0708"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>georadius 以给定的经纬度为中心， 找出某一半径内的元素</p>
</blockquote>
<p>我附近的人？ （获得所有附近的人的地址，定位！）通过半径来查询！</p>
<p>获得指定数量的人，200</p>
<p>所有数据应该都录入：china:city ，才会让结果更加请求！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1000 km <span class="comment"># 以110，30 这个经纬度为中心，寻找方圆1000km内的城市</span></span><br><span class="line">1) <span class="string">"chongqi"</span></span><br><span class="line">2) <span class="string">"xian"</span></span><br><span class="line">3) <span class="string">"shengzhen"</span></span><br><span class="line">4) <span class="string">"hangzhou"</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km</span><br><span class="line">1) <span class="string">"chongqi"</span></span><br><span class="line">2) <span class="string">"xian"</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist <span class="comment"># 显示到中间距离的位置</span></span><br><span class="line">1) 1) <span class="string">"chongqi"</span></span><br><span class="line">2) <span class="string">"341.9374"</span></span><br><span class="line">2) 1) <span class="string">"xian"</span></span><br><span class="line">2) <span class="string">"483.8340"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GE ADIUS china:city 110 30 500 km withcoord <span class="comment"># 显示他人的定位信息</span></span><br><span class="line">1) 1) <span class="string">"chongqi"</span></span><br><span class="line">   2) 1) <span class="string">"106.49999767541885376"</span></span><br><span class="line">      2) <span class="string">"29.52999957900659211"</span></span><br><span class="line">2) 1) <span class="string">"xian"</span></span><br><span class="line">   2) 1) <span class="string">"108.96000176668167114"</span></span><br><span class="line">      2) <span class="string">"34.25999964418929977"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 1  <span class="comment"># 筛选出指定的结果！</span></span><br><span class="line">1) 1) <span class="string">"chongqi"</span></span><br><span class="line">   2) <span class="string">"341.9374"</span></span><br><span class="line">   3) 1) <span class="string">"106.49999767541885376"</span></span><br><span class="line">      2) <span class="string">"29.52999957900659211"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 2</span><br><span class="line">1) 1) <span class="string">"chongqi"</span></span><br><span class="line">   2) <span class="string">"341.9374"</span></span><br><span class="line">   3) 1) <span class="string">"106.49999767541885376"</span></span><br><span class="line">      2) <span class="string">"29.52999957900659211"</span></span><br><span class="line">2) 1) <span class="string">"xian"</span></span><br><span class="line">   2) <span class="string">"483.8340"</span></span><br><span class="line">   3) 1) <span class="string">"108.96000176668167114"</span></span><br><span class="line">      2) <span class="string">"34.25999964418929977"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>GEORADIUSBYMEMBER</p>
</blockquote>
<p># 找出位于指定元素周围的其他元素！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km</span><br><span class="line">1) <span class="string">"beijing"</span></span><br><span class="line">2) <span class="string">"xian"</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city shanghai 400 km</span><br><span class="line">1) <span class="string">"hangzhou"</span></span><br><span class="line">2) <span class="string">"shanghai"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>GEOHASH 命令 - 返回一个或多个位置元素的 Geohash 表示</p>
</blockquote>
<p>该命令将返回11个字符的Geohash字符串!</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！</span></span><br><span class="line">127.0.0.1:6379&gt; geohash china:city beijing chongqi</span><br><span class="line">1) <span class="string">"wx4fbxxfke0"</span></span><br><span class="line">2) <span class="string">"wm5xzrybty0"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGE china:city 0 -1 <span class="comment"># 查看地图中全部的元素</span></span><br><span class="line">1) <span class="string">"chongqi"</span></span><br><span class="line">2) <span class="string">"xian"</span></span><br><span class="line">3) <span class="string">"shengzhen"</span></span><br><span class="line">4) <span class="string">"hangzhou"</span></span><br><span class="line">5) <span class="string">"shanghai"</span></span><br><span class="line">6) <span class="string">"beijing"</span></span><br><span class="line">127.0.0.1:6379&gt; zrem china:city beijing <span class="comment"># 移除指定元素！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE ch a:city 0 -1</span><br><span class="line">1) <span class="string">"chongqi"</span></span><br><span class="line">2) <span class="string">"xian"</span></span><br><span class="line">3) <span class="string">"shengzhen"</span></span><br><span class="line">4) <span class="string">"hangzhou"</span></span><br><span class="line">5) <span class="string">"shanghai"</span></span><br></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis事务没有没有隔离级别的概念！</p>
<p>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行</p>
<p>Redis单条命令式保存原子性的，但是事务不保证原子性</p>
<blockquote>
<p> 步骤</p>
</blockquote>
<ul>
<li>开启事务（multi）</li>
<li>命令入队</li>
<li>执行事务（exec）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line"><span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 命令入队</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 执行事务</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">"v2"</span></span><br><span class="line">4) OK</span><br></pre></td></tr></table></figure>

<blockquote>
<p>放弃事务</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 取消事务</span></span><br><span class="line">127.0.0.1:6379&gt; get k4 <span class="comment"># 事务队列中命令都不会 执行！</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译型异常（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; se k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; getset k3</span><br><span class="line"><span class="comment"># 错误的命令</span></span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'getset'</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k5 v5</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 执行事务报错！</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; get k5 <span class="comment"># 所有的命令都不会被执行！</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行时异常（1/0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 <span class="string">"v1"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr k1 <span class="comment"># 会执行的时候失败！</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) (error) ERR value is not an <span class="built_in">integer</span> or out of range <span class="comment"># 虽然第一条命令报错了，但是依旧正常执行成功了！</span></span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">"v3"</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">"v2"</span></span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line"><span class="string">"v3"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>watch </p>
<p>乐观锁，修改失败，所有事务不会执行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line"><span class="comment"># 监视 money 对象</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！</span></span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line"><span class="comment"># 监视 money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY out 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失</span></span><br><span class="line">败！</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>unwatch 解除监视</p>
</blockquote>
<h1 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h1><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><ol>
<li>导入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入jedis的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 	https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--fastjson--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>开启事务</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTX</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">		jedis.flushDB();</span><br><span class="line">		JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">		jsonObject.put(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line">		jsonObject.put(<span class="string">"name"</span>,<span class="string">"kuangshen"</span>);</span><br><span class="line">		<span class="comment">// 开启事务</span></span><br><span class="line">		Transaction multi = jedis.multi();</span><br><span class="line">		String result = jsonObject.toJSONString();</span><br><span class="line">		<span class="comment">// jedis.watch(result)</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			multi.set(<span class="string">"user1"</span>,result);</span><br><span class="line">			multi.set(<span class="string">"user2"</span>,result);</span><br><span class="line">			<span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span> ; <span class="comment">// 代码抛出异常事务，执行失败！</span></span><br><span class="line">			multi.exec(); <span class="comment">// 执行事务！</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			multi.discard(); <span class="comment">// 放弃事务</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(jedis.get(<span class="string">"user1"</span>));</span><br><span class="line">			System.out.println(jedis.get(<span class="string">"user2"</span>));</span><br><span class="line">			jedis.close(); <span class="comment">// 关闭连接</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h2><blockquote>
<p>默认使用lettuce</p>
</blockquote>
<ol>
<li>导入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置连接</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.kuang.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.kuang.utils.RedisUtil;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis02SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"redisTemplate"</span>)</span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        redisUtil.set(<span class="string">"name"</span>,<span class="string">"kuangshen"</span>);</span><br><span class="line">        System.out.println(redisUtil.get(<span class="string">"name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在企业开发中，我们80%的情况下，都不会使用这个原生的方式去编写代码！</span></span><br><span class="line">        <span class="comment">// RedisUtils;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// redisTemplate  操作不同的数据类型，api和我们的指令是一样的</span></span><br><span class="line">        <span class="comment">// opsForValue  操作字符串 类似String</span></span><br><span class="line">        <span class="comment">// opsForList   操作List 类似List</span></span><br><span class="line">        <span class="comment">// opsForSet</span></span><br><span class="line">        <span class="comment">// opsForHash</span></span><br><span class="line">        <span class="comment">// opsForZSet</span></span><br><span class="line">        <span class="comment">// opsForGeo</span></span><br><span class="line">        <span class="comment">// opsForHyperLogLog</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 除了进本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的CRUD</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取redis的连接对象</span></span><br><span class="line">        <span class="comment">//        RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span></span><br><span class="line">        <span class="comment">//        connection.flushDb();</span></span><br><span class="line">        <span class="comment">//        connection.flushAll();</span></span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"mykey"</span>,<span class="string">"val"</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">"mykey"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="comment">// 真实的开发一般都使用json来传递对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"测试"</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//        String jsonUser = new ObjectMapper().writeValueAsString(user);</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"user"</span>,user);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">"user"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>编写 RedisTemplate</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是我给大家写好的一个固定模板，大家在企业中，拿去就可以直接使用！</span></span><br><span class="line">    <span class="comment">// 自己定义了一个 RedisTemplate</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Json序列化配置</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>RedisUtil </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =============================common============================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(String... key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="keyword">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================String=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="keyword">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"递增因子必须大于0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"递减因子必须大于0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================================Map=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hget</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title">hmget</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hdel</span><span class="params">(String key, Object... item)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hHasKey</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hincr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要减少记(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hdecr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================set=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">sGet</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sHasKey</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSet</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSetAndTime</span><span class="params">(String key, <span class="keyword">long</span> time, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sGetSetSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setRemove</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===============================list=================================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">lGet</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lGetListSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">lGetIndex</span><span class="params">(String key, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lUpdateIndex</span><span class="params">(String key, <span class="keyword">long</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lRemove</span><span class="params">(String key, <span class="keyword">long</span> count, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long remove = redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><blockquote>
<p><a href="https://www.cnblogs.com/yangming1996/p/12152090.html" target="_blank" rel="noopener">传送查看</a></p>
</blockquote>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快</p>
<p>照文件直接读到内存里。</p>
<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后 次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！</p>
<blockquote>
<p>触发机制</p>
</blockquote>
<ol>
<li><p>配置文件中save的规则满足的情况下，会自动触发rdb规则</p>
</li>
<li><p>执行 ﬂushall 命令，也会触发我们的rdb规则！</p>
</li>
<li><p>退出redis，也会产生 rdb 文件！</p>
</li>
</ol>
<p>备份就自动生成一个 dump.rdb</p>
<blockquote>
<p>如果恢复rdb文件</p>
</blockquote>
<p>只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中的数据！</p>
<blockquote>
<p>查看需要存在的位置</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir</span><br><span class="line">1) <span class="string">"dir"</span></span><br><span class="line">2) <span class="string">"/usr/local/bin"</span> <span class="comment"># 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据</span></span><br></pre></td></tr></table></figure>



<p><img src="/images/database/redis/%E6%8C%81%E4%B9%85%E5%8C%96-RDB.png" alt="持久化-RDB.png"></p>
<ul>
<li><p>优势</p>
<ul>
<li><p>适合大规模的数据恢复</p>
</li>
<li><p>对数据完整性和一致性要求不高更适合使用</p>
</li>
<li><p>节省磁盘空间</p>
</li>
<li><p>恢复速度快</p>
</li>
</ul>
</li>
<li><p>劣势</p>
<ul>
<li><p>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</p>
</li>
<li><p>虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。</p>
</li>
<li><p>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</p>
</li>
</ul>
</li>
</ul>
<h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><blockquote>
<p>将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部在执行一遍！</p>
<p>默认是不开启的，我们需要手动进行配置！我们只需要将 appendonly 改为yes就开启了 aof！</p>
<p><a href="https://www.cnblogs.com/yangming1996/p/12259931.html" target="_blank" rel="noopener">传送查看</a></p>
</blockquote>
<p><img src="/images/database/redis/%E6%8C%81%E4%B9%85%E5%8C%96-AOF.png" alt="持久化-AOF.png"></p>
<p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<ul>
<li><p>优势</p>
<ul>
<li><p>备份机制更稳健，丢失数据概率更低。</p>
</li>
<li><p>可读的日志文本，通过操作AOF稳健，可以处理误操作。</p>
</li>
</ul>
</li>
<li><p>劣势</p>
<ul>
<li><p>比起RDB占用更多的磁盘空间。</p>
</li>
<li><p>恢复备份速度要慢。</p>
</li>
<li><p>每次读写都同步的话，有一定的性能压力。</p>
</li>
<li><p>存在个别Bug，造成恢复不能。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>重写规则说明</p>
</blockquote>
<p>aof 默认就是文件的无限追加，文件会越来越大！</p>
<p><img src="/images/database/redis/%E6%8C%81%E4%B9%85%E5%8C%96-RDB%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99.png" alt="持久化-RDB重写规则.png"></p>
<p>如果 aof 文件大于 64m，太大了！ fork一个新的进程来将我们的文件进行重写！</p>
<p><strong>扩展：</strong></p>
<ol>
<li><p>RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</p>
</li>
<li><p>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</p>
</li>
<li><p>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</p>
</li>
<li><p>同时开启两种持久化方式在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在Bug，留着作为一个万一的手段。</p>
</li>
<li><p>性能建议</p>
</li>
</ol>
<ul>
<li><p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 9001 这条规则。</p>
</li>
<li><p>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</p>
</li>
<li><p>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</p>
</li>
</ul>
<h1 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h1><blockquote>
<p>订阅端</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE kuangshenshuo <span class="comment"># 订阅一个频道 kuangshenshuo</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"kuangshenshuo"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 等待读取推送的信息</span></span><br><span class="line">1) <span class="string">"message"</span> <span class="comment"># 消息</span></span><br><span class="line">2) <span class="string">"kuangshenshuo"</span> <span class="comment"># 那个频道的消息</span></span><br><span class="line">3) <span class="string">"hello,kuangshen"</span> <span class="comment"># 消息的具体内容</span></span><br><span class="line">1) <span class="string">"message"</span></span><br><span class="line">2) <span class="string">"kuangshenshuo"</span></span><br><span class="line">3) <span class="string">"hello,redis"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>发送端</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH kuangshenshuo <span class="string">"hello,kuangshen"</span></span><br><span class="line"><span class="comment"># 发布者发布消息到频道！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH kuangshenshuo <span class="string">"hello,redis"</span></span><br><span class="line"><span class="comment"># 发布者发布消息到频道！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景：</strong></p>
<ol>
<li><p>实时消息系统！</p>
</li>
<li><p>事实聊天！（频道当做聊天室，将信息回显给所有人即可！）</p>
</li>
<li><p>订阅，关注系统都是可以的！</p>
</li>
</ol>
<p>稍微复杂的场景我们就会使用 消息中间件 MQ </p>
<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul>
<li>新建myredis目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a etc]# mkdir myredis</span><br></pre></td></tr></table></figure>

<ul>
<li>复制一份redis.conf到myredis目录（etc目录下复制过redis.conf， 如果没有就去安装目录复制）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a etc]# cp redis.conf myredis&#x2F;redis.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>修改myredis目录下redis.conf，将daemonize设置为yes,Appendonly 关掉</li>
<li>myredis目录下新建redis6379.conf ,并添加内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a myredis]# vi redis6379.conf</span><br><span class="line">include redis.conf</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">dbfilename dump6379.rdb</span><br></pre></td></tr></table></figure>

<ul>
<li>myredis目录下新建redis6380.conf ,并添加内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a myredis]# vi redis6380.conf</span><br><span class="line">include redis.conf</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6380.pid</span><br><span class="line">port 6380</span><br><span class="line">dbfilename dump6380.rdb</span><br></pre></td></tr></table></figure>

<ul>
<li>myredis目录下新建redis6381.conf ,并添加内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a myredis]# vi redis6381.conf</span><br><span class="line">include redis.conf</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6381.pid</span><br><span class="line">port 6381</span><br><span class="line">dbfilename dump6381.rdb</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭以前启动的redis服务</li>
</ul>
<p><code>ps -ef | grep redis</code>  查看端口号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill port</span><br></pre></td></tr></table></figure>

<ul>
<li>使用三个配置文件分别启动redis</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a myredis]# redis-server redis6379.conf</span><br><span class="line">[root@a myredis]# redis-server redis6380.conf</span><br><span class="line">[root@a myredis]# redis-server redis6381.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>打开server-cli</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a myredis]# redis-cli -p 6379</span><br><span class="line">[root@a myredis]# redis-cli -p 6380</span><br><span class="line">[root@a myredis]# redis-cli -p 6381</span><br></pre></td></tr></table></figure>

<ul>
<li>在客户端输入<code>info replication</code>打印主从复制的相关信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br></pre></td></tr></table></figure>

<ul>
<li>配从库而不配主库，在从库中设置主从信息，选取6379为主</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt;  slaveof 127.0.0.1 6379</span><br><span class="line">127.0.0.1:6381&gt;  slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<p>PS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从机只能读数据而不能写数据</span><br><span class="line">主机挂掉，重启就行，主从配置不会失效</span><br><span class="line">从机重启需重设：slaveof 127.0.0.1 6379 </span><br><span class="line">可以将配置增加到文件中。永久生效。</span><br></pre></td></tr></table></figure>

<h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p><img src="/images/database/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.png" alt="主从复制原理.png"></p>
<h2 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h2><p><img src="/images/database/redis/%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E.png" alt="一主二从.png"></p>
<ul>
<li>主机宕机后，从机原地待命，不会成为主机</li>
<li>从机宕机后，重启后需要重新设置主机IP</li>
<li>从机宕机后，重新挂到主机上，会将主机的数据从头开始复制</li>
</ul>
<h2 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h2><p><img src="/images/database/redis/%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0.png" alt="薪火相传.png"></p>
<ul>
<li><p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p>
</li>
<li><p>用 slaveof  <ip><port></p>
</li>
<li><p>中途变更转向:会清除之前的数据，重新建立拷贝最新的</p>
</li>
<li><p>风险是一旦某个slave宕机，后面的slave都没法备份</p>
</li>
</ul>
<h3 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h3><ul>
<li>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。</li>
</ul>
<p>如果主机断开了连接，我们可以使用 SLAVEOF no one 让自己变成主机！其他的节点就可以手动连接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连接</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><ul>
<li>调整为一主二仆模式，6379带着6380、6381</li>
<li>自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a myredis]# vi sentinel.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>配置哨兵</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br><span class="line"></span><br><span class="line">PS: 其中mymaster为监控对象自定义的服务器名称， 1 为至少有多少个哨兵(启动的sentinel)同意从机切换为主机。</span><br></pre></td></tr></table></figure>

<ul>
<li>启动哨兵</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a myredis]# redis-sentinel  &#x2F;myredis&#x2F;sentinel.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>当主机挂掉，在从机中产生新的主机。原主机重启后会变为从机。</li>
<li>故障恢复    </li>
</ul>
<p><img src="/images/database/redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F-%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D.png" alt="哨兵模式-故障恢复.png"></p>
<blockquote>
<p>PS</p>
<p>优先级在redis.conf中默认：replica-priority 100，值越小优先级越高</p>
<p>偏移量是指获得原主机数据最全的</p>
<p>每个redis实例启动后都会随机生成一个40位的runid</p>
</blockquote>
<h2 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h2><ul>
<li>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</li>
</ul>
<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。</p>
<p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）：即使集群中有一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求</p>
<h2 id="环境配置-aliyun版本"><a href="#环境配置-aliyun版本" class="headerlink" title="环境配置 (aliyun版本)"></a>环境配置 (aliyun版本)</h2><ul>
<li>将myredis目录下的所有dump文件删除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf dump*</span><br></pre></td></tr></table></figure>

<ul>
<li>创建六个redis配置文件</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12805114/1621680889251-5cac6704-619e-405a-a311-c545c1d8c4f0.png" alt="image.png"></p>
<p>每个文件的内容分别为</p>
<blockquote>
<p>redis6379.conf</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include redis.conf</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">dbfilename dump6379.rdb</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>redis6380.conf</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include redis.conf</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6380.pid</span><br><span class="line">port 6380</span><br><span class="line">dbfilename dump6380.rdb</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6380.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>redis6381.conf</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include redis.conf</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6381.pid</span><br><span class="line">port 6381</span><br><span class="line">dbfilename dump6381.rdb</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6381.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>redis6389.conf</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include redis.conf</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6389.pid</span><br><span class="line">port 6389</span><br><span class="line">dbfilename dump6389.rdb</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6389.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>redis6390.conf</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include redis.conf</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6390.pid</span><br><span class="line">port 6390</span><br><span class="line">dbfilename dump6390.rdb</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6390.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>redis6391.conf</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include redis.conf</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6391.pid</span><br><span class="line">port 6391</span><br><span class="line">dbfilename dump6391.rdb</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6391.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure>

<ul>
<li><p>阿里云控制台添加安全组</p>
</li>
<li><p>使用六个配置文件启动六个redis-server</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a myredis]# redis-server redis6379.conf</span><br><span class="line">[root@a myredis]# redis-server redis6380.conf</span><br><span class="line">[root@a myredis]# redis-server redis6381.conf</span><br><span class="line">[root@a myredis]# redis-server redis6389.conf</span><br><span class="line">[root@a myredis]# redis-server redis6390.conf</span><br><span class="line">[root@a myredis]# redis-server redis6391.conf</span><br></pre></td></tr></table></figure>

<ul>
<li><p>确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常</p>
</li>
<li><p>进入下载的redis目录</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd  &#x2F;opt&#x2F;redis-6.2.3&#x2F;src</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 redis-cli 创建整个 redis 集群（redis5.0版本之前使用的ruby脚本 redis-trib.rb，之后的版本已经集成该脚本）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 8.129.52.78:6379 8.129.52.78:6380 8.129.52.78:6381 8.129.52.78:6389 8.129.52.78:6390 8.129.52.78:6391</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此处不要用127.0.0.1，请用真实IP地址，即服务器IP地址</p>
<p>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</p>
</blockquote>
<p>成功示例</p>
<p><img src="/images/database/redis/%E9%9B%86%E7%BE%A4%E6%88%90%E5%8A%9F%E7%A4%BA%E4%BE%8B.png" alt="集群成功示例.png"></p>
<h2 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h2><ul>
<li>-c 采用集群策略连接，设置数据会自动切换到相应的写主机</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a src]#  redis-cli -c -p 6379</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 cluster nodes 命令查看集群信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br></pre></td></tr></table></figure>

<p><img src="/images/database/redis/%E6%9F%A5%E7%9C%8B%E9%9B%86%E7%BE%A4%E4%BF%A1%E6%81%AF.png" alt="查看集群信息.png"></p>
<h2 id="cluster-如何分配当前六个节点"><a href="#cluster-如何分配当前六个节点" class="headerlink" title="cluster 如何分配当前六个节点"></a>cluster 如何分配当前六个节点</h2><ul>
<li>一个集群至少要有三个主节点。</li>
<li>选项–cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</li>
<li>分配原则尽量保证每个主数据库运行在不同的IP地址(即不同的服务器)，每个从库和主库不在一个IP地址上。</li>
</ul>
<h2 id="什么是slots"><a href="#什么是slots" class="headerlink" title="什么是slots"></a>什么是slots</h2><p>一个 Redis 集群包含16384 个插槽（hash slot），数据库中的每个键都属于这16384 个插槽的其中一个，集群使用公式CRC16(key) % 16384 来计算键key 属于哪个槽，其中CRC16(key) 语句用于计算键key 的CRC16 校验和。集群中的每个节点负责处理一部分插槽。</p>
<p>举个例子，一个集群有三个主节点，其中：</p>
<p>节点 A 负责处理0号至5460号插槽。</p>
<p>节点 B 负责处理5461号至10922号插槽。</p>
<p>节点 C 负责处理10923号至16383号插槽。</p>
<h2 id="向集群写值"><a href="#向集群写值" class="headerlink" title="向集群写值"></a>向集群写值</h2><ul>
<li><p>计算出slot后，自动重定向到对应集群节点</p>
</li>
<li><p>通过{}定义组才可以使用mget,mset等多键操作</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8.129.52.78:6379&gt; mset long&#123;d&#125; qwq bold&#123;d&#125; zxz</span><br></pre></td></tr></table></figure>

<h2 id="查询集群中的值"><a href="#查询集群中的值" class="headerlink" title="查询集群中的值"></a>查询集群中的值</h2><ul>
<li>cluster keyslot <key> ：计算键 key 应该被放置在哪个槽上</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster keyslot k1</span><br></pre></td></tr></table></figure>

<p>![cluster keyslot.png](/images/database/redis/cluster keyslot.png)</p>
<ul>
<li>cluster countkeysinslot <slot> ：返回槽 slot 目前包含的键值对数量。（槽slot的值必须在当前节点范围内否则返回0）</li>
</ul>
<p>![cluster countkeysinslot.png](/images/database/redis/cluster countkeysinslot.png)</p>
<ul>
<li>cluster getkeysinslot <slot> <count> ：返回 count 个 slot 槽中的键 （槽slot的值必须在当前节点范围内否则返回empty array）</li>
</ul>
<p>![cluster getkeysinslot.png](/images/database/redis/cluster getkeysinslot.png)</p>
<h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><ul>
<li>某台主机(A)宕机后，它的从机(B)就会成为主机(C)，且再次启动宕机的主机(A)，该主机(A)会变成C的从机</li>
<li>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么，整个集群都挂掉</li>
<li>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</li>
<li>redis.conf中的参数  cluster-require-full-coverage</li>
</ul>
<h2 id="集群好处与不足"><a href="#集群好处与不足" class="headerlink" title="集群好处与不足"></a>集群好处与不足</h2><ul>
<li>好处</li>
</ul>
<p>实现扩容</p>
<p>分摊压力</p>
<p>无中心配置相对简单</p>
<ul>
<li>不足</li>
</ul>
<p>多键操作是不被支持的</p>
<p>多键的Redis事务是不被支持的。lua脚本不被支持</p>
<p>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大</p>
<h1 id="Redis应用问题"><a href="#Redis应用问题" class="headerlink" title="Redis应用问题"></a>Redis应用问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>
<p><img src="/images/database/redis/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png" alt="缓存穿透.png"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p>
<p>解决方案：</p>
<ul>
<li>对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</li>
<li>设置可访问的名单（白名单）：使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</li>
<li>采用布隆过滤器：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</li>
<li>进行实时监控：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>key(某个)对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p><img src="/images/database/redis/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.png" alt="缓存击穿.png"></p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p>
<p>解决问题：</p>
<ul>
<li><p>预先设置热门数据：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</p>
</li>
<li><p>实时调整：现场监控哪些数据热门，实时调整key的过期时长</p>
</li>
<li><p>使用锁：</p>
</li>
<li><ul>
<li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</li>
<li>先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</li>
<li>当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</li>
</ul>
</li>
</ul>
<p><img src="/images/database/redis/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E4%BD%BF%E7%94%A8%E9%94%81.png" alt="缓存击穿-使用锁.png"></p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>key(大量)对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<blockquote>
<p>PS.    缓存雪崩与缓存击穿的区别在于缓存雪崩针对很多key缓存，缓存击穿则是某一个key</p>
</blockquote>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕！</p>
<p>解决方案：</p>
<ul>
<li><p>构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存（ehcache等）</p>
</li>
<li><p>使用锁或队列：用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</p>
</li>
<li><p>设置过期标志更新缓存：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p>
</li>
<li><p>将缓存失效时间分散开：比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
</li>
</ul>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p>
<p>分布式锁主流的实现方案：</p>
<ol>
<li><p>基于数据库实现分布式锁</p>
</li>
<li><p>基于缓存（Redis等）</p>
</li>
<li><p>基于Zookeeper</p>
</li>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<p>每一种分布式锁解决方案都有各自的优缺点：</p>
<ol>
<li><p>性能：redis最高</p>
</li>
<li><p>可靠性：zookeeper最高</p>
</li>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<p>这里，我们就基于redis实现分布式锁。</p>
<h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>redis命令（setnx）</p>
<ul>
<li>setnx加锁，del释放锁</li>
</ul>
<blockquote>
<p>加锁：setnx user niubi</p>
<p>释放锁: del user</p>
<p> 问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放</p>
<p> 解决：设置过期时间，自动释放锁。</p>
</blockquote>
<ul>
<li>设置过期时间防止锁一直不被释放</li>
</ul>
<blockquote>
<p>加锁：setnx user niubi</p>
<p>设置过期：expire user 10</p>
<p> 缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放</p>
</blockquote>
<ul>
<li>同时设置锁和过期时间(推荐使用)</li>
</ul>
<blockquote>
<p>set user 10 nx ex 10</p>
<p> 问题：可能会释放其他服务器的锁。</p>
<p> 场景：如果业务逻辑的执行时间是7s，锁过期时间为3s。执行流程如下</p>
<p>\1. index1业务逻辑没执行完，3秒后锁被自动释放。</p>
<p>\2. index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</p>
<p>\3. index3获取到锁，执行业务逻辑</p>
<p>\4. index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行   1s就被别人释放。</p>
<p>最终等于没锁的情况。</p>
<p> 解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p>
</blockquote>
<ul>
<li>设置UUID防误删(即将key的值设置为唯一值)</li>
</ul>
<blockquote>
<p>set user UUID nx ex 10</p>
<p>问题：删除操作缺乏原子性。</p>
<p>场景：</p>
<ol>
<li><p>index1执行删除时，查询到的lock值确实和uuid相等</p>
</li>
<li><p>index1执行删除前，lock刚好过期时间已到，被redis自动释放</p>
</li>
<li><p>index2获取了lock开始执行方法</p>
</li>
<li><p>index1执行删除，此时会把index2的lock删除  （同一个锁）</p>
</li>
</ol>
<p>index1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。</p>
<p>解决：LUA脚本保证删除的原子性</p>
</blockquote>
<p>set 命令参数详解</p>
<blockquote>
<p>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value </p>
<p>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于                                </p>
<p>  PSETEX key millisecond value 。</p>
<p>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p>
<p>XX ：只在键已经存在时，才对键进行设置操作。</p>
</blockquote>
<ul>
<li>setnx加锁，del释放锁</li>
</ul>
<p><img src="/images/database/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" alt="分布式锁.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;testLock&quot;)</span><br><span class="line">public void testLock()&#123;</span><br><span class="line">    &#x2F;&#x2F;1获取锁，setnx--&gt;setIfAbsent</span><br><span class="line">    Boolean lock &#x3D; redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;111&quot;);</span><br><span class="line">    &#x2F;&#x2F;2获取锁成功、查询num的值</span><br><span class="line">    if(lock)&#123;</span><br><span class="line">        Object value &#x3D; redisTemplate.opsForValue().get(&quot;num&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.1判断num为空return</span><br><span class="line">        if(StringUtils.isEmpty(value))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;2.2有值就转成成int</span><br><span class="line">        int num &#x3D; Integer.parseInt(value+&quot;&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.3把redis的num加1</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;num&quot;, ++num);</span><br><span class="line">        &#x2F;&#x2F;2.4释放锁，del</span><br><span class="line">        redisTemplate.delete(&quot;lock&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F;3获取锁失败、每隔0.1秒再获取</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<ol>
<li><p>多个客户端同时获取锁（setnx）</p>
</li>
<li><p>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p>
</li>
<li><p>其他客户端等待重试</p>
</li>
</ol>
</blockquote>
<ul>
<li>同时设置锁和过期时间(推荐使用)</li>
</ul>
<p><img src="/images/database/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%812.png" alt="分布式锁2.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;testLock&quot;)</span><br><span class="line">public void testLock()&#123;</span><br><span class="line">    &#x2F;&#x2F;1获取锁，setnx--&gt;setIfAbsent</span><br><span class="line">    Boolean lock &#x3D; redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;111&quot;, 10, TimeUnit.SECONDS);</span><br><span class="line">    &#x2F;&#x2F;2获取锁成功、查询num的值</span><br><span class="line">    if(lock)&#123;</span><br><span class="line">        Object value &#x3D; redisTemplate.opsForValue().get(&quot;num&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.1判断num为空return</span><br><span class="line">        if(StringUtils.isEmpty(value))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;2.2有值就转成成int</span><br><span class="line">        int num &#x3D; Integer.parseInt(value+&quot;&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.3把redis的num加1</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;num&quot;, ++num);</span><br><span class="line">        &#x2F;&#x2F;2.4释放锁，del，保证锁必须被释放</span><br><span class="line">        redisTemplate.delete(&quot;lock&quot;);  --&gt;当业务执行时间小与过期时间时需要释放锁</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F;3获取锁失败、每隔0.1秒再获取</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置UUID防误删</li>
</ul>
<p><img src="/images/database/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%813-uuid.png" alt="分布式锁3-uuid.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;testLock&quot;)</span><br><span class="line">public void testLock()&#123;</span><br><span class="line">    &#x2F;&#x2F;1获取锁，setnx--&gt;setIfAbsent</span><br><span class="line">    String uuid &#x3D; UUID.randomUUID().toString();</span><br><span class="line">    Boolean lock &#x3D; redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, uuid, 10, TimeUnit.SECONDS);</span><br><span class="line">    &#x2F;&#x2F;2获取锁成功、查询num的值</span><br><span class="line">    if(lock)&#123;</span><br><span class="line">        Object value &#x3D; redisTemplate.opsForValue().get(&quot;num&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.1判断num为空return</span><br><span class="line">        if(StringUtils.isEmpty(value))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;2.2有值就转成成int</span><br><span class="line">        int num &#x3D; Integer.parseInt(value+&quot;&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.3把redis的num加1</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;num&quot;, ++num);</span><br><span class="line">        &#x2F;&#x2F;2.4释放锁，del，保证锁必须被释放--&gt;当业务执行时间小与过期时间时需要释放锁</span><br><span class="line">        if(uuid.equals((String)redisTemplate.opsForValue().get(&quot;lock&quot;)))&#123;</span><br><span class="line">             redisTemplate.delete(&quot;lock&quot;); --&gt;删除自己的锁</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F;3获取锁失败、每隔0.1秒再获取</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>LUA脚本保证删除的原子性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;testLockLua&quot;)</span><br><span class="line">public void testLockLua() &#123;</span><br><span class="line">    &#x2F;&#x2F;1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中</span><br><span class="line">    String uuid &#x3D; UUID.randomUUID().toString();</span><br><span class="line">    &#x2F;&#x2F;2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！</span><br><span class="line">    String skuId &#x3D; &quot;25&quot;; &#x2F;&#x2F; 访问skuId 为25号的商品 100008348542</span><br><span class="line">    String locKey &#x3D; &quot;lock:&quot; + skuId; &#x2F;&#x2F; 锁住的是每个商品的数据</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 3 获取锁</span><br><span class="line">    Boolean lock &#x3D; redisTemplate.opsForValue().setIfAbsent(locKey, uuid, 3, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 第一种： lock 与过期时间中间不写任何的代码。</span><br><span class="line">    &#x2F;&#x2F; redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);&#x2F;&#x2F;设置过期时间</span><br><span class="line">    &#x2F;&#x2F; 如果true</span><br><span class="line">    if (lock) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行的业务逻辑开始</span><br><span class="line">        &#x2F;&#x2F; 获取缓存中的num 数据</span><br><span class="line">        Object value &#x3D; redisTemplate.opsForValue().get(&quot;num&quot;);</span><br><span class="line">        &#x2F;&#x2F; 如果是空直接返回</span><br><span class="line">        if (StringUtils.isEmpty(value)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！</span><br><span class="line">        int num &#x3D; Integer.parseInt(value + &quot;&quot;);</span><br><span class="line">        &#x2F;&#x2F; 使num 每次+1 放入缓存</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;num&quot;, String.valueOf(++num));</span><br><span class="line">        &#x2F;*使用lua脚本解锁*&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 定义lua 脚本</span><br><span class="line">        String script &#x3D; &quot;if redis.call(&#39;get&#39;, KEYS[1]) &#x3D;&#x3D; ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">        &#x2F;&#x2F; 使用redis执行lua执行</span><br><span class="line">        DefaultRedisScript&lt;Long&gt; redisScript &#x3D; new DefaultRedisScript&lt;&gt;();</span><br><span class="line">        redisScript.setScriptText(script);</span><br><span class="line">        &#x2F;&#x2F; 设置一下返回值类型 为Long</span><br><span class="line">        &#x2F;&#x2F; 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，</span><br><span class="line">        &#x2F;&#x2F; 那么返回字符串与0 会有发生错误。</span><br><span class="line">        redisScript.setResultType(Long.class);</span><br><span class="line">        &#x2F;&#x2F; 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。</span><br><span class="line">        redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 其他线程等待</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 睡眠</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            &#x2F;&#x2F; 睡醒了之后，调用方法。</span><br><span class="line">            testLockLua();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>加锁</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 从redis中获取锁,set k1 v1 px 20000 nx</span><br><span class="line">String uuid &#x3D; UUID.randomUUID().toString();</span><br><span class="line">Boolean lock &#x3D; this.redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, uuid, 2, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>解锁</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 2. 释放锁 del</span><br><span class="line">String script &#x3D; &quot;if redis.call(&#39;get&#39;, KEYS[1]) &#x3D;&#x3D; ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">&#x2F;&#x2F; 设置lua脚本返回的数据类型</span><br><span class="line">DefaultRedisScript&lt;Long&gt; redisScript &#x3D; new DefaultRedisScript&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F; 设置lua脚本返回类型为Long</span><br><span class="line">redisScript.setResultType(Long.class);</span><br><span class="line">redisScript.setScriptText(script);</span><br><span class="line">redisTemplate.execute(redisScript, Arrays.asList(&quot;lock&quot;),uuid);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>重试</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread.sleep(500);</span><br><span class="line">testLock();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p>
<p>- 互斥性。在任意时刻，只有一个客户端能持有锁。</p>
<p>- 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</p>
<p>- 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</p>
<p>- 加锁和解锁必须具有原子性。</p>
</blockquote>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 学习笔记 - 性能监控与调优</title>
    <url>/2021/06/04/java/JVM-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1PJ411n7xZ" target="_blank" rel="noopener">尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）</a>学习记录</p>
<a id="more"></a>

<blockquote>
<p>笔记来源：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ" target="_blank" rel="noopener">尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）</a></p>
<p>参考笔记：<a href="https://github.com/vectorxxxx/NOTE_JVM" target="_blank" rel="noopener">vectorxxxx/NOTE_JVM: 尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）学习笔记 (github.com)</a></p>
<p><a href="https://gitee.com/tcl192243051/studyJVM/blob/master/4_性能调优篇/JVM监控及诊断工具-GUI篇.md" target="_blank" rel="noopener">4_性能调优篇/JVM监控及诊断工具-GUI篇.md · Tc.l/学习Java虚拟机笔记 - 码云 - 开源中国 (gitee.com</a></p>
</blockquote>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="性能优化的步骤"><a href="#性能优化的步骤" class="headerlink" title="性能优化的步骤"></a>性能优化的步骤</h2><ol>
<li>性能监控：非侵入方式手机运营性能数据，起到预防作用<ol>
<li>GC频繁</li>
<li>cpu load过高</li>
<li>OOM</li>
<li>内存泄漏</li>
<li>死锁</li>
<li>程序响应时间较长</li>
<li>…</li>
</ol>
</li>
<li>性能分析：侵入方式收i就运行性数据，会影响应用的吞吐量或响应性；很少在生产环境进行，通常是在质量评估、系统测试或者开发环境下进行<ol>
<li>查看堆栈信息等W</li>
<li>查看GC日志</li>
<li>…</li>
</ol>
</li>
<li>性能调优<ol>
<li>增加内存</li>
<li>优化代码</li>
<li>设置JVM参数</li>
<li>设置线程池线程数量</li>
<li>…</li>
</ol>
</li>
</ol>
<h2 id="性能评价-测试指标"><a href="#性能评价-测试指标" class="headerlink" title="性能评价/测试指标"></a>性能评价/测试指标</h2><ol>
<li>听到时间（或响应时间）</li>
<li>吞吐量</li>
<li>并发数（同一时刻，对服务器实际交互的请求数）</li>
<li>内存占用</li>
</ol>
<h1 id="JVM监控及诊断工具-命令行"><a href="#JVM监控及诊断工具-命令行" class="headerlink" title="JVM监控及诊断工具-命令行"></a>JVM监控及诊断工具-命令行</h1><blockquote>
<p>源码：<a href="https://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools" target="_blank" rel="noopener">https://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools</a></p>
</blockquote>
<h2 id="jps-查看Java进程"><a href="#jps-查看Java进程" class="headerlink" title="jps 查看Java进程"></a>jps 查看Java进程</h2><blockquote>
<p> Jps（Java Proecess Status） 查看正在运行的虚拟机进程</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-q：输出应用程序主类的全类名 或 如果进程执行的是jar包，则输出jar完整路径</span><br><span class="line">-m：输出虚拟机进程启动时传递给主类main()的参数</span><br><span class="line">-v：列出虚拟机进程启动时的JVM参数</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果Java进程添加了 -xx:-UsePrefData参数，则jps不会显示该进程</p>
</blockquote>
<h2 id="jstat查看JVM统计信息"><a href="#jstat查看JVM统计信息" class="headerlink" title="jstat查看JVM统计信息"></a>jstat查看JVM统计信息</h2><blockquote>
<p>jstat( JVM Statistics Monitoring TooL):用于监视虛拟机各种运行状态信息的命令行工具。它可以是示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<p>在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题</p>
<p>jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]</p>
<p>示例：jstat -gc -t 14024 1000 20</p>
</blockquote>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li><p>Option</p>
<p><strong>类装载相关的</strong>：</p>
<ul>
<li>-class:显示ClassLoader的相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间等</li>
</ul>
<p><strong>垃圾回收相关的</strong>：</p>
<ul>
<li>-gc: 显示与Gc相关的堆信息。包括Eden区、两个Survivor区、老年代永久代等的容量、已用空间、GC时间合计等信息。</li>
<li>-gccapacity:显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。</li>
<li>-gcutil:显示内容与-gc基本相同，但输出主要关注己使用空间占总空间的百分比。</li>
<li>-gccause:与-gutil功能一样，但是会额外输出导致最后一次或当前正在发生的GC产生的原因</li>
<li>-gcnew:显示新生代GC状况</li>
<li>-gcnewcapacity:显示内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</li>
<li>-geold:显示老年代GC状况</li>
</ul>
<p><strong>JIT相关的</strong>：</p>
<ul>
<li>-compiler: 显示JIT编译器编译过的方法、耗时等信息</li>
<li>-printcompilation:输出已经被JIT编译的方法</li>
</ul>
</li>
<li><p>interval： 用于指定输出统计数据的周期，单位为毫秒。即：查询间隔</p>
</li>
<li><p>count：用于指定查询的总次数</p>
</li>
<li><p>-t：可以在输出信息前加上一个Timestamp列，显示程序的运行时间。单位为秒</p>
<ul>
<li>我们可以比较Java进程的启动时间以及总GC时间(GCT列)，或者两次测量的间隔时间 以及总GC时间的增量，来得出GC时间占运行时间的比例。 如果该比例超过20%,则说明目前堆的压力较大：如果该比例超过90%,则说明堆里几乎没有 可用空间，随时都可能抛出OOM异常。</li>
</ul>
</li>
<li><p>-h：可以在周期性数据输出时，输出多少行数据后输出一个表头信息</p>
</li>
</ul>
<h3 id="jstat判断内存泄漏"><a href="#jstat判断内存泄漏" class="headerlink" title="jstat判断内存泄漏"></a>jstat判断内存泄漏</h3><ol>
<li>在长时间运行的Java程序中，我们可以运行jstat命令连续获取多行性能数据，并取这几行<br>数据中OU列（即已占用的老年代内存）的最小值</li>
<li>然后，我们每隔一段较长的时间重复一次上述操作，来获得多组OU最小值。如果这些值呈上涨趋势。则说明该Java程序的老年代内存己使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在存泄漏。</li>
</ol>
<h2 id="jinfo实时查看-修改JVM参数"><a href="#jinfo实时查看-修改JVM参数" class="headerlink" title="jinfo实时查看,修改JVM参数"></a>jinfo实时查看,修改JVM参数</h2><blockquote>
<p>jinfo(Configuration Info for Java)：查看虚拟机配置参数信思，也可用于调整虚拟机的配置参数</p>
</blockquote>
<p>在很多情况下，Java应用程序不会指定所有的Java虚拟机参数。而此时，开发人员可能不知道某一个具体的Java虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数<br>的默认值。这个查找过程可能是非常艰难的。但有了 jinfo工具，开发人员可以很方便地找到Java虚拟机参数的当前值。</p>
<p>jinfo不仅可以查看运行时某一个Java虚拟机参数的实际取值，甚至可以在运行时修改部分参 数，并使之立即生效。 但是，并非所有参数都支持动态修改。参数只有被标记为manageable的flag可以被实时修改。</p>
<h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><p>查看</p>
<ul>
<li>-sysprops：查看由System.getProperties()取得的参数</li>
<li>-flags：查看曾经赋值过的一些参数</li>
<li>-flag 具体参数：查看某个java进程的</li>
</ul>
<p>修改</p>
<ul>
<li>略。后面补充</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jinfo [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jinfo [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    -flag &lt;name&gt;         to print the value of the named VM flag</span><br><span class="line">    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag</span><br><span class="line">    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value</span><br><span class="line">    -flags               to print VM flags</span><br><span class="line">    -sysprops            to print Java system properties</span><br><span class="line">    &lt;no option&gt;          to print both of the above</span><br><span class="line">    -h | -help           to print this help message</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -XX: -PrintFlagslnitial 查看所有JVM参数启动的初始值</span><br><span class="line">java -XX: +PrintFlagsFinal 查看所有JVM参数的最终值</span><br><span class="line">java -XX: +PrintCommandLineflags 查看那些已经被用户或者JVM设置过的详细的XX参数的名称和值</span><br></pre></td></tr></table></figure>

<h2 id="jmap导出内存映像文件和内存使用情况"><a href="#jmap导出内存映像文件和内存使用情况" class="headerlink" title="jmap导出内存映像文件和内存使用情况"></a>jmap导出内存映像文件和内存使用情况</h2><blockquote>
<p>jmap( JVM Memory Map)：导出内存映像文件&amp;内存使用情况</p>
<p>作用一方面是获取dump文件(堆转储快照文件，二进制文件)， 它还可以获取目标Java进程的内存相关信息，包括Java堆各区域的使用情况、堆中对象的统 计信息、类加载信息等</p>
</blockquote>
<p>基本语法</p>
<ul>
<li>jmap [option] <pid></li>
<li>jmap [option] &lt;executable <core></li>
<li>jmap [option] [server_id@]<remote server IP or hostname></li>
</ul>
<p>其中option包括：</p>
<p><img src="/images/java/jvm/jmap%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0.png" alt="jmap部分参数.png"></p>
<p><img src="/images/java/jvm/jmap%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.png" alt="jmap基本语法.png"></p>
<h3 id="导出内存映射文件"><a href="#导出内存映射文件" class="headerlink" title="导出内存映射文件"></a>导出内存映射文件</h3><p>导出的文件可用 JProfiler 查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一般来说，使用jmap指令生成dump文件的操作算得上是最常用的jmap命令之一，将堆中所有存活对象导出至一个文件之中。</span><br><span class="line">Heap Dump又叫做堆存储文件，指一个Java进程在某个时间点的内存快照。 Heap Dump在触发内存快照的时候会保存此刻的信息如下</span><br><span class="line"></span><br><span class="line">All Objects</span><br><span class="line">Class, fields, primitive values and references</span><br><span class="line">All Classes</span><br><span class="line">Classloader, name, super class, static fields</span><br><span class="line">Garbage Collection Roots</span><br><span class="line">Objects defined to be reachable by the JVM</span><br><span class="line">Thread Stacks and Local Variables</span><br><span class="line">The call-stacks of threads at the moment of the snapshot, and per-frame</span><br><span class="line">information about local objects</span><br><span class="line">说明</span><br><span class="line">1 通常在写 Heap Dump文件前会触发一次Full GC,所以 heap dump文件里保存的都是Fu116C后留下的对象信息。</span><br><span class="line">2 由于生成dump文件比较耗时，因此大家需要耐心等待，尤其是大内存镜像生成dump文件则需要耗费更长的时间来完成</span><br></pre></td></tr></table></figure>

<ul>
<li><p>手动导出 : 手动直接立即导出</p>
<ul>
<li><code>jmap -dump:format=b,file=导出目录\文件名.hprof pid</code></li>
<li><code>jmap -dump:live,format=b,file=导出目录\文件名.hprof pid</code><ul>
<li>只dump出存活对象的快照,节省dump时间,空间 (一般在手动时使用这种方式)</li>
</ul>
</li>
</ul>
</li>
<li><p>自动导出: 启动程序时需要带参数,发生OOM时自动导出</p>
<ul>
<li><code>-XX:+HeapDumpOnOutOfMemoryError</code></li>
<li><code>-XX:HeapDumpPath=导出目录\文件名.hprof</code></li>
</ul>
</li>
</ul>
<h3 id="显示堆内存相关信息"><a href="#显示堆内存相关信息" class="headerlink" title="显示堆内存相关信息"></a>显示堆内存相关信息</h3><ul>
<li>jmap -heap pid</li>
<li>jmap -histo pid</li>
</ul>
<h3 id="其他作用"><a href="#其他作用" class="headerlink" title="其他作用"></a>其他作用</h3><ul>
<li>jmap -permstat pid：查看系统的ClassLoader信息</li>
<li>jmap -finalizerinfo：查看堆积在finalizer队列中的对象</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>jmap会访问所有对象,为了不会用户线程干扰,jmap会借助安全点,在安全点中所有线程不会改变堆中对象状态,也就是说: <strong>jmap导出的内存快照文件都是在安全点位置的</strong></p>
<p>结果可能出现偏差(比如某对象声明周期在两个安全点,使用live时就无法探知到这些对象)</p>
<p><strong>如果某线程长时间无法到安全点或安全区域,jmap就会等待,而jstat只需要在安全点读取垃圾回收器保存的统计数据</strong></p>
<h2 id="jhat分析dump文件工具"><a href="#jhat分析dump文件工具" class="headerlink" title="jhat分析dump文件工具"></a>jhat分析dump文件工具</h2><blockquote>
<p>Java Heap Analysis Tool:内置微型服务器分析jmap生成的dump文件</p>
<p>jdk9后删除，官方建议使用VisualVM代替</p>
<p>使用: <code>jhat [option] [dumpfile目录]</code>，然后访问localhost:7000查看</p>
</blockquote>
<h3 id="option参数"><a href="#option参数" class="headerlink" title="option参数"></a>option参数</h3><p>![jhat options参数.png](/images/java/jvm/jhat options参数.png)</p>
<h2 id="jstack打印JVM线程快照"><a href="#jstack打印JVM线程快照" class="headerlink" title="jstack打印JVM线程快照"></a>jstack打印JVM线程快照</h2><p><strong>JVM Stack Trace: 生成指定Java进程中当前时刻的线程快照,常用于定位线程出现长时间停顿的原因</strong></p>
<p><strong>格式: <code>jstack option pid</code></strong></p>
<p><img src="/images/java/jvm/jstack%E7%A4%BA%E4%BE%8B.png" alt="jstack示例.png"></p>
<blockquote>
<p>option参数</p>
</blockquote>
<p>![jstack options参数.png](/images/java/jvm/jstack options参数.png)</p>
<h2 id="jcmd多功能命令行"><a href="#jcmd多功能命令行" class="headerlink" title="jcmd多功能命令行"></a>jcmd多功能命令行</h2><p>jcmd可以实现除了jstat外所有指令的功能</p>
<p><img src="/images/java/jvm/jcmd%E5%8A%9F%E8%83%BD.png" alt="jcmd功能.png"></p>
<blockquote>
<p>jcmd -l 类似jps</p>
</blockquote>
<p>![jcmd -l.png](/images/java/jvm/jcmd -l.png)</p>
<blockquote>
<p>jcmd pid help</p>
</blockquote>
<p>![jcmd pid help.png](/images/java/jvm/jcmd pid help.png)</p>
<blockquote>
<p>jcmd pid 具体命令</p>
</blockquote>
<p>![jcmd pid 具体命令.png](/images/java/jvm/jcmd pid 具体命令.png)</p>
<h2 id="jstatd远程主机信息收集"><a href="#jstatd远程主机信息收集" class="headerlink" title="jstatd远程主机信息收集"></a>jstatd远程主机信息收集</h2><p>以上的很多指令都可以连接远程主机查看信息需要搭配jstatd使用</p>
<h1 id="JVM监控及诊断工具-GUI篇"><a href="#JVM监控及诊断工具-GUI篇" class="headerlink" title="JVM监控及诊断工具-GUI篇"></a>JVM监控及诊断工具-GUI篇</h1><p><img src="/images/java/jvm/JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-GUI.png" alt="JVM监控及诊断工具-GUI.png"></p>
<h2 id="工具概述"><a href="#工具概述" class="headerlink" title="工具概述"></a>工具概述</h2><p>使用上一章命令行工具或组合能帮您获取目标Java应用性能相关的基础信息，但它们存在下列局限：</p>
<ul>
<li>无法获取方法级别的分析数据，如方法间的调用关系、各方法的调用次数和调用时间等（这对定位应用性能瓶颈至关重要）。</li>
<li>要求用户登录到目标 Java 应用所在的宿主机上，使用起来不是很方便。</li>
<li>分析数据通过终端输出，结果展示不够直观。</li>
</ul>
<p>为此，JDK提供了一些内存泄漏的分析工具，如jconsole，jvisualvm等，用于辅助开发人员定位问题，但是这些工具很多时候并不足以满足快速定位的需求。所以这里我们介绍的工具相对多一些、丰富一些。</p>
<p><strong>JDK自带的工具</strong></p>
<ul>
<li><p>jconsole：JDK自带的可视化监控工具。查看Java应用程序的运行概况、监控堆信息、永久区（或元空间）使用情况、类加载情况等</p>
</li>
<li><p>Visual VM：Visual VM是一个工具，它提供了一个可视界面，用于查看Java虚拟机上运行的基于Java技术的应用程序的详细信息。</p>
</li>
<li><p>JMC：Java Mission Control，内置Java Flight Recorder。能够以极低的性能开销收集Java虚拟机的性能数据。</p>
</li>
</ul>
<p><strong>第三方工具</strong></p>
<ul>
<li><p>MAT：MAT（Memory Analyzer Tool）是基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</p>
</li>
<li><p>JProfiler：商业软件，需要付费。功能强大。</p>
</li>
</ul>
<h2 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h2><p>jconsole：从Java5开始，在JDK中自带的java监控和管理控制台。用于对JVM中内存、线程和类等的监控，是一个基于JMX（java management extensions）的GUI性能监控工具。</p>
<p>官方地址：<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html</a></p>
<p><img src="/images/java/jvm/JConsole.png" alt="JConsole.png"></p>
<p><img src="/images/java/jvm/JConsole2.png" alt="JConsole2.png"></p>
<p><img src="/images/java/jvm/JConsole3.png" alt="JConsole3.png"></p>
<p><img src="/images/java/jvm/JConsole4.png" alt="JConsole4.png"></p>
<p><img src="/images/java/jvm/JConsole5.png" alt="JConsole5.png"></p>
<h2 id="Visual-VM"><a href="#Visual-VM" class="headerlink" title="Visual VM"></a>Visual VM</h2><p>Visual VM是一个功能强大的多合一故障诊断和性能监控的可视化工具。它集成了多个JDK命令行工具，使用Visual VM可用于显示虚拟机进程及进程的配置和环境信息（jps，jinfo），监视应用程序的CPU、GC、堆、方法区及线程的信息（jstat、jstack）等，甚至代替JConsole。在JDK 6 Update 7以后，Visual VM便作为JDK的一部分发布（VisualVM 在JDK／bin目录下）即：它完全免费。</p>
<p><strong>主要功能：</strong></p>
<ul>
<li>生成/读取堆内存/线程快照</li>
<li>查看JVM参数和系统属性</li>
<li>查看运行中的虚拟机进程</li>
<li>程序资源的实时监控</li>
<li>JMX代理连接、远程环境监控、CPU分析和内存分析</li>
</ul>
<p>官方地址：<a href="https://visualvm.github.io/index.html" target="_blank" rel="noopener">https://visualvm.github.io/index.html</a></p>
<p>![Visual VM.png](/images/java/jvm/Visual VM.png)</p>
<p>![Visual VM2.png](/images/java/jvm/Visual VM2.png)</p>
<p>![Visual VM3.png](/images/java/jvm/Visual VM3.png)</p>
<h2 id="Eclipse-MAT"><a href="#Eclipse-MAT" class="headerlink" title="Eclipse MAT"></a>Eclipse MAT</h2><p>MAT（Memory Analyzer Tool）工具是一款功能强大的Java堆内存分析器。可以用于查找内存泄漏以及查看内存消耗情况。MAT是基于Eclipse开发的，不仅可以单独使用，还可以作为插件的形式嵌入在Eclipse中使用。是一款免费的性能分析工具，使用起来非常方便。</p>
<p>MAT可以分析heap dump文件。在进行内存分析时，只要获得了反映当前设备内存映像的hprof文件，通过MAT打开就可以直观地看到当前的内存信息。一般说来，这些内存信息包含：</p>
<ul>
<li>所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。</li>
<li>所有的类信息，包括classloader、类名称、父类、静态变量等</li>
<li>GCRoot到所有的这些对象的引用路径</li>
<li>线程信息，包括线程的调用栈及此线程的线程局部变量（TLS）</li>
</ul>
<p>MAT 不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如Sun，HP，SAP 所采用的 HPROF 二进制堆存储文件，以及 IBM的 PHD 堆存储文件等都能被很好的解析。</p>
<p>最吸引人的还是能够快速为开发人员生成内存泄漏报表，方便定位问题和分析问题。虽然MAT有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从MAT展现给我们的信息当中通过经验和直觉来判断才能发现。</p>
<p>官方地址： <a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">https://www.eclipse.org/mat/downloads.php</a> </p>
<p>![Eclipse MAT1.png](/images/java/jvm/Eclipse MAT1.png)</p>
<p>![Eclipse MAT2.png](/images/java/jvm/Eclipse MAT2.png)</p>
<p>![Eclipse MAT3.png](/images/java/jvm/Eclipse MAT3.png)</p>
<p>![Eclipse MAT4.png](/images/java/jvm/Eclipse MAT4.png)</p>
<h2 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h2><p>在运行Java的时候有时候想测试运行时占用内存情况，这时候就需要使用测试工具查看了。在eclipse里面有 Eclipse Memory Analyzer tool（MAT）插件可以测试，而在IDEA中也有这么一个插件，就是JProfiler。JProfiler 是由 ej-technologies 公司开发的一款 Java 应用性能诊断工具。功能强大，但是收费。</p>
<p><strong>特点：</strong></p>
<ul>
<li>使用方便、界面操作友好（简单且强大）</li>
<li>对被分析的应用影响小（提供模板）</li>
<li>CPU，Thread，Memory分析功能尤其强大</li>
<li>支持对jdbc，noSql，jsp，servlet，socket等进行分析</li>
<li>支持多种模式（离线，在线）的分析</li>
<li>支持监控本地、远程的JVM</li>
<li>跨平台，拥有多种操作系统的安装版本</li>
</ul>
<p><strong>主要功能：</strong></p>
<ul>
<li>方法调用：对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法</li>
<li>内存分配：通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄露问题，优化内存使用</li>
<li>线程和锁：JProfiler提供多种针对线程和锁的分析视图助您发现多线程问题</li>
<li>高级子系统：许多性能问题都发生在更高的语义级别上。例如，对于JDBC调用，您可能希望找出执行最慢的SQL语句。JProfiler支持对这些子系统进行集成分析</li>
</ul>
<p>官网地址：<a href="https://www.ej-technologies.com/products/jprofiler/overview.html" target="_blank" rel="noopener">https://www.ej-technologies.com/products/jprofiler/overview.html</a></p>
<p><strong>数据采集方式：</strong></p>
<p>JProfier数据采集方式分为两种：Sampling（样本采集）和Instrumentation（重构模式）</p>
<p><strong>Instrumentation</strong>：这是JProfiler全功能模式。在class加载之前，JProfier把相关功能代码写入到需要分析的class的bytecode中，对正在运行的jvm有一定影响。</p>
<ul>
<li>优点：功能强大。在此设置中，调用堆栈信息是准确的。</li>
<li>缺点：若要分析的class较多，则对应用的性能影响较大，CPU开销可能很高（取决于Filter的控制）。因此使用此模式一般配合Filter使用，只对特定的类或包进行分析</li>
</ul>
<p><strong>Sampling</strong>：类似于样本统计，每隔一定时间（5ms）将每个线程栈中方法栈中的信息统计出来。</p>
<ul>
<li>优点：对CPU的开销非常低，对应用影响小（即使你不配置任何Filter）</li>
<li>缺点：一些数据／特性不能提供（例如：方法的调用次数、执行时间）</li>
</ul>
<p>注：JProfiler本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型。因为JProfiler的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是JProfiler的数据采集类型。</p>
<p><strong>遥感监测 Telemetries</strong></p>
<p><img src="/images/java/jvm/JProfiler1.png" alt="JProfiler1.png"></p>
<p><img src="/images/java/jvm/JProfiler2.png" alt="JProfiler2.png"></p>
<p><img src="/images/java/jvm/JProfiler3.png" alt="JProfiler3.png"></p>
<p><img src="/images/java/jvm/JProfiler4.png" alt="JProfiler4.png"></p>
<p><img src="/images/java/jvm/JProfiler5.png" alt="JProfiler5.png"></p>
<p><img src="/images/java/jvm/JProfiler6.png" alt="JProfiler6.png"></p>
<p><img src="/images/java/jvm/JProfiler7.png" alt="JProfiler7.png"></p>
<p><strong>内存视图 Live Memory</strong></p>
<p>Live memory 内存剖析：class／class instance的相关信息。例如对象的个数，大小，对象创建的方法执行栈，对象创建的热点。</p>
<ul>
<li><strong>所有对象 All Objects</strong>：显示所有加载的类的列表和在堆上分配的实例数。只有Java 1.5（JVMTI）才会显示此视图。</li>
<li><strong>记录对象 Record Objects</strong>：查看特定时间段对象的分配，并记录分配的调用堆栈。</li>
<li><strong>分配访问树 Allocation Call Tree</strong>：显示一棵请求树或者方法、类、包或对已选择类有带注释的分配信息的J2EE组件。</li>
<li><strong>分配热点 Allocation Hot Spots</strong>：显示一个列表，包括方法、类、包或分配已选类的J2EE组件。你可以标注当前值并且显示差异值。对于每个热点都可以显示它的跟踪记录树。</li>
<li><strong>类追踪器 Class Tracker</strong>：类跟踪视图可以包含任意数量的图表，显示选定的类和包的实例与时间。</li>
</ul>
<p><img src="/images/java/jvm/JProfiler-%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE.png" alt="JProfiler-内存视图.png"></p>
<p><img src="/images/java/jvm/JProfiler-%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE2.png" alt="JProfiler-内存视图2.png"></p>
<p><strong>堆遍历 heap walker</strong></p>
<p><img src="/images/java/jvm/JProfiler-%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE3.png" alt="JProfiler-内存视图3.png"></p>
<p><img src="/images/java/jvm/JProfiler-%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE4.png" alt="JProfiler-内存视图4.png"></p>
<p><strong>cpu视图 cpu views</strong></p>
<p>JProfiler 提供不同的方法来记录访问树以优化性能和细节。线程或者线程组以及线程状况可以被所有的视图选择。所有的视图都可以聚集到方法、类、包或J2EE组件等不同层上。</p>
<ul>
<li><strong>访问树 Call Tree</strong>：显示一个积累的自顶向下的树，树中包含所有在JVM中已记录的访问队列。JDBC，JMS和JNDI服务请求都被注释在请求树中。请求树可以根据Servlet和JSP对URL的不同需要进行拆分。</li>
<li><strong>热点 Hot Spots</strong>：显示消耗时间最多的方法的列表。对每个热点都能够显示回溯树。该热点可以按照方法请求，JDBC，JMS和JNDI服务请求以及按照URL请求来进行计算。</li>
<li><strong>访问图 Call Graph</strong>：显示一个从已选方法、类、包或J2EE组件开始的访问队列的图。</li>
<li><strong>方法统计 Method Statistis</strong>：显示一段时间内记录的方法的调用时间细节。</li>
</ul>
<p><img src="/images/java/jvm/JProfiler-cpu%E8%A7%86%E5%9B%BE1.png" alt="JProfiler-cpu视图1.png"></p>
<p><img src="/images/java/jvm/JProfiler-cpu%E8%A7%86%E5%9B%BE2.png" alt="JProfiler-cpu视图2.png"></p>
<p><strong>线程视图 threads</strong></p>
<p>JProfiler通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程所管理的方法以树状形式呈现。对线程剖析。</p>
<ul>
<li><strong>线程历史 Thread History</strong>：显示一个与线程活动和线程状态在一起的活动时间表。</li>
<li><strong>线程监控 Thread Monitor</strong>：显示一个列表，包括所有的活动线程以及它们目前的活动状况。</li>
<li><strong>线程转储 Thread Dumps</strong>：显示所有线程的堆栈跟踪。</li>
</ul>
<p>线程分析主要关心三个方面：</p>
<ul>
<li>web容器的线程最大数。比如：Tomcat的线程容量应该略大于最大并发数。</li>
<li>线程阻塞</li>
<li>线程死锁</li>
</ul>
<p><img src="/images/java/jvm/JProfiler-%E7%BA%BF%E7%A8%8B%E8%A7%86%E5%9B%BE.png" alt="JProfiler-线程视图.png"></p>
<p><strong>监控和锁 Monitors ＆Locks</strong></p>
<p>所有线程持有锁的情况以及锁的信息。观察JVM的内部线程并查看状态：</p>
<ul>
<li><strong>死锁探测图表 Current Locking Graph</strong>：显示JVM中的当前死锁图表。</li>
<li><strong>目前使用的监测器 Current Monitors</strong>：显示目前使用的监测器并且包括它们的关联线程。</li>
<li><strong>锁定历史图表 Locking History Graph</strong>：显示记录在JVM中的锁定历史。</li>
<li><strong>历史检测记录 Monitor History</strong>：显示重大的等待事件和阻塞事件的历史记录。</li>
<li><strong>监控器使用统计 Monitor Usage Statistics</strong>：显示分组监测，线程和监测类的统计监测数据</li>
</ul>
<h2 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h2><p>上述工具都必须在服务端项目进程中配置相关的监控参数，然后工具通过远程连接到项目进程，获取相关的数据。这样就会带来一些不便，比如线上环境的网络是隔离的，本地的监控工具根本连不上线上环境。并且类似于Jprofiler这样的商业工具，是需要付费的。</p>
<p>那么有没有一款工具不需要远程连接，也不需要配置监控参数，同时也提供了丰富的性能监控数据呢？</p>
<p>阿里巴巴开源的性能分析神器Arthas应运而生。</p>
<p>Arthas是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。Arthas 支持JDK 6＋，支持Linux／Mac／Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p>
<ul>
<li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li>
<li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li>
<li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li>
<li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li>
<li>是否有一个全局视角来查看系统的运行状况？</li>
<li>有什么办法可以监控到JVM的实时运行状态？</li>
<li>怎么快速定位应用的热点，生成火焰图？</li>
</ul>
<p>官方地址：<a href="https://arthas.aliyun.com/doc/quick-start.html" target="_blank" rel="noopener">https://arthas.aliyun.com/doc/quick-start.html</a></p>
<p>安装方式：如果速度较慢，可以尝试国内的码云Gitee下载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://io/arthas/arthas-boot.jar</span><br><span class="line">wget https://arthas/gitee/io/arthas-boot.jar</span><br></pre></td></tr></table></figure>

<p>Arthas只是一个java程序，所以可以直接用java -jar运行。</p>
<p>除了在命令行查看外，Arthas目前还支持 Web Console。在成功启动连接进程之后就已经自动启动,可以直接访问 <a href="http://127.0.0.1:8563/" target="_blank" rel="noopener">http://127.0.0.1:8563/</a> 访问，页面上的操作模式和控制台完全一样。</p>
<p><strong>基础指令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">quit/exit 退出当前 Arthas客户端，其他 Arthas喜户端不受影响</span><br><span class="line">stop/shutdown 关闭 Arthas服务端，所有 Arthas客户端全部退出</span><br><span class="line">help 查看命令帮助信息</span><br><span class="line">cat 打印文件内容，和linux里的cat命令类似</span><br><span class="line">echo 打印参数，和linux里的echo命令类似</span><br><span class="line">grep 匹配查找，和linux里的gep命令类似</span><br><span class="line">tee 复制标隹输入到标准输出和指定的文件，和linux里的tee命令类似</span><br><span class="line">pwd 返回当前的工作目录，和linux命令类似</span><br><span class="line">cs 清空当前屏幕区域</span><br><span class="line">session 查看当前会话的信息</span><br><span class="line">reset 重置增强类，将被 Arthas增强过的类全部还原, Arthas服务端关闭时会重置所有增强过的类</span><br><span class="line">version 输出当前目标Java进程所加载的 Arthas版本号</span><br><span class="line">history 打印命令历史</span><br><span class="line">keymap Arthas快捷键列表及自定义快捷键</span><br></pre></td></tr></table></figure>

<p><strong>jvm相关</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dashboard 当前系统的实时数据面板</span><br><span class="line">thread 查看当前JVM的线程堆栈信息</span><br><span class="line">jvm 查看当前JVM的信息</span><br><span class="line">sysprop 查看和修改JVM的系统属性</span><br><span class="line">sysem 查看JVM的环境变量</span><br><span class="line">vmoption 查看和修改JVM里诊断相关的option</span><br><span class="line">perfcounter 查看当前JVM的 Perf Counter信息</span><br><span class="line">logger 查看和修改logger</span><br><span class="line">getstatic 查看类的静态属性</span><br><span class="line">ognl 执行ognl表达式</span><br><span class="line">mbean 查看 Mbean的信息</span><br><span class="line">heapdump dump java heap，类似jmap命令的 heap dump功能</span><br></pre></td></tr></table></figure>

<p><strong>class/classloader相关</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sc 查看JVM已加载的类信息</span><br><span class="line">	-d 输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的Classloader等详细信息。如果一个类被多个Classloader所加载，则会出现多次</span><br><span class="line">	-E 开启正则表达式匹配，默认为通配符匹配</span><br><span class="line">	-f 输出当前类的成员变量信息（需要配合参数-d一起使用）</span><br><span class="line">	-X 指定输出静态变量时属性的遍历深度，默认为0，即直接使用toString输出</span><br><span class="line">sm 查看已加载类的方法信息</span><br><span class="line">	-d 展示每个方法的详细信息</span><br><span class="line">	-E 开启正则表达式匹配,默认为通配符匹配</span><br><span class="line">jad 反编译指定已加载类的源码</span><br><span class="line">mc 内存编译器，内存编译.java文件为.class文件</span><br><span class="line">retransform 加载外部的.class文件, retransform到JVM里</span><br><span class="line">redefine 加载外部的.class文件，redefine到JVM里</span><br><span class="line">dump dump已加载类的byte code到特定目录</span><br><span class="line">classloader 查看classloader的继承树，urts，类加载信息，使用classloader去getResource</span><br><span class="line">	-t 查看classloader的继承树</span><br><span class="line">	-l 按类加载实例查看统计信息</span><br><span class="line">	-c 用classloader对应的hashcode来查看对应的 Jar urls</span><br></pre></td></tr></table></figure>

<p><strong>monitor/watch/trace相关</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">monitor 方法执行监控，调用次数、执行时间、失败率</span><br><span class="line">	-c 统计周期，默认值为120秒</span><br><span class="line">watch 方法执行观测，能观察到的范围为：返回值、抛出异常、入参，通过编写groovy表达式进行对应变量的查看</span><br><span class="line">	-b 在方法调用之前观察(默认关闭)</span><br><span class="line">	-e 在方法异常之后观察(默认关闭)</span><br><span class="line">	-s 在方法返回之后观察(默认关闭)</span><br><span class="line">	-f 在方法结束之后(正常返回和异常返回)观察(默认开启)</span><br><span class="line">	-x 指定输岀结果的属性遍历深度,默认为0</span><br><span class="line">trace 方法内部调用路径,并输出方法路径上的每个节点上耗时</span><br><span class="line">	-n 执行次数限制</span><br><span class="line">stack 输出当前方法被调用的调用路径</span><br><span class="line">tt 方法执行数据的时空隧道,记录下指定方法每次调用的入参和返回信息,并能对这些不同的时间下调用进行观测</span><br></pre></td></tr></table></figure>

<p><strong>其他</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jobs 列出所有job</span><br><span class="line">kill 强制终止任务</span><br><span class="line">fg 将暂停的任务拉到前台执行</span><br><span class="line">bg 将暂停的任务放到后台执行</span><br><span class="line">grep 搜索满足条件的结果</span><br><span class="line">plaintext 将命令的结果去除ANSI颜色</span><br><span class="line">wc 按行统计输出结果</span><br><span class="line">options 查看或设置Arthas全局开关</span><br><span class="line">profiler 使用async-profiler对应用采样，生成火焰图</span><br></pre></td></tr></table></figure>

<h2 id="Java-Misssion-Control"><a href="#Java-Misssion-Control" class="headerlink" title="Java Misssion Control"></a>Java Misssion Control</h2><p>在Oracle收购Sun之前，Oracle的JRockit虚拟机提供了一款叫做 JRockit Mission Control 的虚拟机诊断工具。</p>
<p>在Oracle收购sun之后，Oracle公司同时拥有了Hotspot和 JRockit 两款虚拟机。根据Oracle对于Java的战略，在今后的发展中，会将JRokit的优秀特性移植到Hotspot上。其中一个重要的改进就是在Sun的JDK中加入了JRockit的支持。</p>
<p>在Oracle JDK 7u40之后，Mission Control这款工具己经绑定在Oracle JDK中发布。</p>
<p>自Java11开始，本节介绍的JFR己经开源。但在之前的Java版本，JFR属于Commercial Feature通过Java虚拟机参数-XX:+UnlockCommercialFeatures 开启。</p>
<p>Java Mission Control（简称JMC) ， Java官方提供的性能强劲的工具，是一个用于对 Java应用程序进行管理、监视、概要分析和故障排除的工具套件。它包含一个GUI客户端以及众多用来收集Java虚拟机性能数据的插件如 JMX Console（能够访问用来存放虚拟机齐个于系统运行数据的MXBeans）以及虚拟机内置的高效 profiling 工具 Java Flight Recorder（JFR）。</p>
<p>JMC的另一个优点就是：采用取样，而不是传统的代码植入技术，对应用性能的影响非常非常小，完全可以开着JMC来做压测（唯一影响可能是 full gc 多了）。 </p>
<p> 官方地址：<a href="https://github.com/JDKMissionControl/jmc" target="_blank" rel="noopener">https://github.com/JDKMissionControl/jmc</a></p>
<p>![Java Misssion Control.png](/images/java/jvm/Java Misssion Control.png)</p>
<p><strong>Java Flight Recorder</strong></p>
<p>Java Flight Recorder是JMC的其中一个组件，能够以极低的性能开销收集Java虚拟机的性能数据。与其他工具相比，JFR的性能开销很小，在默认配置下平均低于1%。JFR能够直接访问虚拟机内的敌据并且不会影响虚拟机的优化。因此它非常适用于生产环境下满负荷运行的Java程序。</p>
<p>Java Flight Recorder 和 JDK Mission Control共同创建了一个完整的工具链。JDK Mission Control 可对 Java Flight Recorder 连续收集低水平和详细的运行时信息进行高效、详细的分析。 </p>
<p>当启用时 JFR将记录运行过程中发生的一系列事件。其中包括Java层面的事件如线程事件、锁事件，以及Java虚拟机内部的事件，如新建对象，垃圾回收和即时编译事件。按照发生时机以及持续时间来划分，JFR的事件共有四种类型，它们分别为以下四种：</p>
<ul>
<li><p>瞬时事件（Instant Event) ，用户关心的是它们发生与否，例如异常、线程启动事件。</p>
</li>
<li><p>持续事件(Duration Event) ，用户关心的是它们的持续时间，例如垃圾回收事件。</p>
</li>
</ul>
<ul>
<li><p>计时事件(Timed Event) ，是时长超出指定阈值的持续事件。</p>
</li>
<li><p>取样事件（Sample Event)，是周期性取样的事件。</p>
</li>
</ul>
<p>取样事件的其中一个常见例子便是方法抽样（Method Sampling），即每隔一段时问统计各个线程的栈轨迹。如果在这些抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法 </p>
<p>![Java Flight Recorder.png](/images/java/jvm/Java Flight Recorder.png)</p>
<p>![Java Flight Recorder2.png](/images/java/jvm/Java Flight Recorder2.png)</p>
<p>![Java Flight Recorder3.png](/images/java/jvm/Java Flight Recorder3.png)</p>
<p>![Java Flight Recorder-线程.png](/images/java/jvm/Java Flight Recorder-线程.png)</p>
<p>![Java Flight Recorder-IO.png](/images/java/jvm/Java Flight Recorder-IO.png)</p>
<p>![Java Flight Recorder-系统.png](/images/java/jvm/Java Flight Recorder-系统.png)</p>
<p>![Java Flight Recorder-事件.png](/images/java/jvm/Java Flight Recorder-事件.png)</p>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p><strong>Flame Graphs（火焰图）</strong></p>
<p>在追求极致性能的场景下，了解你的程序运行过程中cpu在干什么很重要，火焰图就是一种非常直观的展示CPU在程序整个生命周期过程中时间分配的工具。火焰图对于现代的程序员不应该陌生，这个工具可以非常直观的显示出调用找中的CPU消耗瓶颈。</p>
<p>网上的关于Java火焰图的讲解大部分来自于Brenden Gregg的博客 <a href="http://new.brendangregg.com/flamegraphs.html" target="_blank" rel="noopener">http://new.brendangregg.com/flamegraphs.html </a></p>
<p>![Flame Graphs（火焰图）.png](/images/java/jvm/Flame Graphs（火焰图）.png)</p>
<p>火焰图，简单通过x轴横条宽度来度量时间指标，y轴代表线程栈的层次。</p>
<p><strong>Tprofiler</strong></p>
<p>案例： 使用JDK自身提供的工具进行JVM调优可以将下 TPS 由2.5提升到20（提升了7倍），并准确 定位系统瓶颈。</p>
<p>系统瓶颈有：应用里释态对象不是太多、有大量的业务线程在频繁创建一些生命周期很长的临时对象，代码里有问题。</p>
<p>那么，如何在海量业务代码里边准确定位这些性能代码？这里使用阿里开源工具 Tprofiler 来定位 这些性能代码，成功解决掉了GC 过于频繁的性能瓶预，并最终在上次优化的基础上将 TPS 再提升了4倍，即提升到100。</p>
<ul>
<li>Tprofiler配置部署、远程操作、 日志阅谈都不太复杂，操作还是很简单的。但是其却是能够 起到一针见血、立竿见影的效果，帮我们解决了GC过于频繁的性能瓶预。</li>
<li>Tprofiler最重要的特性就是能够统汁出你指定时间段内 JVM 的 top method 这些 top method 极有可能就是造成你 JVM 性能瓶颈的元凶。这是其他大多数 JVM 调优工具所不具备的，包括 JRockit Mission Control。JRokit 首席开发者 Marcus Hirt 在其私人博客《 Lom Overhead Method Profiling cith Java Mission Control》下的评论中曾明确指出  JRMC 井不支持 TOP 方法的统计。</li>
</ul>
<p>官方地址：<a href="http://github.com/alibaba/Tprofiler" target="_blank" rel="noopener">http://github.com/alibaba/Tprofiler</a></p>
<p><strong>Btrace</strong></p>
<p>常见的动态追踪工具有BTrace、HouseHD（该项目己经停止开发）、Greys-Anatomy（国人开发 个人开发者）、Byteman（JBoss出品），注意Java运行时追踪工具井不限干这几种，但是这几个是相对比较常用的。 </p>
<p>BTrace是SUN Kenai 云计算开发平台下的一个开源项目，旨在为java提供安全可靠的动态跟踪分析工具。</p>
<p>是一个 Java 平台的安全的动态追踪工具，可以用来动态地追踪一个运行的 Java 程序。BTrace动态调整目标应用程序的类以注入跟踪代码（“字节码跟踪“）。</p>
<p><strong>YourKit</strong></p>
<p><strong>JProbe</strong></p>
<p><strong>Spring Insight</strong></p>
<h1 id="JVM运行时参数"><a href="#JVM运行时参数" class="headerlink" title="JVM运行时参数"></a>JVM运行时参数</h1><h2 id="JVM参数选项"><a href="#JVM参数选项" class="headerlink" title="JVM参数选项"></a>JVM参数选项</h2><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p>
<h3 id="类型一：标准参数选项"><a href="#类型一：标准参数选项" class="headerlink" title="类型一：标准参数选项"></a>类型一：标准参数选项</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> java -<span class="built_in">help</span></span></span><br><span class="line">用法: java [-options] class [args...]</span><br><span class="line">           (执行类)</span><br><span class="line">   或  java [-options] -jar jarfile [args...]</span><br><span class="line">           (执行 jar 文件)</span><br><span class="line">其中选项包括:</span><br><span class="line">    -d32          使用 32 位数据模型 (如果可用)</span><br><span class="line">    -d64          使用 64 位数据模型 (如果可用)</span><br><span class="line">    -server       选择 "server" VM</span><br><span class="line">                  默认 VM 是 server.</span><br><span class="line"></span><br><span class="line">    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">                  用 ; 分隔的目录, JAR 档案</span><br><span class="line">                  和 ZIP 档案列表, 用于搜索类文件。</span><br><span class="line">    -D&lt;名称&gt;=&lt;值&gt;</span><br><span class="line">                  设置系统属性</span><br><span class="line">    -verbose:[class|gc|jni]</span><br><span class="line">                  启用详细输出</span><br><span class="line">    -version      输出产品版本并退出</span><br><span class="line">    -version:&lt;值&gt;</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  需要指定的版本才能运行</span><br><span class="line">    -showversion  输出产品版本并继续</span><br><span class="line">    -jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  在版本搜索中包括/排除用户专用 JRE</span><br><span class="line">    -? -help      输出此帮助消息</span><br><span class="line">    -X            输出非标准选项的帮助</span><br><span class="line">    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  按指定的粒度启用断言</span><br><span class="line">    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  禁用具有指定粒度的断言</span><br><span class="line">    -esa | -enablesystemassertions</span><br><span class="line">                  启用系统断言</span><br><span class="line">    -dsa | -disablesystemassertions</span><br><span class="line">                  禁用系统断言</span><br><span class="line">    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">                  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help</span><br><span class="line">    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  按完整路径名加载本机代理库</span><br><span class="line">    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br><span class="line">    -splash:&lt;imagepath&gt;</span><br><span class="line">                  使用指定的图像显示启动屏幕</span><br><span class="line">有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。</span><br></pre></td></tr></table></figure>

<p><strong>Server模式和Client模式</strong></p>
<p>Hotspot JVM有两种模式，分别是server和client，分别通过-server和-client模式设置</p>
<ul>
<li>32位系统上，默认使用Client类型的JVM。要想使用Server模式，机器配置至少有2个以上的CPU和2G以上的物理内存。client模式适用于对内存要求较小的桌面应用程序，默认使用Serial串行垃圾收集器</li>
<li>64位系统上，只支持server模式的JVM，适用于需要大内存的应用程序，默认使用并行垃圾收集器</li>
</ul>
<p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html</a></p>
<p>如何知道系统默认使用的是那种模式呢？</p>
<p>通过java -version命令：可以看到Server VM字样，代表当前系统使用是Server模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> java -version</span></span><br><span class="line">java version "1.8.0_201"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_201-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</span><br></pre></td></tr></table></figure>

<h3 id="类型二：-X参数选项"><a href="#类型二：-X参数选项" class="headerlink" title="类型二：-X参数选项"></a>类型二：-X参数选项</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> java -X</span></span><br><span class="line">    -Xmixed           混合模式执行 (默认)</span><br><span class="line">    -Xint             仅解释模式执行</span><br><span class="line">    -Xbootclasspath:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      设置搜索路径以引导类和资源</span><br><span class="line">    -Xbootclasspath/a:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      附加在引导类路径末尾</span><br><span class="line">    -Xbootclasspath/p:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      置于引导类路径之前</span><br><span class="line">    -Xdiag            显示附加诊断消息</span><br><span class="line">    -Xnoclassgc       禁用类垃圾收集</span><br><span class="line">    -Xincgc           启用增量垃圾收集</span><br><span class="line">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)</span><br><span class="line">    -Xbatch           禁用后台编译</span><br><span class="line">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class="line">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class="line">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class="line">    -Xprof            输出 cpu 配置文件数据</span><br><span class="line">    -Xfuture          启用最严格的检查, 预期将来的默认值</span><br><span class="line">    -Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)</span><br><span class="line">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class="line">    -Xshare:off       不尝试使用共享类数据</span><br><span class="line">    -Xshare:auto      在可能的情况下使用共享类数据 (默认)</span><br><span class="line">    -Xshare:on        要求使用共享类数据, 否则将失败。</span><br><span class="line">    -XshowSettings    显示所有设置并继续</span><br><span class="line">    -XshowSettings:all</span><br><span class="line">                      显示所有设置并继续</span><br><span class="line">    -XshowSettings:vm 显示所有与 vm 相关的设置并继续</span><br><span class="line">    -XshowSettings:properties</span><br><span class="line">                      显示所有属性设置并继续</span><br><span class="line">    -XshowSettings:locale</span><br><span class="line">                      显示所有与区域设置相关的设置并继续</span><br><span class="line"></span><br><span class="line">-X 选项是非标准选项, 如有更改, 恕不另行通知。</span><br></pre></td></tr></table></figure>

<p>如何知道JVM默认使用的是混合模式呢？</p>
<p>同样地，通过java -version命令：可以看到 mixed mode 字样，代表当前系统使用的是混合模式</p>
<h3 id="类型三：-XX参数选项"><a href="#类型三：-XX参数选项" class="headerlink" title="类型三：-XX参数选项"></a>类型三：-XX参数选项</h3><p><strong>Boolean类型格式</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+&lt;option&gt;  启用option属性</span><br><span class="line">-XX:-&lt;option&gt;  禁用option属性</span><br></pre></td></tr></table></figure>

<p><strong>非Boolean类型格式</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:&lt;option&gt;=&lt;number&gt;  设置option数值，可以带单位如k/K/m/M/g/G</span><br><span class="line">-XX:&lt;option&gt;=&lt;string&gt;  设置option字符值</span><br></pre></td></tr></table></figure>

<h2 id="添加JVM参数选项"><a href="#添加JVM参数选项" class="headerlink" title="添加JVM参数选项"></a>添加JVM参数选项</h2><p>eclipse和idea中配置不必多说，在Run Configurations中VM Options中配置即可，大同小异</p>
<p><strong>运行jar包</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Xms100m -Xmx100m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -jar demo.jar</span><br></pre></td></tr></table></figure>

<p><strong>Tomcat运行war包</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> linux下catalina.sh添加</span></span><br><span class="line">JAVA_OPTS="-Xms512M -Xmx1024M"</span><br><span class="line"><span class="meta">#</span><span class="bash"> windows下catalina.bat添加</span></span><br><span class="line">set "JAVA_OPTS=-Xms512M -Xmx1024M"</span><br></pre></td></tr></table></figure>

<p><strong>程序运行中</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置Boolean类型参数</span></span><br><span class="line">jinfo -flag [+|-]&lt;name&gt; &lt;pid&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置非Boolean类型参数</span></span><br><span class="line">jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<h2 id="常用的JVM参数选项"><a href="#常用的JVM参数选项" class="headerlink" title="常用的JVM参数选项"></a>常用的JVM参数选项</h2><h3 id="打印设置的XX选项及值"><a href="#打印设置的XX选项及值" class="headerlink" title="打印设置的XX选项及值"></a>打印设置的XX选项及值</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags 程序运行时JVM默认设置或用户手动设置的XX选项</span><br><span class="line">-XX:+PrintFlagsInitial 打印所有XX选项的默认值</span><br><span class="line">-XX:+PrintFlagsFinal 打印所有XX选项的实际值</span><br><span class="line">-XX:+PrintVMOptions 打印JVM的参数</span><br></pre></td></tr></table></figure>

<h3 id="堆、栈、方法区等内存大小设置"><a href="#堆、栈、方法区等内存大小设置" class="headerlink" title="堆、栈、方法区等内存大小设置"></a>堆、栈、方法区等内存大小设置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 栈</span></span><br><span class="line">-Xss128k &lt;==&gt; -XX:ThreadStackSize=128k 设置线程栈的大小为128K</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 堆</span></span><br><span class="line">-Xms2048m &lt;==&gt; -XX:InitialHeapSize=2048m 设置JVM初始堆内存为2048M</span><br><span class="line">-Xmx2048m &lt;==&gt; -XX:MaxHeapSize=2048m 设置JVM最大堆内存为2048M</span><br><span class="line">-Xmn2g &lt;==&gt; -XX:NewSize=2g -XX:MaxNewSize=2g 设置年轻代大小为2G</span><br><span class="line">-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8</span><br><span class="line">-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2</span><br><span class="line">-XX:+UseAdaptiveSizePolicy 设置大小比例自适应，默认开启</span><br><span class="line">-XX:PretenureSizeThreadshold=1024 设置让大于此阈值的对象直接分配在老年代，只对Serial、ParNew收集器有效</span><br><span class="line">-XX:MaxTenuringThreshold=15 设置新生代晋升老年代的年龄限制，默认为15</span><br><span class="line">-XX:TargetSurvivorRatio 设置MinorGC结束后Survivor区占用空间的期望比例</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法区</span></span><br><span class="line">-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M</span><br><span class="line">-XX:MaxMetaspaceSize / -XX:MaxPermSize=256m 设置元空间/永久代最大值为256M</span><br><span class="line">-XX:+UseCompressedOops 使用压缩对象</span><br><span class="line">-XX:+UseCompressedClassPointers 使用压缩类指针</span><br><span class="line">-XX:CompressedClassSpaceSize 设置Klass Metaspace的大小，默认1G</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接内存</span></span><br><span class="line">-XX:MaxDirectMemorySize 指定DirectMemory容量，默认等于Java堆最大值</span><br></pre></td></tr></table></figure>

<h3 id="OutOfMemory相关的选项"><a href="#OutOfMemory相关的选项" class="headerlink" title="OutOfMemory相关的选项"></a>OutOfMemory相关的选项</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件，两者互斥</span><br><span class="line">-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件，两者互斥</span><br><span class="line">-XX:HeapDumpPath=&lt;path&gt; 指定heap转储文件的存储路径，默认当前目录</span><br><span class="line">-XX:OnOutOfMemoryError=&lt;path&gt; 指定可行性程序或脚本的路径，当发生OOM时执行脚本</span><br></pre></td></tr></table></figure>

<h3 id="垃圾收集器相关选项"><a href="#垃圾收集器相关选项" class="headerlink" title="垃圾收集器相关选项"></a>垃圾收集器相关选项</h3><p>首先需了解垃圾收集器之间的搭配使用关系</p>
<ul>
<li>红色虚线表示在jdk8时被Deprecate，jdk9时被删除</li>
<li>绿色虚线表示在jdk14时被Deprecate</li>
<li>绿色虚框表示在jdk9时被Deprecate，jdk14时被删除</li>
</ul>
<p><img src="/images/java/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png" alt="垃圾收集器的组合关系.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Serial回收器</span></span><br><span class="line">-XX:+UseSerialGC  年轻代使用Serial GC， 老年代使用Serial Old GC</span><br><span class="line"><span class="meta">#</span><span class="bash"> ParNew回收器</span></span><br><span class="line">-XX:+UseParNewGC  年轻代使用ParNew GC</span><br><span class="line">-XX:ParallelGCThreads  设置年轻代并行收集器的线程数。</span><br><span class="line">	一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</span><br></pre></td></tr></table></figure>

<p>$$<br>ParallelGCThreads =<br>\begin{cases}<br>CPU_Count &amp; \text (CPU_Count &lt;= 8) \<br>3 + (5 * CPU＿Count / 8) &amp; \text (CPU_Count &gt; 8)<br>\end{cases}<br>$$</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Parallel回收器</span></span><br><span class="line">-XX:+UseParallelGC  年轻代使用 Parallel Scavenge GC，互相激活</span><br><span class="line">-XX:+UseParallelOldGC  老年代使用 Parallel Old GC，互相激活</span><br><span class="line">-XX:ParallelGCThreads</span><br><span class="line">-XX:MaxGCPauseMillis  设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒。</span><br><span class="line">	为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</span><br><span class="line">	对于用户来讲，停顿时间越短体验越好；但是服务器端注重高并发，整体的吞吐量。</span><br><span class="line">	所以服务器端适合Parallel，进行控制。该参数使用需谨慎。</span><br><span class="line">-XX:GCTimeRatio  垃圾收集时间占总时间的比例（1 / (N＋1)），用于衡量吞吐量的大小</span><br><span class="line">	取值范围（0,100），默认值99，也就是垃圾回收时间不超过1％。</span><br><span class="line">	与前一个-XX：MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</span><br><span class="line">-XX:+UseAdaptiveSizePolicy  设置Parallel Scavenge收集器具有自适应调节策略。</span><br><span class="line">	在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。</span><br><span class="line">	在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CMS回收器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC  年轻代使用CMS GC。</span><br><span class="line">	开启该参数后会自动将-XX：＋UseParNewGC打开。即：ParNew（Young区）+ CMS（Old区）+ Serial Old的组合</span><br><span class="line">-XX:CMSInitiatingOccupanyFraction  设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68，DK6及以上版本默认值为92％。</span><br><span class="line">	如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。</span><br><span class="line">	反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。</span><br><span class="line">	因此通过该选项便可以有效降低Fu1l GC的执行次数。</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly  是否动态可调，使CMS一直按CMSInitiatingOccupancyFraction设定的值启动</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection  用于指定在执行完Full GC后对内存空间进行压缩整理</span><br><span class="line">	以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction  设置在执行多少次Full GC后对内存空间进行压缩整理。</span><br><span class="line">-XX:ParallelCMSThreads  设置CMS的线程数量。</span><br><span class="line">	CMS 默认启动的线程数是(ParallelGCThreads＋3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。</span><br><span class="line">	当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</span><br><span class="line">-XX:ConcGCThreads  设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的</span><br><span class="line">-XX:+CMSScavengeBeforeRemark  强制hotspot在cms remark阶段之前做一次minor gc，用于提高remark阶段的速度</span><br><span class="line">-XX:+CMSClassUnloadingEnable  如果有的话，启用回收Perm 区（JDK8之前）</span><br><span class="line">-XX:+CMSParallelInitialEnabled  用于开启CMS initial-mark阶段采用多线程的方式进行标记</span><br><span class="line">	用于提高标记速度，在Java8开始已经默认开启</span><br><span class="line">-XX:+CMSParallelRemarkEnabled  用户开启CMS remark阶段采用多线程的方式进行重新标记，默认开启</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrent</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</span><br><span class="line">	这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期</span><br><span class="line">-XX:+CMSPrecleaningEnabled  指定CMS是否需要进行Pre cleaning阶段</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> G1回收器</span></span><br><span class="line">-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务。</span><br><span class="line">-XX:G1HeapRegionSize 设置每个Region的大小。</span><br><span class="line">	值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</span><br><span class="line">-XX:MaxGCPauseMillis  设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</span><br><span class="line">-XX:ParallelGCThread  设置STW时GC线程数的值。最多设置为8</span><br><span class="line">-XX:ConcGCThreads  设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</span><br><span class="line">-XX:G1NewSizePercent  新生代占用整个堆内存的最小百分比（默认5％）</span><br><span class="line">-XX:G1MaxNewSizePercent  新生代占用整个堆内存的最大百分比（默认60％）</span><br><span class="line">-XX:G1ReservePercent=10  保留内存区域，防止 to space（Survivor中的to区）溢出</span><br></pre></td></tr></table></figure>

<p>怎么选择垃圾回收器？</p>
<ul>
<li>优先让JVM自适应，调整堆的大小</li>
<li>串行收集器：内存小于100M；单核、单机程序，并且没有停顿时间的要求</li>
<li>并行收集器：多CPU、高吞吐量、允许停顿时间超过1秒</li>
<li>并发收集器：多CPU、追求低停顿时间、快速响应（比如延迟不能超过1秒，如互联网应用）</li>
<li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1</li>
</ul>
<p>特别说明：</p>
<ul>
<li>没有最好的收集器，更没有万能的收集器</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ul>
<h3 id="GC日志相关选项"><a href="#GC日志相关选项" class="headerlink" title="GC日志相关选项"></a>GC日志相关选项</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGC &lt;==&gt; -verbose:gc  打印简要日志信息</span><br><span class="line">-XX:+PrintGCDetails            打印详细日志信息</span><br><span class="line">-XX:+PrintGCTimeStamps  打印程序启动到GC发生的时间，搭配-XX:+PrintGCDetails使用</span><br><span class="line">-XX:+PrintGCDateStamps  打印GC发生时的时间戳，搭配-XX:+PrintGCDetails使用</span><br><span class="line">-XX:+PrintHeapAtGC  打印GC前后的堆信息，如下图</span><br><span class="line">-Xloggc:&lt;file&gt; 输出GC导指定路径下的文件中</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+TraceClassLoading  监控类的加载</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime  打印GC时线程的停顿时间</span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime  打印垃圾收集之前应用未中断的执行时间</span><br><span class="line">-XX:+PrintReferenceGC 打印回收了多少种不同引用类型的引用</span><br><span class="line">-XX:+PrintTenuringDistribution  打印JVM在每次MinorGC后当前使用的Survivor中对象的年龄分布</span><br><span class="line">-XX:+UseGCLogFileRotation 启用GC日志文件的自动转储</span><br><span class="line">-XX:NumberOfGCLogFiles=1  设置GC日志文件的循环数目</span><br><span class="line">-XX:GCLogFileSize=1M  设置GC日志文件的大小</span><br></pre></td></tr></table></figure>

<h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+DisableExplicitGC  禁用hotspot执行System.gc()，默认禁用</span><br><span class="line">-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]、-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]  指定代码缓存的大小</span><br><span class="line">-XX:+UseCodeCacheFlushing  放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况</span><br><span class="line">-XX:+DoEscapeAnalysis  开启逃逸分析</span><br><span class="line">-XX:+UseBiasedLocking  开启偏向锁</span><br><span class="line">-XX:+UseLargePages  开启使用大页面</span><br><span class="line">-XX:+PrintTLAB  打印TLAB的使用情况</span><br><span class="line">-XX:TLABSize  设置TLAB大小</span><br></pre></td></tr></table></figure>

<h2 id="通过Java代码获取JVM参数"><a href="#通过Java代码获取JVM参数" class="headerlink" title="通过Java代码获取JVM参数"></a>通过Java代码获取JVM参数</h2><p>Java提供了java.lang.management包用于监视和管理Java虚拟机和Java运行时中的其他组件，它允许本地或远程监控和管理运行的Java虚拟机。其中ManagementFactory类较为常用，另外Runtime类可获取内存、CPU核数等相关的数据。通过使用这些api，可以监控应用服务器的堆内存使用情况，设置一些阈值进行报警等处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MemoryMonitor &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MemoryMXBean memorymbean &#x3D; ManagementFactory.getMemoryMXBean();</span><br><span class="line">        MemoryUsage usage &#x3D; memorymbean.getHeapMemoryUsage();</span><br><span class="line">        System.out.println(&quot;INIT HEAP: &quot; + usage.getInit() &#x2F; 1024 &#x2F; 1024 + &quot;m&quot;);</span><br><span class="line">        System.out.println(&quot;MAX HEAP: &quot; + usage.getMax() &#x2F; 1024 &#x2F; 1024 + &quot;m&quot;);</span><br><span class="line">        System.out.println(&quot;USE HEAP: &quot; + usage.getUsed() &#x2F; 1024 &#x2F; 1024 + &quot;m&quot;);</span><br><span class="line">        System.out.println(&quot;\nFull Information:&quot;);</span><br><span class="line">        System.out.println(&quot;Heap Memory Usage: &quot; + memorymbean.getHeapMemoryUsage());</span><br><span class="line">        System.out.println(&quot;Non-Heap Memory Usage: &quot; + memorymbean.getNonHeapMemoryUsage());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;通过java来获取相关系统状态&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;);</span><br><span class="line">        System.out.println(&quot;当前堆内存大小totalMemory &quot; + (int) Runtime.getRuntime().totalMemory() &#x2F; 1024 &#x2F; 1024 + &quot;m&quot;);&#x2F;&#x2F; 当前堆内存大小</span><br><span class="line">        System.out.println(&quot;空闲堆内存大小freeMemory &quot; + (int) Runtime.getRuntime().freeMemory() &#x2F; 1024 &#x2F; 1024 + &quot;m&quot;);&#x2F;&#x2F; 空闲堆内存大小</span><br><span class="line">        System.out.println(&quot;最大可用总堆内存maxMemory &quot; + Runtime.getRuntime().maxMemory() &#x2F; 1024 &#x2F; 1024 + &quot;m&quot;);&#x2F;&#x2F; 最大可用总堆内存大小</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分析GC日志"><a href="#分析GC日志" class="headerlink" title="分析GC日志"></a>分析GC日志</h1><h2 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h2><p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p>
<ul>
<li><p>部分收集（Partial GC）：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li>新生代收集（Minor GC / Young GC）：只是新生代（Eden / S0, S1）的垃圾收集</li>
<li>老年代收集（Major GC / Old GC）：只是老年代的垃圾收集。目前，只有CMS GC会有单独收集老年代的行为。<mark>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</mark></li>
</ul>
</li>
<li><p>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</p>
</li>
<li><p>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。</p>
</li>
</ul>
<h2 id="GC日志分类"><a href="#GC日志分类" class="headerlink" title="GC日志分类"></a>GC日志分类</h2><p><strong>MinorGC</strong></p>
<p>MinorGC（或young GC或YGC）日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">31744</span>K-&gt;<span class="number">2192</span>K (<span class="number">36864</span>K) ] <span class="number">31744</span>K-&gt;<span class="number">2200</span>K (<span class="number">121856</span>K), <span class="number">0.0139308</span> secs] [Times: user=<span class="number">0.05</span> sys=<span class="number">0.01</span>, real=<span class="number">0.01</span> secs]</span><br></pre></td></tr></table></figure>

<p>![Young GC日志分析.png](/images/java/jvm/Young GC日志分析.png)</p>
<p><strong>FullGC</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span> [PSYoungGen: 5104K-&gt;0<span class="title">K</span> <span class="params">(<span class="number">132096</span>K)</span> ] [Par01dGen: 416K-&gt;5453<span class="title">K</span> <span class="params">(<span class="number">50176</span>K)</span> ]5520K-&gt;5453<span class="title">K</span> <span class="params">(<span class="number">182272</span>K)</span>, [Metaspace: 20637K-&gt;20637<span class="title">K</span> <span class="params">(<span class="number">1067008</span>K)</span> ], 0.0245883 secs] [Times: user</span>=<span class="number">0.06</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></table></figure>

<p>![Full GC日志分析.png](/images/java/jvm/Full GC日志分析.png)</p>
<h2 id="GC日志结构剖析"><a href="#GC日志结构剖析" class="headerlink" title="GC日志结构剖析"></a>GC日志结构剖析</h2><p><strong>透过日志看垃圾收集器</strong></p>
<ul>
<li><p>Serial收集器：新生代显示 “[DefNew”，即 Default New Generation</p>
</li>
<li><p>ParNew收集器：新生代显示 “[ParNew”，即 Parallel New Generation</p>
</li>
<li><p>Parallel Scavenge收集器：新生代显示”[PSYoungGen”，JDK1.7使用的即PSYoungGen</p>
</li>
<li><p>Parallel Old收集器：老年代显示”[ParoldGen”</p>
</li>
<li><p>G1收集器：显示”garbage-first heap“</p>
</li>
</ul>
<p><strong>透过日志看GC原因</strong></p>
<ul>
<li>Allocation Failure：表明本次引起GC的原因是因为新生代中没有足够的区域存放需要分配的数据</li>
<li>Metadata GCThreshold：Metaspace区不够用了</li>
<li>FErgonomics：JVM自适应调整导致的GC</li>
<li>System：调用了System.gc()方法</li>
</ul>
<p><strong>透过日志看GC前后情况</strong></p>
<p>通过图示，我们可以发现GC日志格式的规律一般都是：GC前内存占用-＞GC后内存占用（该区域内存总大小）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[PSYoungGen: <span class="number">5986</span>K-&gt;<span class="number">696</span>K (<span class="number">8704</span>K) ] <span class="number">5986</span>K-&gt;<span class="number">704</span>K (<span class="number">9216</span>K)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>中括号内：GC回收前年轻代堆大小，回收后大小，（年轻代堆总大小）</p>
</li>
<li><p>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p>
</li>
</ul>
<p><mark>注意</mark>：Minor GC堆内存总容量 = 9/10 年轻代 + 老年代。原因是Survivor区只计算from部分，而JVM默认年轻代中Eden区和Survivor区的比例关系，Eden:S0:S1=8:1:1。</p>
<p><strong>透过日志看GC时间</strong></p>
<p>GC日志中有三个时间：user，sys和real</p>
<ul>
<li>user：进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际CPU 时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示GC线程执行所使用的 CPU 总时间。</li>
<li>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的CPU 时间</li>
<li>real：程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I/O 完成）。对于并行gc，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数。</li>
</ul>
<p>由于多核的原因，一般的GC事件中，real time是小于sys time＋user time的，因为一般是多个线程并发的去做GC，所以real time是要小于sys＋user time的。如果real＞sys＋user的话，则你的应用可能存在下列问题：IO负载非常重或CPU不够用。</p>
<h2 id="GC日志分析工具"><a href="#GC日志分析工具" class="headerlink" title="GC日志分析工具"></a>GC日志分析工具</h2><p><strong>GCEasy</strong></p>
<p>GCEasy是一款在线的GC日志分析器，可以通过GC日志分析进行内存泄露检测、GC暂停原因分析、JVM配置建议优化等功能，大多数功能是免费的。</p>
<p>官网地址：<a href="https://gceasy.io/" target="_blank" rel="noopener">https://gceasy.io/</a></p>
<p><strong>GCViewer</strong></p>
<p>GCViewer是一款离线的GC日志分析器，用于可视化Java VM选项 -verbose:gc 和 .NET生成的数据 -Xloggc:&lt;file&gt;。还可以计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等）。当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用。</p>
<p>源码下载：<a href="https://github.com/chewiebug/GCViewer" target="_blank" rel="noopener">https://github.com/chewiebug/GCViewer</a></p>
<p>运行版本下载：<a href="https://github.com/chewiebug/GCViewer/wiki/Changelog" target="_blank" rel="noopener">https://github.com/chewiebug/GCViewer/wiki/Changelog</a></p>
<p><strong>GChisto</strong></p>
<ul>
<li>官网上没有下载的地方，需要自己从SVN上拉下来编译</li>
<li>不过这个工具似乎没怎么维护了，存在不少bug</li>
</ul>
<p><strong>HPjmeter</strong></p>
<ul>
<li>工具很强大，但是只能打开由以下参数生成的GC log，-verbose:gc  -Xloggc:gc.log。添加其他参数生成的gc.log无法打开</li>
<li>HPjmeter集成了以前的HPjtune功能，可以分析在HP机器上产生的垃圾回收日志文件</li>
</ul>
<h1 id="补充：使用OQL语言查询对象信息"><a href="#补充：使用OQL语言查询对象信息" class="headerlink" title="补充：使用OQL语言查询对象信息"></a>补充：使用OQL语言查询对象信息</h1><p>MAT支持一种类似于SQL的查询语言OQL（Object Query Language）。OQL使用类SQL语法，可以在堆中进行对象的查找和筛选。</p>
<h2 id="SELECT子句"><a href="#SELECT子句" class="headerlink" title="SELECT子句"></a>SELECT子句</h2><p>在MAT中，Select子句的格式与SQL基本一致，用于指定要显示的列。Select子句中可以使用“＊”，查看结果对象的引用实例（相当于outgoing references）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> java.util.Vector v</span><br></pre></td></tr></table></figure>

<p>使用“OBJECTS”关键字，可以将返回结果集中的项以对象的形式显示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> objects v.elementData <span class="keyword">FROM</span> java.util.Vector v</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> OBJECTS s.value <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></table></figure>

<p>在Select子句中，使用“AS RETAINED SET”关键字可以得到所得对象的保留集。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AS</span> RETAINED <span class="keyword">SET</span> *<span class="keyword">FROM</span> com.atguigu.mat.Student</span><br></pre></td></tr></table></figure>

<p>“DISTINCT”关键字用于在结果集中去除重复对象。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> OBJECTS classof(s) <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></table></figure>

<h2 id="FROM子句"><a href="#FROM子句" class="headerlink" title="FROM子句"></a>FROM子句</h2><p>From子句用于指定查询范围，它可以指定类名、正则表达式或者对象地址。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></table></figure>

<p>使用正则表达式，限定搜索范围，输出所有com.atguigu包下所有类的实例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">"com\.atguigu\..*"</span></span><br></pre></td></tr></table></figure>

<p>使用类的地址进行搜索。使用类的地址的好处是可以区分被不同ClassLoader加载的同一种类型。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="number">0x37a0b4d</span></span><br></pre></td></tr></table></figure>

<h2 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h2><p>Where子句用于指定OQL的查询条件。OQL查询将只返回满足Where子句指定条件的对象。Where子句的格式与传统SQL极为相似。</p>
<p>返回长度大于10的char数组。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> Ichar[] s <span class="keyword">WHERE</span> s.@<span class="keyword">length</span>&gt;<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>返回包含“java”子字符串的所有字符串，使用“LIKE”操作符，“LIKE”操作符的操作参数为正则表达式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> java.lang.String s <span class="keyword">WHERE</span> toString(s) <span class="keyword">LIKE</span> <span class="string">".*java.*"</span></span><br></pre></td></tr></table></figure>

<p>返回所有value域不为null的字符串，使用“＝”操作符。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> java.lang.String s <span class="keyword">where</span> s.value!=<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>返回数组长度大于15，并且深堆大于1000字节的所有Vector对象。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> java.util.Vector v <span class="keyword">WHERE</span> v.elementData.@<span class="keyword">length</span>&gt;<span class="number">15</span> <span class="keyword">AND</span> v.@retainedHeapSize&gt;<span class="number">1000</span></span><br></pre></td></tr></table></figure>

<h2 id="内置对象与方法"><a href="#内置对象与方法" class="headerlink" title="内置对象与方法"></a>内置对象与方法</h2><p>OQL中可以访问堆内对象的属性，也可以访问堆内代理对象的属性。访问堆内对象的属性时，格式如下，其中alias为对象名称：</p>
<p>[ &lt;alias&gt;. ] &lt;field&gt; . &lt;field&gt;. &lt;field&gt;</p>
<p>访问java.io.File对象的path属性，并进一步访问path的value属性：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> toString(f.path.value) <span class="keyword">FROM</span> java.io.File f</span><br></pre></td></tr></table></figure>

<p>显示String对象的内容、objectid和objectAddress。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.toString(),s.@objectId, s.@objectAddress <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></table></figure>

<p>显示java.util.Vector内部数组的长度。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> v.elementData.@<span class="keyword">length</span> <span class="keyword">FROM</span> java.util.Vector v</span><br></pre></td></tr></table></figure>

<p>显示所有的java.util.Vector对象及其子类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> INSTANCEOF java.util.Vector</span><br></pre></td></tr></table></figure>

<h1 id="补充：浅堆深堆与内存泄露"><a href="#补充：浅堆深堆与内存泄露" class="headerlink" title="补充：浅堆深堆与内存泄露"></a>补充：浅堆深堆与内存泄露</h1><h2 id="浅堆（Shallow-Heap）"><a href="#浅堆（Shallow-Heap）" class="headerlink" title="浅堆（Shallow Heap）"></a>浅堆（Shallow Heap）</h2><p>浅堆是指一个对象所消耗的内存。在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。根据堆快照格式不同，对象的大小可能会同8字节进行对齐。</p>
<p>以String为例：2个int值共占8字节，对象引用占用4字节，对象头8字节，合计20字节，向8字节对齐，故占24字节。（jdk7中）</p>
<table>
<thead>
<tr>
<th>int</th>
<th>hash32</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td><strong>int</strong></td>
<td><strong>hash</strong></td>
<td><strong>0</strong></td>
</tr>
<tr>
<td><strong>ref</strong></td>
<td><strong>value</strong></td>
<td><strong>C:\Users\Administrat</strong></td>
</tr>
</tbody></table>
<p>这24字节为String对象的浅堆大小。它与String的value实际取值无关，无论字符串长度如何，浅堆大小始终是24字节。</p>
<h2 id="保留集（Retained-Set）"><a href="#保留集（Retained-Set）" class="headerlink" title="保留集（Retained Set）"></a>保留集（Retained Set）</h2><p>对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合（包括对象A本身），即对象A的保留集可以被认为是只能通过对象A被直接或间接访问到的所有对象的集合。通俗地说，就是指仅被对象A所持有的对象的集合。</p>
<h2 id="深堆（Retained-Heap）"><a href="#深堆（Retained-Heap）" class="headerlink" title="深堆（Retained Heap）"></a>深堆（Retained Heap）</h2><p>深堆是指对象的保留集中所有的对象的浅堆大小之和。</p>
<p>注意：浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。</p>
<h2 id="对象的实际大小"><a href="#对象的实际大小" class="headerlink" title="对象的实际大小"></a>对象的实际大小</h2><p>这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，但实际上，这个概念和垃圾回收无关。</p>
<p>下图显示了一个简单的对象引用关系图，对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。</p>
<p><img src="/images/java/jvm/%E6%B5%85%E5%A0%86%E6%B7%B1%E5%A0%86%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.png" alt="浅堆深堆案例分析.png"></p>
<h2 id="支配树（Dominator-Tree）"><a href="#支配树（Dominator-Tree）" class="headerlink" title="支配树（Dominator Tree）"></a>支配树（Dominator Tree）</h2><p>支配树的概念源自图论。MAT提供了一个称为支配树（Dominator Tree）的对象图。支配树体现了对象实例间的支配关系。在对象引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B。如果对象A是离对象B最近的一个支配对象，则认为对象A为对象B的直接支配者。支配树是基于对象间的引用图所建立的，它有以下基本性质：</p>
<ul>
<li>对象A的子树（所有被对象A支配的对象集合）表示对象A的保留集（retained set），即深堆。</li>
<li>如果对象A支配对象B，那么对象A的直接支配者也支配对象B。</li>
<li>支配树的边与对象引用图的边不直接对应。</li>
</ul>
<p>如下图所示：左图表示对象引用图，右图表示左图所对应的支配树。对象A和B由根对象直接支配，由于在到对象C的路径中，可以经过A，也可以经过B，因此对象C的直接支配者也是根对象。对象F与对象D相互引用，因为到对象F的所有路径必然经过对象D，因此，对象D是对象F的直接支配者。而到对象D的所有路径中，必然经过对象C，即使是从对象F到对象D的引用，从根节点出发，也是经过对象C的，所以，对象D的直接支配者为对象C。同理，对象E支配对象G。到达对象H的可以通过对象D，也可以通过对象E，因此对象D和E都不能支配对象H，而经过对象C既可以到达D也可以到达E，因此对象C为对象H的直接支配者。</p>
<p><img src="/images/java/jvm/%E6%94%AF%E9%85%8D%E6%A0%91.png" alt="支配树.png"></p>
<h2 id="内存泄漏（memory-leak）"><a href="#内存泄漏（memory-leak）" class="headerlink" title="内存泄漏（memory leak）"></a>内存泄漏（memory leak）</h2><p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题（让JVM误以为此对象还在引用中，无法回收，造成内存泄漏）。</p>
<p>＞ 是否还被使用？是</p>
<p>＞ 是否还被需要？否</p>
<p><img src="/images/java/jvm/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.png" alt="内存泄漏.png"></p>
<p>严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致00M，也可以叫做宽泛意义上的“内存泄漏”。</p>
<p>如下图，当Y生命周期结束的时候，X依然引用着Y，这时候，垃圾回收期是不会回收对象Y的；如果对象X还引用着生命周期比较短的A、B、C，对象A又引用着对象 a、b、c，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。</p>
<p><img src="/images/java/jvm/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F2.png" alt="内存泄漏2.png"></p>
<p>申请了内存用完了不释放，比如一共有1024M的内存，分配了512M的内存一直不回收，那么可以用的内存只有512M了，仿佛泄露掉了一部分；通俗一点讲的话，内存泄漏就是【占着茅坑不拉shi】</p>
<h2 id="内存溢出（out-of-memory）"><a href="#内存溢出（out-of-memory）" class="headerlink" title="内存溢出（out of memory）"></a>内存溢出（out of memory）</h2><p>申请内存时，没有足够的内存可以使用；通俗一点儿讲，一个厕所就三个坑，有两个站着茅坑不走的（内存泄漏），剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位（内存）就不够了，内存泄漏变成内存溢出了。可见，内存泄漏和内存溢出的关系：内存泄漏的增多，最终会导致内存溢出。</p>
<p><mark>泄漏的分类</mark></p>
<ul>
<li>经常发生：发生内存泄露的代码会被多次执行，每次执行，泄露一块内存；</li>
<li>偶然发生：在某些特定情况下才会发生</li>
<li>一次性：发生内存泄露的方法只会执行一次；</li>
<li>隐式泄漏：一直占着内存不释放，直到执行结束；严格的说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。</li>
</ul>
<h2 id="Java中内存泄露的8种情况"><a href="#Java中内存泄露的8种情况" class="headerlink" title="Java中内存泄露的8种情况"></a>Java中内存泄露的8种情况</h2><h3 id="静态集合类"><a href="#静态集合类" class="headerlink" title="静态集合类"></a>静态集合类</h3><p>静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oomTests</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object obj＝<span class="keyword">new</span> Object();<span class="comment">//局部变量</span></span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式，和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</p>
<h3 id="内部类持有外部类"><a href="#内部类持有外部类" class="headerlink" title="内部类持有外部类"></a>内部类持有外部类</h3><p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p>
<h3 id="各种连接，如数据库连接、网络连接和IO连接等"><a href="#各种连接，如数据库连接、网络连接和IO连接等" class="headerlink" title="各种连接，如数据库连接、网络连接和IO连接等"></a>各种连接，如数据库连接、网络连接和IO连接等</h3><p>在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Connection conn =<span class="keyword">null</span>;</span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        conn =DriverManager.getConnection(<span class="string">"url"</span>,<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line">        Statement stmt =conn.createStatement();</span><br><span class="line">        ResultSet rs =stmt.executeQuery(<span class="string">"...."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>（Exception e）&#123;<span class="comment">//异常日志</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 1．关闭结果集 Statement</span></span><br><span class="line">        <span class="comment">// 2．关闭声明的对象 ResultSet</span></span><br><span class="line">        <span class="comment">// 3．关闭连接 Connection</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量不合理的作用域"><a href="#变量不合理的作用域" class="headerlink" title="变量不合理的作用域"></a>变量不合理的作用域</h3><p>变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        readFromNet();<span class="comment">//从网络中接受数据保存到msg中</span></span><br><span class="line">        saveDB();<span class="comment">//把msg保存到数据库中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面这个伪代码，通过readFromNet方法把接受的消息保存在变量msg中，然后调用saveDB方法把msg的内容保存到数据库中，此时msg已经就没用了，由于msg的生命周期与对象的生命周期相同，此时msg还不能回收，因此造成了内存泄漏。实际上这个msg变量可以放在receiveMsg方法内部，当方法使用完，那么msg的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完msg后，把msg设置为null，这样垃圾回收器也会回收msg的内存空间。</p>
<h3 id="改变哈希值"><a href="#改变哈希值" class="headerlink" title="改变哈希值"></a>改变哈希值</h3><p>改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。</p>
<p>否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。</p>
<p>这也是 String 为什么被设置成了不可变类型，我们可以放心地把 String 存入 HashSet，或者把String 当做 HashMap 的 key 值；</p>
<p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的 hashCode 不可变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeHashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">"AA"</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">"BB"</span>);</span><br><span class="line"></span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line"></span><br><span class="line">        p1.name = <span class="string">"CC"</span>;<span class="comment">//导致了内存的泄漏</span></span><br><span class="line">        set.remove(p1); <span class="comment">//删除失败</span></span><br><span class="line"></span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">"CC"</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">"AA"</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != person.id) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(person.name) : person.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeHashCode1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Point&gt; hs = <span class="keyword">new</span> HashSet&lt;Point&gt;();</span><br><span class="line">        Point cc = <span class="keyword">new</span> Point();</span><br><span class="line">        cc.setX(<span class="number">10</span>);<span class="comment">//hashCode = 41</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line"></span><br><span class="line">        cc.setX(<span class="number">20</span>);<span class="comment">//hashCode = 51  此行为导致了内存的泄漏</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"hs.remove = "</span> + hs.remove(cc));<span class="comment">//false</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line">        System.out.println(<span class="string">"hs.size = "</span> + hs.size());<span class="comment">//size = 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(hs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        result = prime * result + x;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Point other = (Point) obj;</span><br><span class="line">        <span class="keyword">if</span> (x != other.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Point&#123;"</span> +</span><br><span class="line">                <span class="string">"x="</span> + x +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存泄露"><a href="#缓存泄露" class="headerlink" title="缓存泄露"></a>缓存泄露</h3><p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如：之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存（内存）中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p>
<p>对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map wMap = <span class="keyword">new</span> WeakHashMap();</span><br><span class="line">    <span class="keyword">static</span> Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        testWeakHashMap();</span><br><span class="line">        testHashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String ref1 = <span class="keyword">new</span> String(<span class="string">"obejct1"</span>);</span><br><span class="line">        String ref2 = <span class="keyword">new</span> String(<span class="string">"obejct2"</span>);</span><br><span class="line">        String ref3 = <span class="keyword">new</span> String(<span class="string">"obejct3"</span>);</span><br><span class="line">        String ref4 = <span class="keyword">new</span> String(<span class="string">"obejct4"</span>);</span><br><span class="line">        wMap.put(ref1, <span class="string">"cacheObject1"</span>);</span><br><span class="line">        wMap.put(ref2, <span class="string">"cacheObject2"</span>);</span><br><span class="line">        map.put(ref3, <span class="string">"cacheObject3"</span>);</span><br><span class="line">        map.put(ref4, <span class="string">"cacheObject4"</span>);</span><br><span class="line">        System.out.println(<span class="string">"String引用ref1，ref2，ref3，ref4 消失"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"WeakHashMap GC之前"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"WeakHashMap GC之后"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HashMap GC之前"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"HashMap GC之后"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码和图示主演演示WeakHashMap如何自动释放缓存对象，当init函数执行完成后，局部变量字符串引用weakd1，weakd2，d1，d2都会消失，此时只有静态map中保存中对字符串对象的引用，可以看到，调用gc之后，HashMap的没有被回收，而WeakHashMap里面的缓存被回收了。</p>
<h3 id="监听器和其他回调"><a href="#监听器和其他回调" class="headerlink" title="监听器和其他回调"></a>监听器和其他回调</h3><p>内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。</p>
<p>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为WeakHashMap中的键。</p>
<h2 id="内存泄露案例分析"><a href="#内存泄露案例分析" class="headerlink" title="内存泄露案例分析"></a>内存泄露案例分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123; <span class="comment">//入栈</span></span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序并没有明显的错误，但是这段程序有一个内存泄漏，随着GC活动的增加，或者内存占用的不断增加，程序性能的降低就会表现出来，严重时可导致内存泄漏，但是这种失败情况相对较少。</p>
<p>代码的主要问题在pop函数，下面通过这张图示展现。假设这个栈一直增长，增长后如下图所示</p>
<p><img src="/images/java/jvm/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.png" alt="内存泄漏案例分析.png"></p>
<p>当进行大量的pop操作时，由于引用未进行置空，gc是不会释放的，如下图所示</p>
<p><img src="/images/java/jvm/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%902.png" alt="内存泄漏案例分析2.png"></p>
<p>从上图中看以看出，如果栈先增长，再收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些队象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称过期引用，这个内存泄露很隐蔽。</p>
<p>将代码中的pop()方法变成如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    Object result = elements[--size];</span><br><span class="line">    elements[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦引用过期，清空这些引用，将引用置空。</p>
<p><img src="/images/java/jvm/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%903.png" alt="内存泄漏案例分析3.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>线程、ThreadLocal</title>
    <url>/2021/04/01/java/Thread/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="程序线程、进程、协程"><a href="#程序线程、进程、协程" class="headerlink" title="程序线程、进程、协程"></a>程序线程、进程、协程</h2><ul>
<li>程序是指令和数据的有序集合，其本身没有任何运行的含义 ，是一个静态概念</li>
<li>进程是系统资源分配的最小分配单位；</li>
<li>线程是操作系统调度（CPU调度）、执行的最小单位；</li>
<li>协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）</li>
</ul>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><ol>
<li>继承 <code>Thread</code> 类</li>
<li>重写 <code>run</code> 方法</li>
<li>start 启动</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"TestThread线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread testThread = <span class="keyword">new</span> TestThread();</span><br><span class="line">        testThread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果，两个线程交替执行</span></span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><blockquote>
<p>可以避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</p>
</blockquote>
<ol>
<li>实现 <code>Runnable</code> 接口</li>
<li>重写 <code>run</code>方法</li>
<li>new <code>Thread</code> 类，传入 <code>Runnable</code> 对象</li>
<li>start 启动</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"TestThread线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TestRunnable());</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk1.8</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"TestThread线程"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><ol>
<li>实现 Callable 接口，需要返回值类型</li>
<li>重写 call 方法，需要抛出异常</li>
<li>创建目标对象</li>
<li>创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1)</li>
<li>执行提交：Future<Boolean> result1 = ser.submit(t1);</li>
<li>获取结果：boolean r1 = result1.get()</li>
<li>关闭服务：ser.shutdownNow();</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"TestThread线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestCallable testCallable = <span class="keyword">new</span> TestCallable();</span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        Future&lt;Boolean&gt; result = ser.submit(testCallable);</span><br><span class="line">        Boolean r1 = result.get();</span><br><span class="line">        System.out.println(r1);</span><br><span class="line">        ser.shutdownNow();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// FutureTask的方式</span></span><br><span class="line">        FutureTask&lt;Boolean&gt; booleanFutureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(testCallable);</span><br><span class="line">        <span class="keyword">new</span> Thread(booleanFutureTask).start();</span><br><span class="line">        System.out.println(booleanFutureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="/images/java/thread/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="线程状态.png"></p>
<p><img src="/images/java/thread/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%88%E8%AF%A6%E7%BB%86%E7%89%88%EF%BC%89.png" alt="线程状态（详细版）.png"></p>
<h3 id="Thread-State"><a href="#Thread-State" class="headerlink" title="Thread.State"></a>Thread.State</h3><p>线程状态。线程可以处于一下状态之一：</p>
<ul>
<li><p>NEW</p>
<p>尚未启动的线程处于此状态</p>
</li>
<li><p>RUNNABLE</p>
<p>再Java虚拟机中执行的线程处于此状态</p>
</li>
<li><p>BLOCKED</p>
<p>被阻塞等待监视器锁定的线程处于此状态</p>
</li>
<li><p>WAITING</p>
<p>正在等待另一个线程执行特定动作的线程处于此状态</p>
</li>
<li><p>TIMED_WAITING</p>
<p>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态</p>
</li>
<li><p>TERMINATED</p>
<p>已退出的线程处于此状态</p>
</li>
</ul>
<blockquote>
<p>一个线程可以在给定时间点处于一个状态。这些状态是不反映任何操系统线程状态的虚拟机状态</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"////"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.State state = thread.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line">        thread.start();</span><br><span class="line">        state = thread.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line">        <span class="keyword">while</span> (state != Thread.State.TERMINATED) &#123; <span class="comment">// 只有线程不终止，就一直输出状态</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            state = thread.getState();</span><br><span class="line">            System.out.println(state);</span><br><span class="line">        &#125;</span><br><span class="line">        thread.start(); <span class="comment">// 报错：java.lang.IllegalThreadStateException </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:1745', transport: 'socket'</span><br><span class="line">NEW</span><br><span class="line">RUNNABLE</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">////</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">////</span><br><span class="line">TERMINATED</span><br><span class="line">Exception in thread "main" java.lang.IllegalThreadStateException</span><br><span class="line">	at java.lang.Thread.start(Thread.java:708)</span><br><span class="line">	at com.learning.thread.TestThreadState.main(TestThreadState.java:25)</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:1745', transport: 'socket'</span><br></pre></td></tr></table></figure>



<h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>setPriority(int newPriority)</td>
<td>更改线程的优先级</td>
</tr>
<tr>
<td>static void sleep(long millis)</td>
<td>在指定的毫秒数内让当前正在执行的线程休眠</td>
</tr>
<tr>
<td>void join()</td>
<td>等待该线程终止</td>
</tr>
<tr>
<td>static void yield()</td>
<td>暂停当前正在执行的线程对象，并执行其他线程</td>
</tr>
<tr>
<td>void interrupt()</td>
<td>中断线程，别用这个方式</td>
</tr>
<tr>
<td>boolean isAlive()</td>
<td>测试线程是否处于活动状态</td>
</tr>
</tbody></table>
<h2 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h2><blockquote>
<p>线程停止最好是使用一个外部的标志位停止线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadStop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThreadStop target = <span class="keyword">new</span> TestThreadStop();</span><br><span class="line">        <span class="keyword">new</span> Thread(target).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main 线程停止 Thread 线程"</span>);</span><br><span class="line">            target.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread is running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h2><ul>
<li>sleep(long millis)指定当前线程阻塞的毫秒数 </li>
<li>sleep存在异常InterruptedException</li>
<li>sleep时间达到后线程进入就绪状态</li>
<li>sleep可以模拟网络延时，倒计时等</li>
<li>每一个对象都有一个锁，sleep不会释放锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h2><ul>
<li>礼让线程，让当前正在执行的线程暂停，但不阻塞</li>
<li>将线程从运行状态转为就绪状态</li>
<li>让cpu重新调度</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.yield();</span><br></pre></td></tr></table></figure>

<h2 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h2><p>Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"TestThread线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TestRunnable());</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">200</span>) &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"main线程: "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul>
<li>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所以线程，线程调度器按照优先级决定应该调度哪个线程来执行</li>
<li>线程的优先级用数字表示，范围从1~10<ul>
<li>Thread.MIN_PRIORITY = 1</li>
<li>Thread.NORM_PRIORITY = 5</li>
<li>Thread.MAX_PRIORITY = 10</li>
</ul>
</li>
<li>使用<code>getPriority()</code>、<code>setPriority(int xxx)</code>获取或设置优先级</li>
</ul>
<blockquote>
<p>优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看CPU的调度</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPriority</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyPriority myPriority = <span class="keyword">new</span> MyPriority();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(myPriority, <span class="string">"t1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(myPriority, <span class="string">"t2"</span>);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(myPriority, <span class="string">"t3"</span>);</span><br><span class="line">        Thread thread4 = <span class="keyword">new</span> Thread(myPriority, <span class="string">"t4"</span>);</span><br><span class="line">        Thread thread5 = <span class="keyword">new</span> Thread(myPriority, <span class="string">"t5"</span>);</span><br><span class="line">        Thread thread6 = <span class="keyword">new</span> Thread(myPriority, <span class="string">"t6"</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        thread2.setPriority(<span class="number">1</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread3.setPriority(<span class="number">8</span>);</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        thread4.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        thread4.start();</span><br><span class="line"></span><br><span class="line">        thread5.setPriority(-<span class="number">1</span>); <span class="comment">// 报错 IllegalArgumentException</span></span><br><span class="line">        thread5.start();</span><br><span class="line"></span><br><span class="line">        thread6.setPriority(<span class="number">11</span>); <span class="comment">// 报错 IllegalArgumentException</span></span><br><span class="line">        thread6.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPriority</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + Thread.currentThread().getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="守护（daemon）线程"><a href="#守护（daemon）线程" class="headerlink" title="守护（daemon）线程"></a>守护（daemon）线程</h2><ul>
<li>线程分为<strong>用户线程</strong>和<strong>守护线程</strong></li>
<li>虚拟机必须确保用户线程执行完毕</li>
<li>虚拟机不同等待守护线程执行完毕</li>
<li>如：后台记录操作日志、监控日志、垃圾回收等待…</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaemon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        God god = <span class="keyword">new</span> God();</span><br><span class="line">        Human human = <span class="keyword">new</span> Human();</span><br><span class="line">        </span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(god);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        </span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(human);</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"上帝保佑你"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">36500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"还活着"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"bye bye"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><blockquote>
<p>处理多线程问题时，多个线程访问同意个对象，并且某些对象还想修改这个对象。这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个 <mark>对象的等待池</mark> 形成队列，等待前面线程使用完毕，下一个线程再使用。</p>
</blockquote>
<ul>
<li><p>由于同一线程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入<strong>锁机制 synchronized</strong>，当一个线程获得对象的排他锁，独占资源，其他线程必须等待，使用后释放线程即可，存在以下问题：</p>
<ul>
<li>一个线程持有锁会导致其他所有需要此锁的线程挂起</li>
<li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换 和 调度延迟，引起性能问题</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题</li>
</ul>
</li>
<li><p>针对方法的同步：可以使用 同步方法 和 同步块 来解决</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步块</span></span><br><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同步方法</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote>
<p>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有”两个以上对象的锁“时，就可能会发生”死锁“的问题</p>
</blockquote>
<p>产生死锁的四个必要条件：</p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Resource1 resource1 = <span class="keyword">new</span> Resource1();</span><br><span class="line">        Resource2 resource2 = <span class="keyword">new</span> Resource2();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" :拿到资源1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" :拿到资源2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" :拿到资源2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" :拿到资源1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">// 结果：程序卡住不会终止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决：避免同时抱有两个锁</p>
</blockquote>
<h2 id="线程协助-生产者消费者模式"><a href="#线程协助-生产者消费者模式" class="headerlink" title="线程协助-生产者消费者模式"></a>线程协助-生产者消费者模式</h2><p><img src="/images/java/thread/Java%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.png" alt="Java提供的线程通信方式.png"></p>
<h3 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncContainer container = <span class="keyword">new</span> SyncContainer();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Productor(container)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(container)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    SyncContainer syncContainer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SyncContainer syncContainer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.syncContainer = syncContainer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"消费了"</span> + syncContainer.pull().id + <span class="string">"只鸡"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    SyncContainer syncContainer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(SyncContainer syncContainer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.syncContainer = syncContainer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            syncContainer.push(<span class="keyword">new</span> Chicken(i + <span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">"生产了"</span> + (i + <span class="number">1</span>) + <span class="string">"只鸡"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chicken</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncContainer</span> </span>&#123;</span><br><span class="line">    Chicken[] chickens = <span class="keyword">new</span> Chicken[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Chicken chicken)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 超过最大容量，等待</span></span><br><span class="line">        <span class="keyword">if</span> (count == chickens.length) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chickens[count++] = chicken;</span><br><span class="line">        <span class="comment">// 唤醒消费者消费鸡</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Chicken <span class="title">pull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没有鸡了，等待</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Chicken chicken = chickens[--count];</span><br><span class="line">        <span class="comment">// 唤醒生产者继续生产鸡</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> chicken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号灯法"><a href="#信号灯法" class="headerlink" title="信号灯法"></a>信号灯法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNotify2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TV tv = <span class="keyword">new</span> TV();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Player(tv)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Watcher(tv)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Watcher</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            tv.watch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            tv.play(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    String voice; <span class="comment">// 表演的节目</span></span><br><span class="line">    Boolean flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String voice)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 节目还没有看，等待</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.voice = voice;</span><br><span class="line">        System.out.println(<span class="string">"表演了："</span> + voice);</span><br><span class="line">        <span class="comment">// 唤醒消费者观看</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        flag = !flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没有节目了，等待</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"观看了："</span> + voice);</span><br><span class="line">        <span class="comment">// 唤醒演员表演</span></span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>JDK5.0起提供了线程池相关API：ExecutorService 和 Executors</li>
<li>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor<ul>
<li>void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行Runnable</li>
<li><T> Future<T> submit(Callable<T> task)：执行任务，有返回值，一般用来执行Callable</li>
<li>vod shutdown()：关闭线程池</li>
</ul>
</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecutors</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock 锁"></a>Lock 锁</h2><ul>
<li>从JDK 5.0 开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当</li>
<li>java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具</li>
<li>锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象</li>
<li>ReentrantLock 类实现了 Lock，他拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁 、释放锁</li>
</ul>
<p><img src="/images/java/thread/Lock%E5%85%AC%E5%B9%B3%E9%94%81%E3%80%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="Lock公平锁、非公平锁.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLock myLock = <span class="keyword">new</span> MyLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(myLock::sale).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myLock::sale).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myLock::sale).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(ticket--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a>synchronized 与 Lock 的对比</h3><ul>
<li><p>Lock 是显式锁（手动开启和关闭锁），synchronized 是隐式锁，出了作用域自动释放锁</p>
</li>
<li><p>Lock只有代码块锁，synchronized 有代码块和方法锁</p>
</li>
<li><p>Synchronized 无法判断获取锁的状态，Lock 可以判断是否获取到了锁</p>
</li>
<li><p>Synchronized 可重入锁，不可以中断的，非公平；Lock ，可重入锁，可以 判断锁，非公平（可以</p>
<p>自己设置）；</p>
</li>
<li><p>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</p>
</li>
<li><p>优先使用顺序：</p>
<ul>
<li>Lock &gt; 同步代码块 &gt; 同步方法</li>
</ul>
</li>
</ul>
<h3 id="线程协助-生产者消费者模式-JUC版"><a href="#线程协助-生产者消费者模式-JUC版" class="headerlink" title="线程协助-生产者消费者模式(JUC版)"></a>线程协助-生产者消费者模式(JUC版)</h3><blockquote>
<p>Synchronized 改进版，使用 while 防止虚假唤醒</p>
</blockquote>
<p>线程也可以唤醒，而不会被通知，中断或超时，即所谓的虚假唤醒 。 虽然这在实践中很少会发生，但应用程序必须通过测试应该使线程被唤醒的条件来防范，并且如果条件不满足则继续等待。 换句话说，等待应该总是出现在循环中，就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">       <span class="keyword">while</span> (&lt;condition does not hold&gt;)</span><br><span class="line">           obj.wait(timeout);</span><br><span class="line">       ... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123; <span class="comment">// 数字 资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123; <span class="comment">//0</span></span><br><span class="line">			<span class="comment">// 等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> + number);</span><br><span class="line">		<span class="comment">// 通知其他线程，我+1完毕了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">			<span class="comment">// 等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> + number);</span><br><span class="line">		<span class="comment">// 通知其他线程，我-1完毕了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JUC 版</p>
<p>Lock替换synchronized方法和语句的使用， Condition取代了对象监视器方法的使用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Data2 data = <span class="keyword">new</span> Data2();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data2</span> </span>&#123; <span class="comment">// 数字 资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务代码</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123; <span class="comment">//0</span></span><br><span class="line">                <span class="comment">// 等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> + number);</span><br><span class="line">            <span class="comment">// 通知其他线程，我+1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">                <span class="comment">// 等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> + number);</span><br><span class="line">            <span class="comment">// 通知其他线程，我-1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>精准唤醒</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 执行完调用B，B执行完调用C，C执行完调用A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data3 data = <span class="keyword">new</span> Data3();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data3</span> </span>&#123; <span class="comment">// 资源类 Lock</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>; <span class="comment">// 1A 2B 3C</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;AAAAAAA"</span>);</span><br><span class="line">            <span class="comment">// 唤醒，唤醒指定的人，B</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;BBBBBBBBB"</span>);</span><br><span class="line">            <span class="comment">// 唤醒，唤醒指定的人，c</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;BBBBBBBBB"</span>);</span><br><span class="line">            <span class="comment">// 唤醒，唤醒指定的人，c</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h2><blockquote>
<p>List</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非线程安全类报异常：java.util.ConcurrentModificationException 并发修改异常！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// CopyOnWrite 写入时复制</span></span><br><span class="line">        <span class="comment">// COW 计算机程序设计领域的一种优化策略；</span></span><br><span class="line">        <span class="comment">// 多个线程调用的时候，list，读取的时候，固定的，写入（覆盖）</span></span><br><span class="line">        <span class="comment">// 在写入的时候避免覆盖，造成数据问题！</span></span><br><span class="line">        <span class="comment">// 读写分离</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Set</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同理可证 ： ConcurrentModificationException</span></span><br><span class="line"><span class="comment"> * //1、Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line"><span class="comment"> * //2、</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">30</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Map</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(</span><br><span class="line">                        <span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p><img src="/images/java/thread/Callable%E4%BB%8B%E7%BB%8D.png" alt="Callable介绍.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"TestThread线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestCallable testCallable = <span class="keyword">new</span> TestCallable();</span><br><span class="line">        FutureTask&lt;Boolean&gt; booleanFutureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(testCallable);</span><br><span class="line">        <span class="keyword">new</span> Thread(booleanFutureTask).start();</span><br><span class="line">        System.out.println(booleanFutureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><blockquote>
<p>允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">"消耗一个countDownLatch"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"完成countDownLatch"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理</p>
</blockquote>
<p>countDownLatch.countDown(); // 数量-1</p>
<p>countDownLatch.await(); // 等待计数器归零，然后再向下执行</p>
<p>每次有线程调用 countDown() 数量-1，假设计数器变为0，countDownLatch.await() 就会被唤醒，继续执行！</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><blockquote>
<p>加法计数器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第二个变量为当到达第一个变量的时候执行的操作，同时也会执行 await()后面的操作</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, () -&gt; System.out.println(<span class="string">"找齐七颗龙珠，召唤神龙"</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.printf(<span class="string">"找到第%s颗龙珠%n"</span>, temp);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.printf(<span class="string">"测试:%s%n"</span>, temp);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><blockquote>
<p>信号量</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(temp + <span class="string">"抢到信号量"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                    System.out.println(<span class="string">"释放信号量"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理</p>
</blockquote>
<p>semaphore.acquire() 获得，假设如果已经满了，等待，等待被释放为止！</p>
<p>semaphore.release(); 释放，会将当前的信号量释放 + 1，然后唤醒等待的线程！</p>
<blockquote>
<p>作用</p>
</blockquote>
<p>多个共享资源互斥的使用！并发限流，控制最大的线程数！</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><blockquote>
<p>ReadWriteLock 维护一对关联的locks ，一个用于只读操作，一个用于写入。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="comment">// 写入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; myCache.put(temp + <span class="string">""</span>, temp + <span class="string">""</span>), String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; myCache.get(temp + <span class="string">""</span>), String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String k, Object v)</span> </span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"写入"</span> + k);</span><br><span class="line">            map.put(k, v);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"写入OK"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"读取"</span> + key);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"读取成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().lock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><blockquote>
<p>四组API</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方式</th>
<th align="center">抛出异常</th>
<th align="center">有返回值，不抛出异常</th>
<th align="center">阻塞等待</th>
<th align="center">超时等待</th>
</tr>
</thead>
<tbody><tr>
<td align="center">添加</td>
<td align="center">add</td>
<td align="center">offer()</td>
<td align="center">put()</td>
<td align="center">offer(,,)</td>
</tr>
<tr>
<td align="center">移除</td>
<td align="center">remove</td>
<td align="center">poll()</td>
<td align="center">take()</td>
<td align="center">poll(,)</td>
</tr>
<tr>
<td align="center">检测队首元素</td>
<td align="center">element</td>
<td align="center">peek</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//        test1();</span></span><br><span class="line"><span class="comment">//        test2();</span></span><br><span class="line"><span class="comment">//        test3();</span></span><br><span class="line">        test4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队列的大小</span></span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"a"</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"b"</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"c"</span>));</span><br><span class="line">        <span class="comment">// IllegalStateException: Queue full 抛出异常！</span></span><br><span class="line">        <span class="comment">// System.out.println(blockingQueue.add("d"));</span></span><br><span class="line">        System.out.println(<span class="string">"============="</span>);</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.element());</span><br><span class="line">        <span class="comment">// java.util.NoSuchElementException 抛出异常！</span></span><br><span class="line">        <span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有返回值，没有异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队列的大小</span></span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"b"</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"c"</span>));</span><br><span class="line">        <span class="comment">// System.out.println(blockingQueue.offer("d")); // false 不抛出异常！</span></span><br><span class="line">        System.out.println(<span class="string">"============================"</span>);</span><br><span class="line">        System.out.println(blockingQueue.peek());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll()); <span class="comment">// null 不抛出异常！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待，阻塞（一直阻塞）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 队列的大小</span></span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一直阻塞</span></span><br><span class="line">        blockingQueue.put(<span class="string">"a"</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">"b"</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">"c"</span>);</span><br><span class="line"><span class="comment">//        blockingQueue.put("d"); // 队列没有位置了，一直阻塞</span></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take()); <span class="comment">// 没有这个元素，一直阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待，阻塞（等待超时）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 队列的大小</span></span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">"a"</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">"b"</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">// blockingQueue.offer("d",2,TimeUnit.SECONDS); // 等待超过2秒就退出</span></span><br><span class="line">        System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS); <span class="comment">// 等待超过2秒就退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><blockquote>
<p>SynchronousQueue 同步队列</p>
<p>没有容量，进去一个元素，必须等待取出来之后，才能再往里面放一个元素！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步队列</span></span><br><span class="line"><span class="comment"> * 和其他的BlockingQueue 不一样， SynchronousQueue 不存储元素</span></span><br><span class="line"><span class="comment"> * put了一个元素，必须从里面先take取出来，否则不能在put进去值！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(); <span class="comment">// 同步队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" put 1"</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">"1"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" put 2"</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">"2"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" put 3"</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">"3"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"T1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> + blockingQueue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"T2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h2><blockquote>
<p>线程池：三大方法、7大参数、4种拒绝策略</p>
</blockquote>
<p>线程池的好处</p>
<ol>
<li>降低资源的消耗</li>
<li>提高响应的速度</li>
<li>方便管理</li>
</ol>
<p>线程复、可以控制最大并发数、管理线程</p>
<blockquote>
<p>alibaba开发手册中关于线程池的创建的规范</p>
</blockquote>
<p><img src="/images/java/thread/alibaba%E8%A7%84%E8%8C%83-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA.png" alt="alibaba规范-线程池的创建.png"></p>
<blockquote>
<p>默认的三种创建线程池的方式，不推荐</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三种创建线程池的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newSingleThreadExecutor();      //单个线程</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newFixedThreadPool(5);         // 创建一个固定的线程池的大小</span></span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();         <span class="comment">// 大小可伸缩的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 使用了线程池之后，使用线程池来创建线程</span></span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" ok"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 线程池用完，程序结束，关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>七个参数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jdk源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,// 核心线程池大小</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,// 最大核心线程池大小</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,// 超时了没有人调用就会释放</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,// 超时单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,// 阻塞队列,没地方放的队列保持在这里</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,// 线程工厂：创建线程的，一般不用动</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler// 拒绝策略</span></span></span><br><span class="line"><span class="function"><span class="params">                         )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 最大容量 maxPool + 给定队列的长度</span></span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()); <span class="comment">//队列满了，丢弃最旧的未处理请求，重试，也不会抛出异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 使用了线程池之后，使用线程池来创建线程</span></span><br><span class="line">                <span class="keyword">int</span> temp = i;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" ok："</span> + temp);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 线程池用完，程序结束，关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> ok：<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> ok：<span class="number">5</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> ok：<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> ok：<span class="number">6</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> ok：<span class="number">7</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> ok：<span class="number">97</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> ok：<span class="number">98</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> ok：<span class="number">99</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>4种拒绝策略</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy() <span class="comment">// 队列满了，还有人进来，不处理这个人的，抛出异常</span></span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy() <span class="comment">// 哪来的去哪里，交给原来的线程执行！</span></span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy() <span class="comment">//队列满了，丢掉任务，不会抛出异常！</span></span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy() <span class="comment">//队列满了，丢弃最旧的未处理请求，重试，也不会抛出异常</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结</p>
</blockquote>
<p>最大线程该如何设置？</p>
<ul>
<li><p>CPU 密集型，几核，就是几，可以保持CPU的效率最高！</p>
</li>
<li><p>IO 密集型，判断你程序中十分耗IO的线程来给相应大小的线程数</p>
</li>
</ul>
<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><blockquote>
<p>把大任务拆分为小任务</p>
</blockquote>
<p>ForkJoin的工作窃取</p>
<p><img src="/images/java/thread/ForkJoin%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96.png" alt="ForkJoin的工作窃取.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> temp = <span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinDemo</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; temp) &#123;</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinDemo task1 = <span class="keyword">new</span> ForkJoinDemo(start, mid);</span><br><span class="line">            task1.fork();</span><br><span class="line">            ForkJoinDemo task2 = <span class="keyword">new</span> ForkJoinDemo(mid + <span class="number">1</span>, end);</span><br><span class="line">            task2.fork();</span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 三种计算方式效率对比</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 500000000500000000</span></span><br><span class="line">        <span class="comment">// 用时：2287</span></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinDemo forkJoinDemo = <span class="keyword">new</span> ForkJoinDemo(<span class="number">1L</span>, <span class="number">10_0000_0000L</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(forkJoinDemo);</span><br><span class="line">            Long result = submit.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">            System.out.println(<span class="string">"用时："</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 500000000500000000</span></span><br><span class="line">        <span class="comment">// 用时：154</span></span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> sum1 = LongStream.rangeClosed(<span class="number">0L</span>,</span><br><span class="line">                <span class="number">10_0000_0000</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        System.out.println(sum1);</span><br><span class="line">        System.out.println(<span class="string">"用时："</span> + (System.currentTimeMillis() - start1));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 500000000500000000</span></span><br><span class="line">        <span class="comment">// 用时：3942</span></span><br><span class="line">        Long sum2 = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1L</span>; i &lt;= <span class="number">10_0000_0000</span>; i++) &#123;</span><br><span class="line">            sum2 += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">        System.out.println(<span class="string">"用时："</span> + (System.currentTimeMillis() - start2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 没有返回值的 runAsync 异步回调</span></span><br><span class="line"><span class="comment">//        CompletableFuture&lt;Void&gt; completableFuture =</span></span><br><span class="line"><span class="comment">//                CompletableFuture.runAsync(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//                    try &#123;</span></span><br><span class="line"><span class="comment">//                        TimeUnit.SECONDS.sleep(2);</span></span><br><span class="line"><span class="comment">//                    &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                    System.out.println(Thread.currentThread().getName() + "runAsync=&gt;Void");</span></span><br><span class="line"><span class="comment">//                &#125;);</span></span><br><span class="line"><span class="comment">//        System.out.println("1111");</span></span><br><span class="line"><span class="comment">//        completableFuture.get(); // 获取阻塞执行结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有返回值的 supplyAsync 异步回调</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture =</span><br><span class="line">                CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"supplyAsync=&gt;Integer"</span>);</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t=&gt;"</span> + t); <span class="comment">// 正常的返回结果</span></span><br><span class="line">            System.out.println(<span class="string">"u=&gt;"</span> + u); <span class="comment">// 错误信息：</span></span><br><span class="line">        &#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">233</span>; <span class="comment">// 可以获取到错误的返回结果</span></span><br><span class="line">        &#125;).get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><blockquote>
<p><strong>Volatile 是可以保证可见性。不能保证原子性，由于内存屏障，可以保证避免指令重排的现象产生！</strong></p>
</blockquote>
<blockquote>
<p>保证可见性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">volatileTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不加 volatile 程序就会死循环！</span></span><br><span class="line">    <span class="comment">// 加 volatile 可以保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"num不为0"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"num修改为1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不保证原子性</p>
</blockquote>
<p>下面的结果不能保证输出为 2W</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">volatileTest2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// volatile 不保证原子性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//理论上num结果应该为 2 万</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123; </span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用原子类解决原子操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">volatileTest2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// volatile 不保证原子性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        num.getAndIncrement();	<span class="comment">// 底层采用自旋锁直接在内存中修改值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//num结果为 2 万</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123; <span class="comment">// main gc</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以避免指令重排</p>
</blockquote>
<p>指令重排：源代码–&gt;编译器优化的重排–&gt; 指令并行也可能会重排–&gt; 内存系统也会重排—&gt; 执行</p>
<p>指令重排在单线程下没有问题，在多线程下有问题</p>
<p><strong>volatile</strong>可以避免指令重排：</p>
<p>内存屏障。CPU指令。作用：</p>
<ol>
<li>保证特定的操作的执行顺序</li>
<li>可以保证某些变量的内存可见性（利用这些特性volatile实现了可见性）</li>
</ol>
<p><img src="/images/java/thread/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" alt="内存屏障.png"></p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><blockquote>
<p>compareAndSet</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CAS compareAndSet : 比较并交换！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">2020</span>);</span><br><span class="line">        <span class="comment">// public final boolean compareAndSet(int expect, int update)</span></span><br><span class="line">        <span class="comment">// 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层实现为：Unsafe.getAndAddInt()</p>
<p>比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ol>
<li>循环耗时</li>
<li>一次性只能保证一个共享变量的原子性</li>
<li>ABA问题</li>
</ol>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><blockquote>
<p>一个线程将值修改又很快的改回原值，而另一个线程不可知</p>
</blockquote>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><blockquote>
<p>带版本号 的原子操作！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题</span></span><br><span class="line">    <span class="comment">// 正常在业务操作，这里面比较的都是一个个对象</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span></span><br><span class="line">            AtomicStampedReference&lt;&gt;(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// CAS compareAndSet : 比较并交换！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp(); <span class="comment">// 获得版本号</span></span><br><span class="line">            System.out.println(<span class="string">"a1=&gt;"</span>+stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">                    atomicStampedReference.getStamp(),</span><br><span class="line">                    atomicStampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">"a2=&gt;"</span>+atomicStampedReference.getStamp());</span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(<span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">                    atomicStampedReference.getStamp(),</span><br><span class="line">                    atomicStampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">"a3=&gt;"</span>+atomicStampedReference.getStamp());</span><br><span class="line">        &#125;,<span class="string">"a"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp(); <span class="comment">// 获得版本号</span></span><br><span class="line">            System.out.println(<span class="string">"b1=&gt;"</span>+stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">6</span>,</span><br><span class="line">                    stamp, stamp + <span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">"b2=&gt;"</span>+atomicStampedReference.getStamp());</span><br><span class="line">        &#125;,<span class="string">"b"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果</span></span><br><span class="line"><span class="comment"> * a1=&gt;1</span></span><br><span class="line"><span class="comment"> * b1=&gt;1</span></span><br><span class="line"><span class="comment"> * true</span></span><br><span class="line"><span class="comment"> * a2=&gt;2</span></span><br><span class="line"><span class="comment"> * true</span></span><br><span class="line"><span class="comment"> * a3=&gt;3</span></span><br><span class="line"><span class="comment"> * false</span></span><br><span class="line"><span class="comment"> * b2=&gt;3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><blockquote>
<p>JMM即Java内存模型(Java memory model)，在JSR133里指出了JMM是用来定义一个<strong>一致的、跨平台</strong>的内存模型，是缓存一致性协议，用来定义数据读写的规则。</p>
</blockquote>
<p><img src="/images/java/thread/%E5%86%85%E5%AD%98%E7%9A%84%E5%85%AB%E7%A7%8D%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C.png" alt="内存的八种交互操作.png"></p>
<p><strong>内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）</strong></p>
<ul>
<li><p>lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态</p>
</li>
<li><p>unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</p>
</li>
<li><p>read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</p>
</li>
<li><p>load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中</p>
</li>
<li><p>use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令</p>
</li>
<li><p>assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中</p>
</li>
<li><p>store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用</p>
</li>
<li><p>write （写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</p>
</li>
</ul>
<p><strong>JMM</strong>对这八种指令的使用，制定了如下规则：</p>
<ul>
<li><p>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</p>
</li>
<li><p>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</p>
</li>
<li><p>不允许一个线程将没有assign的数据从工作内存同步回主内存</p>
</li>
<li><p>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</p>
</li>
<li><p>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</p>
</li>
<li><p>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</p>
</li>
<li><p>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</p>
</li>
<li><p>对一个变量进行unlock操作之前，必须把此变量同步回主内存</p>
</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h3><p>公平锁： 非常公平， 不能够插队，必须先来后到！</p>
<p>非公平锁：非常不公平，可以插队 （默认都是非公平）</p>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>某个线程已经获得某个锁，可以再次获取锁而不会出现死锁</p>
<p><code>Synchronized</code> 和 <code>ReentrantLock</code> 都是可重入锁</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><h3 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h3><blockquote>
<p>解决方法</p>
</blockquote>
<ol>
<li><p>使用 jps -l 定位进程号</p>
</li>
<li><p>使用 jstack 进程号 找到死锁问题</p>
</li>
</ol>
<h2 id="强引用、虚引用、弱引用"><a href="#强引用、虚引用、弱引用" class="headerlink" title="强引用、虚引用、弱引用"></a>强引用、虚引用、弱引用</h2><ul>
<li>强引用是常见的普通对象引用，只有有强引用指向对象，那么垃圾回收不会对该对象进行回收；</li>
<li>软引用：<ol>
<li>软引用需要通过Jdk提供的 java.lang.ref.SoftReference实现</li>
<li>当系统内存充足时它不会被回收</li>
<li>当系统内存不足时它会被回收</li>
</ol>
</li>
<li>弱引用：<ol>
<li>弱引用需要通过Jdk提供的 java.lang.ref.WeakReference实现</li>
<li>弱引用的对象，在垃圾回收的时候，无论内存是否充足，都会被垃圾回收</li>
</ol>
</li>
</ul>
<h2 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h2><p><img src="/images/java/cachecache.png" alt="cachecache"></p>
<ul>
<li>数据在缓存中不是以独立的项来存储的，它不是一个单独的变量，也不是一个单独的指针,它在数据缓存中以缓存行存在的，也称缓存行为缓存条目。目前主流的CPU Cache的Cache Line大小通常是64字节，并且它有效地引用主内存中的一块地址。一个Java的long类型是8字节，因此在一个缓存行中可以存8个long类型的变量。</li>
<li>这么做的原因是因为避免频繁的需要从主存中读取数据到缓存，至于为什么是以64位为一个缓存行进行读取，则是因为工业实践出来的最优结果</li>
<li>有些程序为了不让其他线程读取到当前的数据行而导致程序需要频繁的同步最新数据带来的程序性能损耗，在数据前加64-x，数据后加64-x位的数据，以保证当前数据行只有当前程序在使用。</li>
</ul>
<h2 id="缓存一致性协议（MESI）"><a href="#缓存一致性协议（MESI）" class="headerlink" title="缓存一致性协议（MESI）"></a>缓存一致性协议（MESI）</h2><ul>
<li>多处理机系统中，一种用来保持多个高速缓存之间，以及高速缓存与主存储器之间数据一致的机制</li>
<li>每个系统的实现方式不同，何时保持一致性也完全由操作系统控制</li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><ul>
<li>ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//实际存储的数据结构类型</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//如果存在map就直接set，没有则创建map并set</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getMap方法</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//thred中维护了一个ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal中get方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><ul>
<li><code>ThreadLocalMap.Entry</code> 的父类为 <code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code> ,而Entry的构造方法设置key调用的是 <code>super(k)</code>，这代表key是被一个弱引用指向，如果没有其他引用指向当前key，那么系统垃圾回收会自动回收掉当前key，以免造成内存泄漏。但是value并不会自动回收，所有在 <code>ThreadLocal</code> 使用完之后需要用 <code>ThreadLocal.remove()</code> 方法移除。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Entry为ThreadLocalMap静态内部类，对ThreadLocal的若引用</span></span><br><span class="line"><span class="comment">//同时让ThreadLocal和储值形成key-value的关系</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadLocalMap构造方法</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">//内部成员数组，INITIAL_CAPACITY值为16的常量</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">//位运算，结果与取模相同，计算出需要存放的位置</span></span><br><span class="line">    <span class="comment">//threadLocalHashCode比较有趣</span></span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h2><ul>
<li>Consumer</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt;</span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Function</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt;</span>&#123;<span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Predicate</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Supplier</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="function">T <span class="title">get</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目要求：一分钟内完成此题，只能用一行代码实现！</span></span><br><span class="line"><span class="comment"> * 现在有5个用户！筛选：</span></span><br><span class="line"><span class="comment"> * 1、ID 必须是偶数</span></span><br><span class="line"><span class="comment"> * 2、年龄必须大于23岁</span></span><br><span class="line"><span class="comment"> * 3、用户名转为大写字母</span></span><br><span class="line"><span class="comment"> * 4、用户名字母倒着排序</span></span><br><span class="line"><span class="comment"> * 5、只输出一个用户！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"a"</span>, <span class="number">21</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"b"</span>, <span class="number">22</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"c"</span>, <span class="number">23</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">"d"</span>, <span class="number">24</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="number">6</span>, <span class="string">"e"</span>, <span class="number">25</span>);</span><br><span class="line"><span class="comment">// 集合就是存储</span></span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);</span><br><span class="line"><span class="comment">// 计算交给Stream流</span></span><br><span class="line"><span class="comment">// lambda表达式、链式编程、函数式接口、Stream流式计算</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(u -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> u.getId() % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">                .filter(u -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> u.getAge() &gt; <span class="number">23</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">                .map(u -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> u.getName().toUpperCase();</span><br><span class="line">                &#125;)</span><br><span class="line">                .sorted((uu1, uu2) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> uu2.compareTo(uu1);</span><br><span class="line">                &#125;)</span><br><span class="line">                .limit(<span class="number">1</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式中只有 <strong>饿汉式</strong> 和 <strong>枚举</strong> 的方式才正在的安全，懒汉式均有可能遭到反射的破坏</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 学习笔记</title>
    <url>/2021/04/05/java/SpringCloud/</url>
    <content><![CDATA[<p><img src="/images/java/springcloud/SpringClound%E9%80%89%E5%9E%8B.png" alt="SpringClound选型"></p>
<h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><h2 id="Eureka集群原理"><a href="#Eureka集群原理" class="headerlink" title="Eureka集群原理"></a>Eureka集群原理</h2><p><img src="/images/java/springcloud/Eureka%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86.png" alt="Eureka集群原理"></p>
<h2 id="EurekaService-服务端单机版安装"><a href="#EurekaService-服务端单机版安装" class="headerlink" title="EurekaService 服务端单机版安装"></a>EurekaService 服务端单机版安装</h2><ol>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># false表示自己端就是注册中心，我的职责是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">    <span class="comment"># 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>localhost:7001</p>
<p><img src="/images/java/springcloud/Eureka-Server-%E7%95%8C%E9%9D%A2.png" alt="Eureka-Server-界面"></p>
</li>
</ol>
<h2 id="支付服务入驻eurekaServer"><a href="#支付服务入驻eurekaServer" class="headerlink" title="支付服务入驻eurekaServer"></a>支付服务入驻eurekaServer</h2><ol>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- eureka-client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 表示是否将自己注册进EurekaServer，默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从Eureka抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain8001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8001<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>localhost:7001</p>
</li>
</ol>
<p><img src="/images/java/springcloud/payment%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%A9%BBEurekaServer.png" alt="payment服务入驻EurekaServer"></p>
<h2 id="订单微服务入驻eurekaServer"><a href="#订单微服务入驻eurekaServer" class="headerlink" title="订单微服务入驻eurekaServer"></a>订单微服务入驻eurekaServer</h2><ol>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- eureka-client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 表示是否将自己注册进EurekaServer，默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从Eureka抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderMain80<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>localhost:7001</p>
</li>
</ol>
<p><img src="/images/java/springcloud/Order%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%A9%BBEurekaServer.png" alt="Order服务入驻EurekaServer"></p>
<h2 id="EurekaServer-服务端集群版安装"><a href="#EurekaServer-服务端集群版安装" class="headerlink" title="EurekaServer 服务端集群版安装"></a>EurekaServer 服务端集群版安装</h2><blockquote>
<p>原理：相互注册，相互守望</p>
<p>defaultZone添加其他几个EurekaServer的地址，用 <code>,</code>隔开</p>
</blockquote>
<ol>
<li><p>添加一个Server7002（同cloud-eureka-server7001）</p>
</li>
<li><p>修改 <code>C:\Windows\System32\drivers\etc\hosts</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SoringCloud-添加eureka</span></span><br><span class="line"><span class="meta">127.0.0.1</span> <span class="string">eureka7001.com</span></span><br><span class="line"><span class="meta">127.0.0.1</span> <span class="string">eureka7002.com</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>cloud-eureka-server7001</code> 的 <code>application.yml</code></p>
<p><img src="/images/java/springcloud/EurekaServer7001-application.yml%E9%9B%86%E7%BE%A4%E7%89%88.png" alt="EurekaServer7001-application.yml集群版"></p>
</li>
<li><p>修改 <code>cloud-eureka-server7002</code>的 <code>application.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7002.com</span> <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># false表示自己端就是注册中心，我的职责是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">    <span class="comment"># 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>访问<strong><a href="http://eureka7001.com:7001/" target="_blank" rel="noopener">http://eureka7001.com:7001/</a></strong>，<strong><a href="http://eureka7002.com:7002/" target="_blank" rel="noopener">http://eureka7002.com:7002/</a></strong>，可以访问成功！</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>CAP原则又称CAP定理，指的是在一个分布式系统中，<a href="https://baike.baidu.com/item/一致性/9840083" target="_blank" rel="noopener">一致性</a>（Consistency）、<a href="https://baike.baidu.com/item/可用性/109628" target="_blank" rel="noopener">可用性</a>（Availability）、<a href="https://baike.baidu.com/item/分区容错性/23734073" target="_blank" rel="noopener">分区容错性</a>（Partition tolerance）。CAP 原则指的是，这三个<a href="https://baike.baidu.com/item/要素/5261200" target="_blank" rel="noopener">要素</a>最多只能同时实现两点，不可能三者兼顾。</li>
<li>AP架构<ul>
<li>当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。</li>
<li>违背了一致性的要求，只满足可用性和分区容错。</li>
</ul>
</li>
<li>CP架构<ul>
<li>当网络分区出现后，为了保证一致性，就必须拒绝请求，否则无法保证一致性。</li>
<li>违背了可用性A的要求，只满足一致性和分区容错。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>组件名</th>
<th>语言</th>
<th>CAP</th>
<th>服务健康检查</th>
<th>对外暴露接口</th>
<th>Spring Cloud集成</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka</td>
<td>Java</td>
<td>AP</td>
<td>可配支持</td>
<td>HTTP</td>
<td>已集成</td>
</tr>
<tr>
<td>Consul</td>
<td>Go</td>
<td>CP</td>
<td>支持</td>
<td>HTTP/DNS</td>
<td>已集成</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>Java</td>
<td>CP</td>
<td>支持</td>
<td>客户端</td>
<td>已集成</td>
</tr>
</tbody></table>
<p><img src="/images/java/springcloud/cap.png" alt="经典CAP图"></p>
<h1 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h1><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ul>
<li>LoadBalancer<ul>
<li>集中式LB：即在服务的消费方和提供方之间提供独立的LB设施（可以是硬件，如F5，也可以是软件，如nginx），由该设施负责把访问请求通过某种策略转发至服务的提供方</li>
<li>进程内LB：将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些服务可用，软后自己再从这些地址中选择一个和合适的服务器。Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</li>
</ul>
</li>
</ul>
<h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><ul>
<li><p>Ribbon 是 Netflex 发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项入连接超时，重试等。简单的说，就是在配置文件中列出LoadBalancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。</p>
</li>
<li><p><strong>Springcloud 2.2.1.RELEASE</strong> 的 <strong>spring-cloud-starter-netflix-eureka-client</strong> 默认集成了 <strong>Ribbon</strong>，在 <strong>RestTemplate</strong> 上使用注解<strong>@LoadBalance</strong> 则自动使用 <strong>Ribbon</strong> 负载均衡</p>
</li>
<li><p>Ribbon 有7种负载均衡策略可供选择：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>策略类</th>
<th>命名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RandomRule</td>
<td>随机策略</td>
<td>随机选择server</td>
</tr>
<tr>
<td>RoundRobinRule</td>
<td>轮询策略</td>
<td>按照顺序选择server（ribbon默认策略）</td>
</tr>
<tr>
<td>RetryRule</td>
<td>重试策略</td>
<td>在一个配置时间段内，当选择server不成功，则一直尝试选择一个可用的server</td>
</tr>
<tr>
<td>BestAvailableRule</td>
<td>最低并发策略</td>
<td>逐个考察server，如果server断路器打开，则忽略，再选择其中并发链接最低的server</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>可用过滤策略</td>
<td>过滤掉一直失败并被标记为circuit tripped的server，过滤掉那些高并发链接的server（active connections超过配置的阈值）</td>
</tr>
<tr>
<td>ResponseTimeWeightedRule</td>
<td>响应时间加权重策略</td>
<td>根据server的响应时间分配权重，响应时间越长，权重越低，被选择到的概率也就越低。响应时间越短，权重越高，被选中的概率越高，这个策略很贴切，综合了各种因素，比如：网络，磁盘，io等，都直接影响响应时间</td>
</tr>
<tr>
<td>ZoneAvoidanceRule</td>
<td>区域权重策略</td>
<td>综合判断server所在区域的性能，和server的可用性，轮询选择server并且判断一个AWS Zone的运行性能是否可用，剔除不可用的Zone中的所有server</td>
</tr>
</tbody></table>
<h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><ul>
<li><strong>Feign</strong> 是一个声明式的Web服务客户端，让编写Web服务客户端变得非常容易，只需要创建一个接口并在接口上添加注解即可。 <strong>Feign</strong> 集成了 <strong>Ribbon</strong> 实现客户端负载均衡调用。</li>
</ul>
<h3 id="Eureka集成OpenFeign"><a href="#Eureka集成OpenFeign" class="headerlink" title="Eureka集成OpenFeign"></a>Eureka集成OpenFeign</h3><ol>
<li><p><strong>pom.xml</strong> 添加 <strong>OpenFeign</strong> 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>application.yml</strong> 添加 <strong>eureka</strong> 服务地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">feign-order-service</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 表示是否将自己注册进EurekaServer，默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span> <span class="comment">#,http://eureka7001.com:7002/eureka/</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>主启动类添加 <strong>@EnableFeignClients</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignOrderMain80</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FeignOrderMain80<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>新建 service 接口类，添加 <strong>@FeignClient</strong> 注解指明服务名称，用 <strong>PostMapping</strong>、<strong>GetMapping</strong>…指明调用的是哪个接口（与服务提供方的 <strong>controller</strong> 层代码一致）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.learning.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.learning.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PAYMENT-SERVICE"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/payment/create"</span>)</span><br><span class="line">    <span class="function">CommonResult&lt;Payment&gt; <span class="title">create</span><span class="params">(Payment payment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>controller 调用…</p>
</li>
</ol>
<h3 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h3><p><img src="/images/java/springcloud/OpenFeign-timeout.png" alt="OpenFeign-timeout"></p>
<ul>
<li><p>ribbon 默认超时时间 1 秒，超时响应就会报错</p>
</li>
<li><p>通过在 <strong>application.yml</strong> 中添加超时时间</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加ribbon超时时间</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="日志打印功能"><a href="#日志打印功能" class="headerlink" title="日志打印功能"></a>日志打印功能</h3><ul>
<li><p><strong>Feign</strong> 提供了日志打印功能，可以通过配置调整日志级别，从而了解 Feign 中 Http 请求的细节</p>
<ul>
<li>NONE：默认的，不显示任何日志</li>
<li>BASIC：仅提供请求方法、URL、响应状态码及执行时间</li>
<li>HEADERS：除了 BASIC 中定义的信息外，还有请求和响应的头信息</li>
<li>FULL：出来 HEADERS 中定义的信息外，还有请求和响应的正文及元数据</li>
</ul>
</li>
<li><p>添加FeignConfig.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;    </span><br><span class="line">    <span class="meta">@Bean</span>    </span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在application.yml中添加打印级别</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.learning.springcloud.service.PaymentService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>效果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2021-05-16 17:05:19.100 DEBUG 13352 --- [p-nio-80-exec-1] c.l.springcloud.service.PaymentService   : [PaymentService#getPaymentById] &lt;--- HTTP/1.1 200 (66ms)</span><br><span class="line">2021-05-16 17:05:19.100 DEBUG 13352 --- [p-nio-80-exec-1] c.l.springcloud.service.PaymentService   : [PaymentService#getPaymentById] connection: keep-alive</span><br><span class="line">2021-05-16 17:05:19.100 DEBUG 13352 --- [p-nio-80-exec-1] c.l.springcloud.service.PaymentService   : [PaymentService#getPaymentById] content-type: application/json</span><br><span class="line">2021-05-16 17:05:19.100 DEBUG 13352 --- [p-nio-80-exec-1] c.l.springcloud.service.PaymentService   : [PaymentService#getPaymentById] date: Sun, 16 May 2021 09:05:19 GMT</span><br><span class="line">2021-05-16 17:05:19.100 DEBUG 13352 --- [p-nio-80-exec-1] c.l.springcloud.service.PaymentService   : [PaymentService#getPaymentById] keep-alive: timeout=60</span><br><span class="line">2021-05-16 17:05:19.100 DEBUG 13352 --- [p-nio-80-exec-1] c.l.springcloud.service.PaymentService   : [PaymentService#getPaymentById] transfer-encoding: chunked</span><br><span class="line">2021-05-16 17:05:19.100 DEBUG 13352 --- [p-nio-80-exec-1] c.l.springcloud.service.PaymentService   : [PaymentService#getPaymentById] </span><br><span class="line">2021-05-16 17:05:19.100 DEBUG 13352 --- [p-nio-80-exec-1] c.l.springcloud.service.PaymentService   : [PaymentService#getPaymentById] &#123;"code":200,"message":"success，端口：8001","data":null&#125;</span><br><span class="line">2021-05-16 17:05:19.100 DEBUG 13352 --- [p-nio-80-exec-1] c.l.springcloud.service.PaymentService   : [PaymentService#getPaymentById] &lt;--- END HTTP (60-byte body)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="服务雪崩、服务降级、服务熔断、服务限流"><a href="#服务雪崩、服务降级、服务熔断、服务限流" class="headerlink" title="服务雪崩、服务降级、服务熔断、服务限流"></a>服务雪崩、服务降级、服务熔断、服务限流</h1><h2 id="服务雪崩效应"><a href="#服务雪崩效应" class="headerlink" title="服务雪崩效应"></a>服务雪崩效应</h2><ul>
<li>是一种因“服务提供者的不可用”（原因）导致“服务调用者不可用”（结果），并将不可用逐渐放大的现象。</li>
</ul>
<h2 id="服务降级（fallback）"><a href="#服务降级（fallback）" class="headerlink" title="服务降级（fallback）"></a>服务降级（fallback）</h2><ul>
<li>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</li>
</ul>
<h2 id="服务熔断（break）"><a href="#服务熔断（break）" class="headerlink" title="服务熔断（break）"></a>服务熔断（break）</h2><ul>
<li>服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。</li>
</ul>
<h2 id="服务限流（flowlimit）"><a href="#服务限流（flowlimit）" class="headerlink" title="服务限流（flowlimit）"></a>服务限流（flowlimit）</h2><ul>
<li>为了防止某个消费者的QPS或是所有消费者的QPS总和突然飙升而导致的重要服务的失效，系统可以对访问流量进行控制，这种对集群的保护措施称为服务限流。</li>
</ul>
<h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><ul>
<li>Hystrix是一个延迟和容错库，旨在隔离对远程系统，服务和第三方库的访问点，停止级联故障，并在不可避免发生故障的复杂分布式系统中实现弹性。</li>
<li>服务降级情况<ul>
<li>程序运行异常</li>
<li>超时</li>
<li>服务熔断触发服务降级</li>
<li>线程池/信号量打满也会导致服务降级</li>
</ul>
</li>
</ul>
<h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>消费端 Feign 和 Hystrix 配合使用示例</p>
<blockquote>
<p>源码：cloud-consumer-feign-hystrix-order80</p>
</blockquote>
<ol>
<li><p>拷贝 Feign 项目作为基础</p>
</li>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>application .yml</code> 中添加 Feign 的 Hystrix 支持</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启 feign 的 hystrix 支持</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>main.java</code> 添加 <code>@EnableHystrix</code></p>
</li>
<li><p>controller 侧示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.learning.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.learning.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> com.learning.springcloud.service.PaymentService;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="comment">// hystrix 默认 fallback</span></span><br><span class="line"><span class="meta">@DefaultProperties</span>(defaultFallback = <span class="string">"fallback"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/timeout"</span>)</span><br><span class="line"><span class="comment">//    @HystrixCommand(fallbackMethod = "fallback",</span></span><br><span class="line">            <span class="comment">//设置这个线程的超时时间是3s，3s内是正常的业务逻辑，超过3s调用fallbackMethod指定的方法进行处理</span></span><br><span class="line"><span class="comment">//            commandProperties = &#123;@HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "3000")&#125;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;String&gt; <span class="title">timeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int a = 10/0;</span></span><br><span class="line">        <span class="keyword">return</span> paymentService.timeout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/ok"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">ok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentService.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;String&gt; <span class="title">fallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">500</span>, <span class="string">"消费侧fallback"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Service 层示例 </p>
<ol>
<li><p>PaymentService接口 <code>@FeignClient</code> 添加 <code>fallback = PaymentFallbackService.class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.learning.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.learning.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PROVIDER-HYSTRIX-PAYMENT"</span>, fallback = PaymentFallbackService<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/payment/ok"</span>)</span><br><span class="line">    <span class="function">CommonResult&lt;Payment&gt; <span class="title">ok</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/payment/timeout"</span>)</span><br><span class="line">    <span class="function">CommonResult&lt;String&gt; <span class="title">timeout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>PaymentFallbackService</code> 实现 <code>PaymentService</code> 接口，出现错误自动调用接口实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.learning.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.learning.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">ok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">500</span>, <span class="string">"出错啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;String&gt; <span class="title">timeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">500</span>, <span class="string">"出错啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<h3 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h3><p><img src="/images/java/springcloud/%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6.png" alt="熔断机制.png"></p>
<ul>
<li>断路器三个重要参数<ul>
<li>快照窗口期（circuitBreaker.sleepWindowInMilliseconds）：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的 <strong>10</strong> 秒</li>
<li>请求总数阈值（circuitBreaker.requestVloumeThreshold）：在快照时间窗内，必须满足请求总数阈值才有资格熔断， 默认为 <strong>20</strong> ，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开</li>
<li>错误百分比阈值（circuitBreaker.errorThresholdPercentage）：当请求总数在快照时间窗内超过了阈值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定 <strong>50%</strong> 阈值情况下，这时候就会将断路器打开</li>
</ul>
</li>
</ul>
<h4 id="服务端8001断路器示例"><a href="#服务端8001断路器示例" class="headerlink" title="服务端8001断路器示例"></a>服务端8001断路器示例</h4><blockquote>
<p> 源码：cloud-provider-hystrix-payment8001</p>
</blockquote>
<ol>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hystrix --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>main.java</code> 添加 <code>@EnableHystrix</code></p>
</li>
<li><p>在 <code>PaymentServiceImpl</code>  中添加如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务熔断</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentCircuitBreaker_fallback"</span>, commandProperties = &#123;</span><br><span class="line">    <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.enabled"</span>, value = <span class="string">"true"</span>),   <span class="comment">//是否开启断路器</span></span><br><span class="line">    <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.requestVolumeThreshold"</span>, value = <span class="string">"10"</span>),  <span class="comment">//请求次数</span></span><br><span class="line">    <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.sleepWindowInMilliseconds"</span>, value = <span class="string">"10000"</span>),    <span class="comment">//时间窗口期</span></span><br><span class="line">    <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.errorThresholdPercentage"</span>, value = <span class="string">"60"</span>),    <span class="comment">//失败率达到多少后跳闸</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"******id 不能为负数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String serialNumber = IdUtil.simpleUUID();  <span class="comment">//UUID.randomUUID();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"调用成功，流水号："</span> + serialNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker_fallback</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"id 不能负数，请稍后再试，o(╥﹏╥)o  id："</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>controller 中调用</p>
</li>
<li><p><a href="http://localhost:8001/payment/get/1" target="_blank" rel="noopener">localhost:8001/payment/get/1</a> 测试！！！当方法失败次数足够多时（在该方法中即id为负数），Hystrix将不再调用方法，此时方法状态为打开状态，直接调用fallback，直到时间窗口期过去，才会将方法状态改为半打开状态，如果继续失败则重新回到fallback窗口期，如果成功则关闭断路器。</p>
</li>
</ol>
<h3 id="HystrixDashboard"><a href="#HystrixDashboard" class="headerlink" title="HystrixDashboard"></a>HystrixDashboard</h3><blockquote>
<p>源码 cloud-consumer-hystrix-dashboard9001</p>
</blockquote>
<ol>
<li><p>新建9001项目</p>
</li>
<li><p>pom.xml 添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml 添加端口号</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span>  </span><br><span class="line">	<span class="attr">port:</span> <span class="number">9001</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动类添加注释 <code>@EnableHystrixDashboard</code></p>
</li>
<li><p>修改要监控的项目，如：cloud-provider-hystrix-payment8001，在主启动类添加如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此配置是为了服务监控而配置，与服务容错本身无关,SpringCloud升级后的坑</span></span><br><span class="line"><span class="comment"> * ServletRegistrationBean因为springboot的默认路径不是"/hystrix.stream"，</span></span><br><span class="line"><span class="comment"> * 只要在自己的项目里配置上下面的servlet就可以了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">    ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">    registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    registrationBean.addUrlMappings(<span class="string">"/hystrix.stream"</span>);</span><br><span class="line">    registrationBean.setName(<span class="string">"HystrixMetricsStreamServlet"</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问 <a href="http://localhost:9001/hystrix" target="_blank" rel="noopener">http://localhost:9001/hystrix</a> 如下界面添加监控地址 <a href="http://localhost:8001/hystrix.stream" target="_blank" rel="noopener">http://localhost:8001/hystrix.stream</a></p>
<p><img src="/images/java/springcloud/HystrixDashboard%E7%9B%91%E6%8E%A7%E9%A6%96%E9%A1%B5.png" alt="HystrixDashboard监控首页"></p>
<p><img src="/images/java/springcloud/HystrixDashboard%E7%9B%91%E6%8E%A7%E8%AF%A6%E6%83%85.png" alt="HystrixDashboard监控详情"></p>
</li>
</ol>
<ol start="7">
<li>访问 <a href="http://localhost:8001/" target="_blank" rel="noopener">http://localhost:8001/</a> 进行测试</li>
</ol>
<h1 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h1><p>为微服务云平台提供统一的入口是API网关最主要的用途，除此之外，网关还可承担认证授权、访问控制、路由、负载均衡、缓存、日志、限流限额、转换、映射、过滤、熔断、注册、服务编排、API管理、监控、统计分析等等非业务性的功能。</p>
<h2 id="Spring-Cloud-GateWay"><a href="#Spring-Cloud-GateWay" class="headerlink" title="Spring Cloud GateWay"></a>Spring Cloud GateWay</h2><p>参考文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/" target="_blank" rel="noopener">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/</a></p>
<ul>
<li><p><strong>Route</strong>：网关的基本构建块。 它由ID，目标URI，谓词集合和过滤器集合定义。 如果聚合谓词为true，则匹配路由。</p>
</li>
<li><p><strong>Predicate</strong>：这是Java 8函数谓词。 输入类型是Spring Framework ServerWebExchange。 这使您可以匹配HTTP请求中的所有内容，例如标头或参数。</p>
</li>
<li><p><strong>Filter</strong>：这些是已通过特定工厂构造的GatewayFilter实例。 在这里，您可以在发送下游请求之前或之后修改请求和响应。</p>
</li>
</ul>
<p>工作原理：</p>
<p><img src="/images/java/springcloud/spring_cloud_gateway_diagram.png" alt="Spring Cloud Gateway Diagram"></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><blockquote>
<p>源码 cloud-gateway-gateway9527</p>
</blockquote>
<ol>
<li><p>新建 <code>cloud-gateway-gateway9527</code></p>
</li>
<li><p>pom.xml 添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--gateway--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--eureka client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入自定义的api通用包，可使用Payment支付Entity--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.learning.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--一般基础配置类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml 开启从注册中心动态创建路由的功能，利用微服务名进行路由，配置文件进行路由配置示例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_route1</span>  <span class="comment"># 路由ID，没有固定规则但要求唯一</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001 # 匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span>  <span class="comment"># 匹配后提供服务的路由地址，lb表示负载均衡的意思</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>  <span class="comment"># 断言，路径匹配</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">After=2021-05-22T11:35:50.231+08:00[Asia/Shanghai]</span>  <span class="comment"># 在什么时间之后匹配路由，对应的有after，before，between</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_route2</span>  <span class="comment"># 路由ID，没有固定规则但要求唯一</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001 # 匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span>  <span class="comment"># 匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/create/**</span>  <span class="comment"># 断言，路径匹配</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 表示是否将自己注册进EurekaServer，默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从Eureka抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span> <span class="comment"># ,http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>GatewayMain9527</code> 添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码形式注册路由 <code>GatewayConfig.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.RouteLocator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置一个id为 path_baidu.news 的路由规则，</span></span><br><span class="line"><span class="comment">     * 当访问地址 http://localhost:9527/guonei 时会自动转发到地址：http://news.baidu.com/guonei</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routeLocatorBuilder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder routeLocatorBuilder)</span> </span>&#123;</span><br><span class="line">        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();</span><br><span class="line">        routes.route(<span class="string">"path_baidu.news"</span>,</span><br><span class="line">                r -&gt; r.path(<span class="string">"/guonei"</span>)</span><br><span class="line">                        .uri(<span class="string">"http://news.baidu.com/guonei"</span>)).build();</span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义Filter <code>MyFilter.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义filter，需继承GlobalFilter，实现filter方法</span></span><br><span class="line"><span class="comment"> * order表示执行顺序，order越小，优先级越高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"进入到自定义Filter MyFilter : "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">"uname"</span>);<span class="comment">//每次进来后判断带不带uname这个key</span></span><br><span class="line">        <span class="keyword">if</span> (uname == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"用户名为null，非法用户"</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="分布式配置中心"><a href="#分布式配置中心" class="headerlink" title="分布式配置中心"></a>分布式配置中心</h1><h2 id="bootstrap-yml-介绍"><a href="#bootstrap-yml-介绍" class="headerlink" title="bootstrap.yml 介绍"></a>bootstrap.yml 介绍</h2><p><strong>application.yml</strong> 是用户级的资源配置项</p>
<p><strong>bootstrap.yml</strong> 是系统级的，优先级更高</p>
<p>Spring Cloud 会创建一个 <strong>Bootstrap Context</strong> ，作为Spring应用的 <strong>Application Context</strong> 的父上下文。初始化的时候， <strong>Bootstrap Context</strong> 负责从外部源加载配置属性并解析配置。这两个上下文共享一个外部获取的 <strong>Environment</strong></p>
<p><strong>Bootstrap</strong> 属性有高优先级，默认情况下，他们不会被本地配置覆盖， <strong>Bootstrap context</strong> 和 <strong>Application Context</strong> 有着不同的约定，所以新增了一个 <strong>bootstrap.yml</strong> 文件，保证 <strong>Bootstrap Context</strong> 和 <strong>Application Context</strong> 配置的分离</p>
<h2 id="Spring-Cloud-Config-Spring-Cloud-Bus"><a href="#Spring-Cloud-Config-Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Config + Spring Cloud Bus"></a>Spring Cloud Config + Spring Cloud Bus</h2><blockquote>
<p>源码（未测试）：cloud-config-center-3344、cloud-config-client-3355、cloud-config-client-3366</p>
</blockquote>
<ol>
<li><p>新建 cloud-config-center-3344</p>
<ol>
<li>pom.xml 添加 <strong>spring-cloud-starter-bus-amqp、spring-cloud-config-server、spring-boot-starter-actuator</strong></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加消息总线RabbitMQ支持--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加<code>bootstrap.yml</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-config-center</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">git@github.com:******/cloud-config.git</span> <span class="comment">#github仓库上面的git仓库名字</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">cloud-config</span></span><br><span class="line">      <span class="comment"># 默认读取分支</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span> <span class="comment"># 注册进eureka</span></span><br><span class="line"><span class="comment">#暴露actuator端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'bus-refresh'</span>  <span class="comment"># 凡是暴露监控、刷新都要有actuator依赖，bus-refresh就是actuator的刷新操作</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>主启动类添加 <code>@EnableConfigServer</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigCenter3344</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigCenter3344<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建 cloud-config-client-3355</p>
<ol>
<li>pom.xml 添加 <strong>spring-cloud-starter-bus-amqp、spring-cloud-starter-config</strong></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加消息总线RabbitMQ支持--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加<code>bootstrap.yml</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span> <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称 上述3个综合：master分支上config-dev.yml的配置文件被读取 http://localhost:3344/master/config-dev.yml</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment">#配置中心地址</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span> <span class="comment"># 注册进eureka</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#暴露监控端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>主启动类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClient3355</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigClient3355<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>需要刷新配置的地方添加<code>@RefreshScope</code>注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;config.info&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String configInfo;  <span class="comment">//要访问的3344上的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/configInfo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建 cloud-config-client-3366 与 cloud-config-client-3355 基本一致</p>
</li>
<li><p>修改配置，刷新配置</p>
<ul>
<li>采用通过 cloud-config-center-3344 服务通知其他服务的方式，访问 <a href="http://localhost:3344/actuator/bus-refresh（新版：http://localhost:3344/actuator/busrefresh）（推荐）" target="_blank" rel="noopener">http://localhost:3344/actuator/bus-refresh（新版：http://localhost:3344/actuator/busrefresh）（推荐）</a></li>
<li>或者自己服务刷新的方式，访问<a href="http://localhost:3355/actuator/refresh" target="_blank" rel="noopener">http://localhost:3355/actuator/refresh</a></li>
<li>刷新部分服务<a href="http://localhost:3344/actuator/bus-refresh/{destination}（新版：http://localhost:3344/actuator/busrefresh/{destination}），例子http://localhost:3344/actuator/bus-refresh/cloud-config-client:3355" target="_blank" rel="noopener">http://localhost:3344/actuator/bus-refresh/{destination}（新版：http://localhost:3344/actuator/busrefresh/{destination}），例子http://localhost:3344/actuator/bus-refresh/cloud-config-client:3355</a></li>
</ul>
</li>
</ol>
<h1 id="消息驱动"><a href="#消息驱动" class="headerlink" title="消息驱动"></a>消息驱动</h1><h2 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h2><p>Spring Cloud Stream是一个框架，用于构建与共享消息传递系统连接的高度可扩展的事件驱动型微服务。该框架提供了一个灵活的编程模型，该模型建立在已经建立并熟悉的Spring习惯用法和最佳实践的基础上，包括对持久性发布/订阅语义，使用者组和有状态分区的支持。</p>
<h1 id="链路监控"><a href="#链路监控" class="headerlink" title="链路监控"></a>链路监控</h1><h2 id="Spring-Cloud-Sleuth-Spring-Cloud-Zipkin"><a href="#Spring-Cloud-Sleuth-Spring-Cloud-Zipkin" class="headerlink" title="Spring Cloud Sleuth + Spring Cloud Zipkin"></a>Spring Cloud Sleuth + Spring Cloud Zipkin</h2><blockquote>
<p>源码：在原来 cloud-provider-payment8001 和 cloud-consumer-feign-order80 基础上添加</p>
</blockquote>
<ol>
<li><p>docker安装<strong>Zipkin</strong></p>
</li>
<li><p>两边同时添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- zipkin 链路监控 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>两边同时修改<code>application.yml</code>，添加配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 整合链路监控</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">    <span class="attr">sleuth:</span></span><br><span class="line">      <span class="attr">sampler:</span></span><br><span class="line">        <span class="attr">probability:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>链路调用，访问 <a href="http://localhost:9411/zipkin/" target="_blank" rel="noopener">http://localhost:9411/zipkin/</a> 查看结果</p>
</li>
</ol>
<h1 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h1><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul>
<li><strong>服务限流降级</strong>：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li>
<li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li>
<li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li>
<li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li>
<li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。</li>
<li><strong>阿里云对象存储</strong>：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li><strong>分布式任务调度</strong>：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li>
<li><strong>阿里云短信服务</strong>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>
</ul>
<h2 id="已包含的组件"><a href="#已包含的组件" class="headerlink" title="已包含的组件"></a>已包含的组件</h2><p><strong>Sentinel</strong></p>
<p>阿里巴巴开源产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
<p><strong>Nacos</strong></p>
<p>阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p>
<p><strong>RocketMQ</strong></p>
<p>Apache RocketMQ™ 基于 Java 的高性能、高吞吐量的分布式消息和流计算平台。</p>
<p><strong>Dubbo</strong></p>
<p>Apache Dubbo™ 是一款高性能 Java RPC 框架。</p>
<p><strong>Seata</strong></p>
<p>阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</p>
<p><strong>Alibaba Cloud OSS</strong></p>
<p>阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</p>
<p><strong>Alibaba Cloud SchedulerX</strong></p>
<p>阿里中间件团队开发的一款分布式任务调度产品，支持周期性的任务与固定时间点触发任务。</p>
<p><strong>Alibaba Cloud SMS</strong></p>
<p>覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</p>
<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><ul>
<li>Nacos = Eureka + Config + Bus</li>
</ul>
<p><img src="/images/java/springcloud/nacos%E4%B8%8E%E5%85%B6%E4%BB%96%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%89%B9%E6%80%A7%E5%AF%B9%E6%AF%94.png" alt="nacos与其他注册中心特性对比.png"></p>
<h2 id="Nacos单机版搭建"><a href="#Nacos单机版搭建" class="headerlink" title="Nacos单机版搭建"></a>Nacos单机版搭建</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name nacos -e MODE=standalone -p 8848:8848 -d nacos/nacos-server</span><br></pre></td></tr></table></figure>

<p>网站：<a href="http://localhost:8848/nacos" target="_blank" rel="noopener">http://localhost:8848/nacos</a><br>账号：nacos<br>密码：nacos</p>
<h2 id="Nacos注册中心示例"><a href="#Nacos注册中心示例" class="headerlink" title="Nacos注册中心示例"></a>Nacos注册中心示例</h2><blockquote>
<p> 源码：cloudalibaba-provider-payment9001、cloudalibaba-provider-payment9002、cloudalibaba-consumer-nacos-order83</p>
</blockquote>
<ol>
<li><p>新建 cloudalibaba-provider-payment9001</p>
</li>
<li><p>pom添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--springcloud alibaba nacos--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.learning.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml 添加nacos注册服务</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置Nacos地址</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Main.java 添加 <code>@EnableDiscoveryClient</code> 注解</p>
</li>
<li><p>添加 controller</p>
</li>
<li><p>cloudalibaba-provider-payment9002 与 cloudalibaba-provider-payment9001 基本一致</p>
</li>
</ol>
<blockquote>
<p>consumer 端部分代码，cloudalibaba-consumer-nacos-order83</p>
</blockquote>
<ol>
<li><p>新增 cloudalibaba-consumer-nacos-order83</p>
</li>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.learning.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml 添加nacos注册服务</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称（成功注册进nacos的微服务提供者），在这配置了访问的服务，业务类就不用在定义常量了</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-payment-service:</span> <span class="string">http://nacos-payment-provider</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 <code>RestTemplateConfig</code> 配置，实现负载均衡，<code>nacos</code> 自带 <code>ribbon</code> 负载均衡</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplateConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>controller实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;service-url.nacos-payment-service&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String nacosUserService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/nacos/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(nacosUserService + <span class="string">"/payment/nacos/"</span> + id, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试 <a href="http://localhost:83/consumer/payment/nacos/1" target="_blank" rel="noopener">localhost:83/consumer/payment/nacos/1</a></p>
</li>
</ol>
<h2 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="dataid、group、namespace"><a href="#dataid、group、namespace" class="headerlink" title="dataid、group、namespace"></a>dataid、group、namespace</h4><ul>
<li><strong>dataid</strong>：Nacos 中的某个配置集的 ID。配置集 ID 是组织划分配置的维度之一。Data ID 通常用于组织划分系统的配置集。一个系统或者应用可以包含多个配置集，每个配置集都可以被一个有意义的名称标识。Data ID 通常采用类 Java 包（如 com.taobao.tc.refund.log.level）的命名规则保证全局唯一性。此命名规则非强制。这个概念来自于官方文档，说人话就是配置文件的名字，相当于主键的作用</li>
<li><strong>group(分组)</strong>: Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串（如 Buy 或 Trade ）对配置集进行分组，从而区分 Data ID 相同的配置集。当您在 Nacos 上创建一个配置时，如果未填写配置分组的名称，则配置分组的名称默认采用 DEFAULT_GROUP 。配置分组的常见场景：不同的应用或组件使用了相同的配置类型，如 database_url 配置和 MQ_topic 配置。说人话，就是可以分组，不同的系统或微服务的配置文件可以放在一个组里。比如用户系统和订单系统的配置文件都可以放在同个组中。</li>
<li><strong>命名空间(namespace)</strong>: 用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</li>
</ul>
<p>在 Nacos Spring Cloud 中，<code>dataId</code> 的完整格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>prefix</code> 默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</li>
<li><code>spring.profiles.active</code> 即为当前环境对应的 profile，详情可以参考 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html#boot-features-profiles" target="_blank" rel="noopener">Spring Boot文档</a>。 <strong>注意：当 <code>spring.profiles.active</code> 为空时，对应的连接符 <code>-</code> 也将不存在，dataId 的拼接格式变成 <code>${prefix}.${file-extension}</code></strong></li>
<li><code>file-exetension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置。目前只支持 <code>properties</code> 和 <code>yaml</code> 类型。</li>
</ul>
<h3 id="Nacos配置中心示例"><a href="#Nacos配置中心示例" class="headerlink" title="Nacos配置中心示例"></a>Nacos配置中心示例</h3><blockquote>
<p>源码：cloudalibaba-config-nacos-client3377</p>
</blockquote>
<ol>
<li><p>新建项目</p>
</li>
<li><p>添加pom依赖 <code>spring-cloud-starter-alibaba-nacos-config</code>、<code>spring-cloud-starter-alibaba-nacos-discovery</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.learning.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动类添加注解 <code>@EnableDiscoveryClient</code></p>
</li>
<li><p>添加 <code>bootstrap.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yml</span>   <span class="comment"># 文件后缀</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">TEST_GROUP</span>  <span class="comment"># 组</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">test</span>     <span class="comment"># 命名空间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 <code>application.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line"><span class="comment">#    active: dev #开发环境</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">test</span> <span class="comment">#测试环境</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>controller添加 <code>@RefreshScope</code> 注解，自动刷新配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span>   <span class="comment">//SpringCloud原生注解 支持Nacos的动态刷新功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;config.info&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/config/info"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <a href="http://localhost:8848/nacos/" target="_blank" rel="noopener">http://localhost:8848/nacos/</a> 中 命名空间 <code>public</code> 下添加  nacos-config-client-dev.yml 文件</p>
<p><img src="/images/java/springcloud/nacos%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE.png" alt="nacos测试配置.png"></p>
</li>
<li><p>测试 <a href="http://localhost:3377/config/info" target="_blank" rel="noopener">localhost:3377/config/info</a></p>
</li>
</ol>
<h2 id="Nacos集群"><a href="#Nacos集群" class="headerlink" title="Nacos集群"></a>Nacos集群</h2><p>略</p>
<h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><blockquote>
<p>官网 WIKI：<a href="https://github.com/alibaba/Sentinel/wiki" target="_blank" rel="noopener">Home · alibaba/Sentinel Wiki (github.com)</a></p>
<p>docker安装：docker run –name sentinel  -d -p 8858:8858 -d  bladex/sentinel-dashboard<br>账号：sentinel<br>密码：sentinel</p>
</blockquote>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><h3 id="并发线程数控制"><a href="#并发线程数控制" class="headerlink" title="并发线程数控制"></a>并发线程数控制</h3><p>并发数控制用于保护业务线程池不被慢调用耗尽。例如，当应用所依赖的下游应用由于某种原因导致服务不稳定、响应延迟增加，对于调用者来说，意味着吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽。为应对太多线程占用的情况，业内有使用隔离的方案，比如通过不同业务逻辑使用不同线程池来隔离业务自身之间的资源争抢（线程池隔离）。这种隔离方案虽然隔离性比较好，但是代价就是线程数目太多，线程上下文切换的 overhead 比较大，特别是对低延时的调用有比较大的影响。Sentinel 并发控制不负责创建和管理线程池，而是简单统计当前请求上下文的线程数目（正在执行的调用数目），如果超出阈值，新的请求会被立即拒绝，效果类似于信号量隔离。<strong>并发数控制通常在调用端进行配置。</strong></p>
<p>例子参见：<a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/FlowThreadDemo.java" target="_blank" rel="noopener">ThreadDemo</a></p>
<h3 id="QPS流量控制"><a href="#QPS流量控制" class="headerlink" title="QPS流量控制"></a>QPS流量控制</h3><p>当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的效果包括以下几种：<strong>直接拒绝</strong>、<strong>Warm Up</strong>、<strong>匀速排队</strong>。对应 <code>FlowRule</code> 中的 <code>controlBehavior</code> 字段。</p>
<blockquote>
<p>注意：若使用除了直接拒绝之外的流量控制效果，则调用关系限流策略（strategy）会被忽略。</p>
</blockquote>
<h4 id="直接拒绝"><a href="#直接拒绝" class="headerlink" title="直接拒绝"></a>直接拒绝</h4><p><strong>直接拒绝</strong>（<code>RuleConstant.CONTROL_BEHAVIOR_DEFAULT</code>）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出<code>FlowException</code>。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。具体的例子参见 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/FlowQpsDemo.java" target="_blank" rel="noopener">FlowQpsDemo</a>。</p>
<h4 id="Warm-Up"><a href="#Warm-Up" class="headerlink" title="Warm Up"></a>Warm Up</h4><p>Warm Up（<code>RuleConstant.CONTROL_BEHAVIOR_WARM_UP</code>）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 <a href="https://github.com/alibaba/Sentinel/wiki/限流---冷启动" target="_blank" rel="noopener">流量控制 - Warm Up 文档</a>，具体的例子可以参见 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/WarmUpFlowDemo.java" target="_blank" rel="noopener">WarmUpFlowDemo</a>。</p>
<p>通常冷启动的过程系统允许通过的 QPS 曲线如下图所示：</p>
<p>![通常冷启动的过程系统允许通过的 QPS 曲线.png](/images/java/springcloud/通常冷启动的过程系统允许通过的 QPS 曲线.png)</p>
<h4 id="匀速排队"><a href="#匀速排队" class="headerlink" title="匀速排队"></a>匀速排队</h4><p>匀速排队（<code>RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER</code>）方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。详细文档可以参考 <a href="https://github.com/alibaba/Sentinel/wiki/流量控制-匀速排队模式" target="_blank" rel="noopener">流量控制 - 匀速器模式</a>，具体的例子可以参见 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/PaceFlowDemo.java" target="_blank" rel="noopener">PaceFlowDemo</a>。</p>
<p>该方式的作用如下图所示：</p>
<p><img src="/images/java/springcloud/%E5%8C%80%E9%80%9F%E6%8E%92%E9%98%9F.png" alt="匀速排队.png"></p>
<p>这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p>
<blockquote>
<p>注意：匀速排队模式暂时不支持 QPS &gt; 1000 的场景。</p>
</blockquote>
<h2 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h2><p>Sentinel 提供以下几种熔断策略：</p>
<ul>
<li>慢调用比例 (<code>SLOW_REQUEST_RATIO</code>)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。</li>
<li>异常比例 (<code>ERROR_RATIO</code>)：当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</li>
<li>异常数 (<code>ERROR_COUNT</code>)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</li>
</ul>
<p>注意异常降级<strong>仅针对业务异常</strong>，对 Sentinel 限流降级本身的异常（<code>BlockException</code>）不生效。为了统计异常比例或异常数，需要通过 <code>Tracer.trace(ex)</code> 记录业务异常。</p>
<h2 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h2><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p>
<p>系统保护规则是应用整体维度的，而不是资源维度的，并且<strong>仅对入口流量生效</strong>。入口流量指的是进入应用的流量（<code>EntryType.IN</code>），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。</p>
<p>系统规则支持以下的模式：</p>
<ul>
<li><strong>Load 自适应</strong>（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li>
<li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li>
<li><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li>
<li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>
<li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li>
</ul>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>json 案例</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[    </span><br><span class="line">    &#123; 		</span><br><span class="line">        <span class="attr">"resource"</span>: <span class="string">"/byUrl"</span>,    	</span><br><span class="line">        <span class="attr">"limitApp"</span>: <span class="string">"default"</span>,    	</span><br><span class="line">        <span class="attr">"grade"</span>: <span class="number">1</span>,    	</span><br><span class="line">        <span class="attr">"count"</span>: <span class="number">1</span>,    	</span><br><span class="line">        <span class="attr">"strategy"</span>: <span class="number">0</span>,		</span><br><span class="line">        <span class="attr">"controlBehavior"</span>: <span class="number">0</span>,    	</span><br><span class="line">        <span class="attr">"clusterMode"</span>: <span class="literal">false</span>	</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>resource：资源名称</li>
<li>limitApp：来源应用</li>
<li>grade：阈值类型，0表示线程数，1表示QPS</li>
<li>count：单机阈值</li>
<li>strategy：流控模式，0表示直接，1表示关联，2表示链路；</li>
<li>controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待</li>
<li>clusterMode：是否集群</li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><ul>
<li><p>Sentinel整合+持久化到Nacos：cloudalibaba-sentinel-service8401</p>
</li>
<li><p>Sentinel + Ribbon + OpenFeign + fallback/blockHandler 示例：cloudalibaba-consumer-nacos-order85、cloudalibaba-provider-payment9003、cloudalibaba-provider-payment9004</p>
</li>
</ul>
<h1 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata_learning_order;</span><br><span class="line"><span class="keyword">USE</span> seata_learning_order;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">    user_id <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</span><br><span class="line">    product_id <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'产品id'</span>,</span><br><span class="line">    <span class="keyword">count</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'数量'</span>,</span><br><span class="line">    money <span class="built_in">DECIMAL</span>(<span class="number">11</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'金额'</span>,</span><br><span class="line">    <span class="keyword">status</span> <span class="built_in">INT</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单状态：0创建中，1已完结'</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">7</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`undo_log`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`branch_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`xid`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`context`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`rollback_info`</span> longblob <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_status`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_created`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_modified`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`ext`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>,<span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata_learning_storage;</span><br><span class="line"><span class="keyword">USE</span> seata_learning_storage;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_storage(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">    product_id <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'产品id'</span>,</span><br><span class="line">    total <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'总库存'</span>,</span><br><span class="line">    used <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'已用库存'</span>,</span><br><span class="line">    residue <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'剩余库存'</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">7</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_storage(<span class="keyword">id</span>, product_id, total, used, residue) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">100</span>,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`undo_log`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`branch_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`xid`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`context`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`rollback_info`</span> longblob <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_status`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_created`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_modified`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`ext`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>,<span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata_learning_account;</span><br><span class="line"><span class="keyword">USE</span> seata_learning_account;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_account(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">    user_id <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</span><br><span class="line">    total <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'总额度'</span>,</span><br><span class="line">    used <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'已用额度'</span>,</span><br><span class="line">    residue <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'剩余可用额度'</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">7</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_account(<span class="keyword">id</span>, user_id, total, used, residue) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1000</span>,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`undo_log`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`branch_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`xid`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`context`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`rollback_info`</span> longblob <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_status`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_created`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_modified`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`ext`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>,<span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h2 id="Seata-服务搭建"><a href="#Seata-服务搭建" class="headerlink" title="Seata 服务搭建"></a>Seata 服务搭建</h2><h3 id="Seata-Service"><a href="#Seata-Service" class="headerlink" title="Seata Service"></a>Seata Service</h3><blockquote>
<p>确保 nacos 容器和 seata 容器和 mysql 容器处于同一个自定义网络，后续需要使用服务名进行网络连通</p>
<p>Seata文件：<a href="/resources/java/springcloud/seata.7z">seata</a></p>
</blockquote>
<ol>
<li><p>运行nacos容器</p>
</li>
<li><p>运行seata容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name seata -p 8091:8091 seataio/seata-server:1.4.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>copy配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker cp seata:/seata-server/resources  D:\workspace\env\docker\seata\seata-config</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm -f seata</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件注册进nacos，配置文件位置：  D:\workspace\env\docker\seata\seata-config\registry.conf。若指定命名空间则配置文件进行相应调整，注意namespace的值为命名空间ID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  type &#x3D; &quot;nacos&quot;</span><br><span class="line">  loadBalance &#x3D; &quot;RandomLoadBalance&quot;</span><br><span class="line">  loadBalanceVirtualNodes &#x3D; 10</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    application &#x3D; &quot;seata-server&quot;</span><br><span class="line">    # 写自己的ip:port</span><br><span class="line">    serverAddr &#x3D; &quot;nacos:8848&quot;</span><br><span class="line">    group &#x3D; &quot;SEATA_GROUP&quot;</span><br><span class="line">    # 这里替换自己的namespace ID</span><br><span class="line">    namespace &#x3D; &quot;seata&quot;</span><br><span class="line">    username &#x3D; &quot;nacos&quot;</span><br><span class="line">    password &#x3D; &quot;nacos&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">config &#123;</span><br><span class="line">  type &#x3D; &quot;nacos&quot;</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;nacos:8848&quot;</span><br><span class="line">    namespace &#x3D; &quot;seata&quot;</span><br><span class="line">    group &#x3D; &quot;SEATA_GROUP&quot;</span><br><span class="line">    username &#x3D; &quot;nacos&quot;</span><br><span class="line">    password &#x3D; &quot;nacos&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>到github的seata源码库弄来两个文件，config.txt 、nacos/nacos-config.sh</p>
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fseata%2Fseata%2Ftree%2Fdevelop%2Fscript%2Fconfig-center" target="_blank" rel="noopener">https://github.com/seata/seata/tree/develop/script/config-center</a></p>
</li>
<li><p>配置文件位置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\workspace\env\docker\seata\seata-config\nacos-seata\config.txt</span><br><span class="line">D:\workspace\env\docker\seata\seata-config\nacos-seata\nacos\nacos-config.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改config.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这里 fps_tx_group 随意，但需与客户端保持一致</span><br><span class="line">service.vgroupMapping.fps_tx_group&#x3D;default</span><br><span class="line"></span><br><span class="line">store.db.driverClassName&#x3D;com.mysql.cj.jdbc.Driver</span><br><span class="line"># 这里替换自己的mysql地址</span><br><span class="line">store.db.url&#x3D;jdbc:mysql:&#x2F;&#x2F;mysql:3306&#x2F;seata?characterEncoding&#x3D;utf8&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC</span><br><span class="line">store.db.user&#x3D;root</span><br><span class="line">store.db.password&#x3D;123456</span><br><span class="line"></span><br><span class="line"># 添加存储模式</span><br><span class="line">store.mode&#x3D;db</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 .sh 文件，将seata配置推送到nacos</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:\workspace\env\docker\seata\seata-config\nacos-seata\nacos</span><br><span class="line">bash nacos-config.sh -h localhost -p 8848 -g SEATA_GROUP -t seata -u nacos -w nacos</span><br></pre></td></tr></table></figure>
</li>
<li><p>nacos配置列表</p>
<p><img src="/images/java/springcloud/nacos-seata%E9%85%8D%E7%BD%AE%E5%88%97%E8%A1%A8%E7%95%8C%E9%9D%A2.png" alt="nacos-seata配置列表界面.png"></p>
<p>seata配置成功推送至nacos</p>
</li>
<li><p>seata服务端，建立seata库，运行sql</p>
<p>[<a href="https://github.com/seata/seata/blob/develop/script/server/db/mysql.sql" target="_blank" rel="noopener">https://github.com/seata/seata/blob/develop/script/server/db/mysql.sql</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- -------------------------------- The script used when storeMode is &#39;db&#39; --------------------------------</span><br><span class="line">-- the table to store GlobalSession data</span><br><span class="line">CREATE TABLE IF NOT EXISTS &#96;global_table&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;xid&#96;                       VARCHAR(128) NOT NULL,</span><br><span class="line">    &#96;transaction_id&#96;            BIGINT,</span><br><span class="line">    &#96;status&#96;                    TINYINT      NOT NULL,</span><br><span class="line">    &#96;application_id&#96;            VARCHAR(32),</span><br><span class="line">    &#96;transaction_service_group&#96; VARCHAR(32),</span><br><span class="line">    &#96;transaction_name&#96;          VARCHAR(128),</span><br><span class="line">    &#96;timeout&#96;                   INT,</span><br><span class="line">    &#96;begin_time&#96;                BIGINT,</span><br><span class="line">    &#96;application_data&#96;          VARCHAR(2000),</span><br><span class="line">    &#96;gmt_create&#96;                DATETIME,</span><br><span class="line">    &#96;gmt_modified&#96;              DATETIME,</span><br><span class="line">    PRIMARY KEY (&#96;xid&#96;),</span><br><span class="line">    KEY &#96;idx_gmt_modified_status&#96; (&#96;gmt_modified&#96;, &#96;status&#96;),</span><br><span class="line">    KEY &#96;idx_transaction_id&#96; (&#96;transaction_id&#96;)</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br><span class="line"></span><br><span class="line">-- the table to store BranchSession data</span><br><span class="line">CREATE TABLE IF NOT EXISTS &#96;branch_table&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;branch_id&#96;         BIGINT       NOT NULL,</span><br><span class="line">    &#96;xid&#96;               VARCHAR(128) NOT NULL,</span><br><span class="line">    &#96;transaction_id&#96;    BIGINT,</span><br><span class="line">    &#96;resource_group_id&#96; VARCHAR(32),</span><br><span class="line">    &#96;resource_id&#96;       VARCHAR(256),</span><br><span class="line">    &#96;branch_type&#96;       VARCHAR(8),</span><br><span class="line">    &#96;status&#96;            TINYINT,</span><br><span class="line">    &#96;client_id&#96;         VARCHAR(64),</span><br><span class="line">    &#96;application_data&#96;  VARCHAR(2000),</span><br><span class="line">    &#96;gmt_create&#96;        DATETIME(6),</span><br><span class="line">    &#96;gmt_modified&#96;      DATETIME(6),</span><br><span class="line">    PRIMARY KEY (&#96;branch_id&#96;),</span><br><span class="line">    KEY &#96;idx_xid&#96; (&#96;xid&#96;)</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br><span class="line"></span><br><span class="line">-- the table to store lock data</span><br><span class="line">CREATE TABLE IF NOT EXISTS &#96;lock_table&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;row_key&#96;        VARCHAR(128) NOT NULL,</span><br><span class="line">    &#96;xid&#96;            VARCHAR(128),</span><br><span class="line">    &#96;transaction_id&#96; BIGINT,</span><br><span class="line">    &#96;branch_id&#96;      BIGINT       NOT NULL,</span><br><span class="line">    &#96;resource_id&#96;    VARCHAR(256),</span><br><span class="line">    &#96;table_name&#96;     VARCHAR(32),</span><br><span class="line">    &#96;pk&#96;             VARCHAR(36),</span><br><span class="line">    &#96;gmt_create&#96;     DATETIME,</span><br><span class="line">    &#96;gmt_modified&#96;   DATETIME,</span><br><span class="line">    PRIMARY KEY (&#96;row_key&#96;),</span><br><span class="line">    KEY &#96;idx_branch_id&#96; (&#96;branch_id&#96;)</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行seata容器并将配置文件挂载出来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里替换自己的ip</span></span><br><span class="line">docker run  -d --name seata -p 8091:8091  -e SEATA_IP=127.0.0.1 -e SEATA_CONFIG_NAME=file:/seata-server/resources/registry  -v ~/seata-config:/seata-server/resources seataio/seata-server:1.4.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看seata容器日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -f seata</span><br></pre></td></tr></table></figure>
</li>
<li><p>nacos服务列表</p>
<p><img src="/images/java/springcloud/nacos-seata-service%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8.png" alt="nacos-seata-service服务列表.png"></p>
<p>seata服务成功注册至nacos</p>
</li>
</ol>
<h3 id="Seata-Client"><a href="#Seata-Client" class="headerlink" title="Seata Client"></a>Seata Client</h3><blockquote>
<p>代码：seata-order-service2001、seata-storage-service2002、seata-account-service2003</p>
</blockquote>
<ol>
<li><p>创建模块 seata-order-service2001</p>
</li>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">2001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">seata-order-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">alibaba:</span></span><br><span class="line">      <span class="attr">seata:</span></span><br><span class="line">        <span class="comment">#自定义事务组名称需要与seata-server中的对应</span></span><br><span class="line">        <span class="attr">tx-service-group:</span> <span class="string">fsp_tx_group</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">"seata"</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/seata_learning_order?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">io:</span></span><br><span class="line">      <span class="attr">seata:</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>到github的seata源码库弄来两个文件，registry.conf。文件放到resource目录下<a href="https://github.com/seata/seata/tree/develop/script/client/conf，修改" target="_blank" rel="noopener">https://github.com/seata/seata/tree/develop/script/client/conf，修改</a> registry.conf 文件</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  <span class="meta"># file 、nacos 、eureka、redis、zk、consul、etcd3、sofa、custom</span></span><br><span class="line">  type = <span class="string">"nacos"</span></span><br><span class="line">  loadBalance = <span class="string">"RandomLoadBalance"</span></span><br><span class="line">  loadBalanceVirtualNodes = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    application = <span class="string">"seata-server"</span></span><br><span class="line">    <span class="meta"># 这里Nacos配置替换自己的ip、group、namespace ID</span></span><br><span class="line">    serverAddr = <span class="string">"127.0.0.1:8848"</span></span><br><span class="line">    <span class="keyword">group</span> = <span class="string">"SEATA_GROUP"</span></span><br><span class="line">    <span class="keyword">namespace</span> = <span class="string">"seata"</span></span><br><span class="line">    username = <span class="string">"nacos"</span></span><br><span class="line">    password = <span class="string">"nacos"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">config &#123;</span><br><span class="line">  <span class="meta"># file、nacos 、apollo、zk、consul、etcd3、springCloudConfig、custom</span></span><br><span class="line">  type = <span class="string">"nacos"</span></span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = <span class="string">"127.0.0.1:8848"</span></span><br><span class="line">    <span class="keyword">namespace</span> = <span class="string">"seata"</span></span><br><span class="line">    <span class="keyword">group</span> = <span class="string">"SEATA_GROUP"</span></span><br><span class="line">    username = <span class="string">"nacos"</span></span><br><span class="line">    password = <span class="string">"nacos"</span></span><br><span class="line">    <span class="meta"># dataId = "seata.properties"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全部代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa、custom</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa、custom</span><br><span class="line">  type &#x3D; &quot;file&quot;</span><br><span class="line">  loadBalance &#x3D; &quot;RandomLoadBalance&quot;</span><br><span class="line">  loadBalanceVirtualNodes &#x3D; 10</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    application &#x3D; &quot;seata-server&quot;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:8848&quot;</span><br><span class="line">    group &#x3D; &quot;SEATA_GROUP&quot;</span><br><span class="line">    namespace &#x3D; &quot;seata&quot;</span><br><span class="line">    username &#x3D; &quot;nacos&quot;</span><br><span class="line">    password &#x3D; &quot;nacos&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl &#x3D; &quot;http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&quot;</span><br><span class="line">    weight &#x3D; &quot;1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  redis &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;localhost:6379&quot;</span><br><span class="line">    db &#x3D; &quot;0&quot;</span><br><span class="line">    password &#x3D; &quot;&quot;</span><br><span class="line">    timeout &#x3D; &quot;0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:2181&quot;</span><br><span class="line">    sessionTimeout &#x3D; 6000</span><br><span class="line">    connectTimeout &#x3D; 2000</span><br><span class="line">    username &#x3D; &quot;&quot;</span><br><span class="line">    password &#x3D; &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:8500&quot;</span><br><span class="line">    aclToken &#x3D; &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;http:&#x2F;&#x2F;localhost:2379&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  sofa &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:9603&quot;</span><br><span class="line">    region &#x3D; &quot;DEFAULT_ZONE&quot;</span><br><span class="line">    datacenter &#x3D; &quot;DefaultDataCenter&quot;</span><br><span class="line">    group &#x3D; &quot;SEATA_GROUP&quot;</span><br><span class="line">    addressWaitTime &#x3D; &quot;3000&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name &#x3D; &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  custom &#123;</span><br><span class="line">    name &#x3D; &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config &#123;</span><br><span class="line">  # file、nacos 、apollo、zk、consul、etcd3、springCloudConfig、custom</span><br><span class="line">  type &#x3D; &quot;nacos&quot;</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:8848&quot;</span><br><span class="line">    namespace &#x3D; &quot;seata&quot;</span><br><span class="line">    group &#x3D; &quot;SEATA_GROUP&quot;</span><br><span class="line">    username &#x3D; &quot;nacos&quot;</span><br><span class="line">    password &#x3D; &quot;nacos&quot;</span><br><span class="line">    # dataId &#x3D; &quot;seata.properties&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:8500&quot;</span><br><span class="line">    aclToken &#x3D; &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  apollo &#123;</span><br><span class="line">    appId &#x3D; &quot;seata-server&quot;</span><br><span class="line">    apolloMeta &#x3D; &quot;http:&#x2F;&#x2F;192.168.1.204:8801&quot;</span><br><span class="line">    namespace &#x3D; &quot;application&quot;</span><br><span class="line">    apolloAccesskeySecret &#x3D; &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:2181&quot;</span><br><span class="line">    sessionTimeout &#x3D; 6000</span><br><span class="line">    connectTimeout &#x3D; 2000</span><br><span class="line">    username &#x3D; &quot;&quot;</span><br><span class="line">    password &#x3D; &quot;&quot;</span><br><span class="line">    nodePath &#x3D; &quot;&#x2F;seata&#x2F;seata.properties&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;http:&#x2F;&#x2F;localhost:2379&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name &#x3D; &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  custom &#123;</span><br><span class="line">    name &#x3D; &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在业务数据库下建立undo_log表，用于回滚，Seata官方GitHub源码库sql脚本链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- for AT mode you must to init this sql for you business database. the seata server not need it.</span><br><span class="line">CREATE TABLE IF NOT EXISTS &#96;undo_log&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;branch_id&#96;     BIGINT       NOT NULL COMMENT &#39;branch transaction id&#39;,</span><br><span class="line">    &#96;xid&#96;           VARCHAR(128) NOT NULL COMMENT &#39;global transaction id&#39;,</span><br><span class="line">    &#96;context&#96;       VARCHAR(128) NOT NULL COMMENT &#39;undo_log context,such as serialization&#39;,</span><br><span class="line">    &#96;rollback_info&#96; LONGBLOB     NOT NULL COMMENT &#39;rollback info&#39;,</span><br><span class="line">    &#96;log_status&#96;    INT(11)      NOT NULL COMMENT &#39;0:normal status,1:defense status&#39;,</span><br><span class="line">    &#96;log_created&#96;   DATETIME(6)  NOT NULL COMMENT &#39;create datetime&#39;,</span><br><span class="line">    &#96;log_modified&#96;  DATETIME(6)  NOT NULL COMMENT &#39;modify datetime&#39;,</span><br><span class="line">    UNIQUE KEY &#96;ux_undo_log&#96; (&#96;xid&#96;, &#96;branch_id&#96;)</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  AUTO_INCREMENT &#x3D; 1</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8 COMMENT &#x3D;&#39;AT transaction mode undo table&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span>(exclude = DataSourceAutoConfiguration<span class="class">.<span class="keyword">class</span>)//取消数据源的自带创建</span></span><br><span class="line"><span class="class">@<span class="title">EnableFeignClients</span></span></span><br><span class="line"><span class="class">@<span class="title">EnableDiscoveryClient</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SeataOrderMainApp2001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SeataOrderMainApp2001<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加MyBatis配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.datasource.DataSourceProxy;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionTemplate;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(&#123;<span class="string">"com.learning.springcloud.dao"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mybatis.mapper-locations&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String mapperLocations;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sqlSessionFactory SqlSessionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SqlSessionTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置文件获取属性构造datasource，注意前缀，这里用的是druid，根据自己情况配置,</span></span><br><span class="line"><span class="comment">     * 原生datasource前缀取"spring.datasource"</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造datasource代理对象，替换原来的datasource</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> druidDataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceProxy <span class="title">dataSourceProxy</span><span class="params">(DataSource druidDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProxy(druidDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"sqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactoryBean</span><span class="params">(DataSourceProxy dataSourceProxy)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean bean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSourceProxy);</span><br><span class="line">        ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">        bean.setMapperLocations(resolver.getResources(mapperLocations));</span><br><span class="line"></span><br><span class="line">        SqlSessionFactory factory;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            factory = bean.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建表语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata_learning_order;</span><br><span class="line"><span class="keyword">USE</span> seata_learning_storage;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_storage(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">    product_id <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> 产品<span class="keyword">id</span>,</span><br><span class="line">    total <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> 总库存,</span><br><span class="line">    used <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> 已用库存,</span><br><span class="line">    residue <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> 剩余库存</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">7</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_storage(<span class="keyword">id</span>, product_id, total, used, residue) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">100</span>,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata_learning_storage;</span><br><span class="line"><span class="keyword">USE</span> seata_learning_storage;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_storage(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">    product_id <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'产品id'</span>,</span><br><span class="line">    total <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'总库存'</span>,</span><br><span class="line">    used <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'已用库存'</span>,</span><br><span class="line">    residue <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'剩余库存'</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">7</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_storage(<span class="keyword">id</span>, product_id, total, used, residue) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">100</span>,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata_learning_account;</span><br><span class="line"><span class="keyword">USE</span> seata_learning_account;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_account(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">    user_id <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</span><br><span class="line">    total <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'总额度'</span>,</span><br><span class="line">    used <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'已用额度'</span>,</span><br><span class="line">    residue <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'剩余可用额度'</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">7</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_account(<span class="keyword">id</span>, user_id, total, used, residue) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1000</span>,<span class="number">0</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 seata log：<code>docker logs seata</code>，出现如下信息，done！</p>
<p><img src="/images/java/springcloud/docker-seata-logs.png" alt="docker-seata-logs.png"></p>
</li>
<li><p>使用 <code>GlobalTransactional</code> 注解开启事务</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>ES</title>
    <url>/2021/06/10/database/ES/</url>
    <content><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>详见 docker 文档</p>
<p>访问 <a href="http://127.0.0.1:9200/" target="_blank" rel="noopener">127.0.0.1:9200</a></p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>Elasticsearch 是面向文档型数据库，一条数据在这里就是一个文档。为了方便大家理解，我们将 Elasticsearch 里存储文档数据和关系型数据库 MySQL 存储数据的概念进行一个类比ES 里的 Index 可以看做一个库，而 Types 相当于表，Documents 则相当于表的行。这里 Types 的概念已经被逐渐弱化，Elasticsearch 6.X 中，一个 index 下已经只能包含一个type，Elasticsearch 7.X 中, Type 的概念已经被删除了。</p>
<p><img src="/images/database/es/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.png" alt="数据格式.png"></p>
<h2 id="HTTP-操作"><a href="#HTTP-操作" class="headerlink" title="HTTP 操作"></a><strong>HTTP</strong> 操作</h2><h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><blockquote>
<p>对比关系型数据库，创建索引就等同于创建数据库</p>
</blockquote>
<p>在 Postman 中，向 ES 服务器发 <strong>PUT</strong> 请求 ：<a href="http://127.0.0.1:9200/shopping" target="_blank" rel="noopener">http://127.0.0.1:9200/shopping</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	"acknowledged"【响应结果】: true, # true操作成功</span><br><span class="line">	"shards_acknowledged"【分片结果】: true, # 分片操作成功</span><br><span class="line">	"index"【索引名称】: "shopping"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果重复添加索引，会返回错误信息</p>
<p>注意：创建索引库的分片数默认 1片，在 7.0.0之前的 Elasticsearch版本中，默认 5片</p>
</blockquote>
<h4 id="查看所有索引"><a href="#查看所有索引" class="headerlink" title="查看所有索引"></a>查看所有索引</h4><p>在 Postman 中，向 ES 服务器发 <strong>GET</strong> 请求 ：<a href="http://127.0.0.1:9200/_cat/indices?v" target="_blank" rel="noopener">http://127.0.0.1:9200/_cat/indices?v</a></p>
<p><img src="/images/database/es/%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%B4%A2%E5%BC%95.png" alt="查看所有索引.png"></p>
<table>
<thead>
<tr>
<th>表头</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>health</td>
<td>当前服务器健康状态：<strong>green</strong>(集群完整) <strong>yellow</strong>(单点正常、集群不完整) red(单点不正常)</td>
</tr>
<tr>
<td>status</td>
<td>索引打开、关闭状态</td>
</tr>
<tr>
<td>index</td>
<td>索引名</td>
</tr>
<tr>
<td>uuid</td>
<td>索引统一编号</td>
</tr>
<tr>
<td>pri</td>
<td>主分片数量</td>
</tr>
<tr>
<td>rep</td>
<td>副本数量</td>
</tr>
<tr>
<td>docs.count</td>
<td>可用文档数量</td>
</tr>
<tr>
<td>docs.deleted</td>
<td>文档删除状态（逻辑删除）</td>
</tr>
<tr>
<td>store.size</td>
<td>主分片和副分片整体占空间大小</td>
</tr>
<tr>
<td>pri.store.size</td>
<td>主分片占空间大小</td>
</tr>
</tbody></table>
<h4 id="查看单个索引"><a href="#查看单个索引" class="headerlink" title="查看单个索引"></a>查看单个索引</h4><p>在 Postman 中，向 ES 服务器发 <strong>GET</strong> 请求 :<a href="http://127.0.0.1:9200/shopping" target="_blank" rel="noopener">http://127.0.0.1:9200/shopping</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	"shopping"【索引名】: &#123;</span><br><span class="line">		"aliases"【别名】: &#123;&#125;,</span><br><span class="line">		"mappings"【映射】: &#123;&#125;,</span><br><span class="line">		"settings"【设置】: &#123;</span><br><span class="line">			"index"【设置 - 索引】: &#123;</span><br><span class="line">				"creation_date"【设置 - 索引 - 创建时间】: "1614265373911",</span><br><span class="line">				"number_of_shards"【设置 - 索引 - 主分片数量】: "1",</span><br><span class="line">				"number_of_replicas"【设置 - 索引 - 副分片数量】: "1",</span><br><span class="line">				"uuid"【设置 - 索引 - 唯一标识】: "eI5wemRERTumxGCc1bAk2A",</span><br><span class="line">				"version"【设置 - 索引 - 版本】: &#123;</span><br><span class="line">					"created": "7080099"</span><br><span class="line">				&#125;,</span><br><span class="line">				"provided_name"【设置 - 索引 - 名称】: "shopping"</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p>在 Postman 中，向 ES 服务器发 <strong>DELETE</strong> 请求 <a href="http://127.0.0.1:9200/_cat/indices?v" target="_blank" rel="noopener">：</a><a href="http://127.0.0.1:9200/_cat/indices?v" target="_blank" rel="noopener">http://127.0.0.1:9200/sho</a>pping</p>
<p><img src="/images/database/es/%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95.png" alt="删除索引.png"></p>
<h3 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h3><h4 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h4><p>在 Postman 中，向 ES 服务器发 <strong>POST</strong> 请求 <a href="http://127.0.0.1:9200/_cat/indices?v" target="_blank" rel="noopener">：</a><a href="http://127.0.0.1:9200/_cat/indices?v" target="_blank" rel="noopener">http://127.0.0.1:9200/shop</a>ping<strong>/_doc</strong></p>
<p>请求体内容为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"title"</span>:<span class="string">"小米手机"</span>,</span><br><span class="line">	<span class="attr">"category"</span>:<span class="string">"小米"</span>,</span><br><span class="line">	<span class="attr">"images"</span>:<span class="string">"http://www.gulixueyuan.com/xm.jpg"</span>,</span><br><span class="line">	<span class="attr">"price"</span>:<span class="number">3999.00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>响应：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	"_index"【索引】: "shopping",</span><br><span class="line">	"_type"【类型-文档】: "_doc",</span><br><span class="line">	"_id"【唯一标识】: "Xhsa2ncBlvF_7lxyCE9G", #可以类比为 MySQL中的主键，随机生成</span><br><span class="line">	"_version"【版本】: 1,</span><br><span class="line">	"result"【结果】: "created", #这里的 create表示创建成功</span><br><span class="line">	"_shards"【分片】: &#123;</span><br><span class="line">		"total"【分片 - 总数】: 2,</span><br><span class="line">		"successful"【分片 - 成功】: 1,</span><br><span class="line">		"failed"【分片 - 失败】: 0</span><br><span class="line">	&#125;,</span><br><span class="line">	"_seq_no": 0,</span><br><span class="line">	"_primary_term": 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的数据创建后，由于没有指定数据唯一性标识（ID），默认情况下，ES 服务器会随机生成一个。</p>
<p>如果想要自定义唯一性标识，需要在创建时指定：<a href="http://127.0.0.1:9200/shopping/_doc/1" target="_blank" rel="noopener">http://127.0.0.1:9200/shopping/_doc/1</a></p>
<h4 id="查看文档"><a href="#查看文档" class="headerlink" title="查看文档"></a>查看文档</h4><p>查看文档时，需要指明文档的唯一性标识，类似于 MySQL 中数据的主键查询</p>
<p>在 Postman 中，向 ES 服务器发 <strong>GET</strong> 请求 ：<a href="http://127.0.0.1:9200/shopping/_doc/1" target="_blank" rel="noopener">http://127.0.0.1:9200/shopping/_doc/1</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	"_index"【索引】: "shopping",</span><br><span class="line">	"_type"【文档类型】: "_doc",</span><br><span class="line">	"_id": "1",</span><br><span class="line">	"_version": 2,</span><br><span class="line">	"_seq_no": 2,</span><br><span class="line">	"_primary_term": 2,</span><br><span class="line">	"found"【查询结果】: true, # true表示查找到，false表示未查找到</span><br><span class="line">	"_source"【文档源信息】: &#123;</span><br><span class="line">		"title": "华为手机",</span><br><span class="line">		"category": "华为",</span><br><span class="line">		"images": "http://www.gulixueyuan.com/hw.jpg",</span><br><span class="line">		"price": 4999.00</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h4><p>和新增文档一样，输入相同的 URL 地址请求，如果请求体变化，会将原有的数据内容覆盖在 Postman 中，向 ES 服务器发 <strong>POST</strong> 请求 ：<a href="http://127.0.0.1:9200/shopping/_doc/1" target="_blank" rel="noopener">http://127.0.0.1:9200/shopping/_doc/1</a></p>
<p>请求体内容为:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"title"</span>:<span class="string">"华为手机"</span>,</span><br><span class="line">	<span class="attr">"category"</span>:<span class="string">"华为"</span>,</span><br><span class="line">	<span class="attr">"images"</span>:<span class="string">"http://www.gulixueyuan.com/hw.jpg"</span>,</span><br><span class="line">	<span class="attr">"price"</span>:<span class="number">4999.00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>响应：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"_index"</span>: <span class="string">"shopping"</span>,</span><br><span class="line">	<span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">	<span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">	"_version"【版本】: 2,</span><br><span class="line">	"result"【结果】: "updated", # updated表示数据被更新</span><br><span class="line">	"_shards": &#123;</span><br><span class="line">		"total": 2,</span><br><span class="line">		"successful": 1,</span><br><span class="line">		"failed": 0</span><br><span class="line">	&#125;,</span><br><span class="line">	"_seq_no": 2,</span><br><span class="line">	"_primary_term": 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h4><p>修改数据时，也可以只修改某一给条数据的局部信息</p>
<p>在 Postman 中，向 ES 服务器发 <strong>POST</strong> 请求 ：<a href="http://127.0.0.1:9200/shopping/**_update/1" target="_blank" rel="noopener">http://127.0.0.1:9200/shopping/**_update/1</a>**</p>
<p>请求体内容为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"doc"</span>: &#123;</span><br><span class="line">		<span class="attr">"price"</span>:<span class="number">3000.00</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改成功后，服务器响应结果：</p>
<p><img src="/images/database/es/%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C-%E4%BF%AE%E6%94%B9%E5%AD%97%E6%AE%B5.png" alt="文档操作-修改字段.png"></p>
<h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><p>删除一个文档不会立即从磁盘上移除，它只是被标记成已删除（逻辑删除）。</p>
<p>在 Postman 中，向 ES 服务器发 <strong>DELETE</strong> 请求 ：<a href="http://127.0.0.1:9200/shopping**/_doc/1" target="_blank" rel="noopener">http://127.0.0.1:9200/shopping**/_doc/1</a>**</p>
<p>删除成功，服务器响应结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"_index"</span>: <span class="string">"shopping"</span>,</span><br><span class="line">	<span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">	<span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">	"_version"【版本】: 4, #对数据的操作，都会更新版本</span><br><span class="line">	"result"【结果】: "deleted", # deleted表示数据被标记为删除</span><br><span class="line">	"_shards": &#123;</span><br><span class="line">		"total": 2,</span><br><span class="line">		"successful": 1,</span><br><span class="line">		"failed": 0</span><br><span class="line">	&#125;,</span><br><span class="line">	"_seq_no": 4,</span><br><span class="line">	"_primary_term": 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果删除一个并不存在的文档</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"_index"</span>: <span class="string">"shopping"</span>,</span><br><span class="line">	<span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">	<span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">	<span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">	"result"【结果】: "not_found", # not_found表示未查找到</span><br><span class="line">	"_shards": &#123;</span><br><span class="line">		"total": 2,</span><br><span class="line">		"successful": 1,</span><br><span class="line">		"failed": 0</span><br><span class="line">	&#125;,</span><br><span class="line">	"_seq_no": 5,</span><br><span class="line">	"_primary_term": 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件删除文档"><a href="#条件删除文档" class="headerlink" title="条件删除文档"></a>条件删除文档</h4><p>一般删除数据都是根据文档的唯一性标识进行删除，实际操作时，也可以根据条件对多条数据进行删除</p>
<p>向 ES 服务器发 <strong>POST</strong> 请求 ：<a href="http://127.0.0.1:9200/shopping/_delete_by_query" target="_blank" rel="noopener">http://127.0.0.1:9200/shopping/_delete_by_query</a></p>
<p>请求体内容为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span>:&#123;</span><br><span class="line">		<span class="attr">"match"</span>:&#123;</span><br><span class="line">			<span class="attr">"price"</span>:<span class="number">4000.00</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除成功后，服务器响应结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	"took"【耗时】: 175,</span><br><span class="line">	"timed_out"【是否超时】: false,</span><br><span class="line">	"total"【总数】: 2,</span><br><span class="line">	"deleted"【删除数量】: 2,</span><br><span class="line">	"batches": 1,</span><br><span class="line">	"version_conflicts": 0,</span><br><span class="line">	"noops": 0,</span><br><span class="line">	"retries": &#123;</span><br><span class="line">		"bulk": 0,</span><br><span class="line">		"search": 0</span><br><span class="line">	&#125;,</span><br><span class="line">	"throttled_millis": 0,</span><br><span class="line">	"requests_per_second": -1.0,</span><br><span class="line">	"throttled_until_millis": 0,</span><br><span class="line">	"failures": []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="映射操作"><a href="#映射操作" class="headerlink" title="映射操作"></a>映射操作</h3><p>有了索引库，等于有了数据库中的 database。</p>
<p>接下来就需要建索引库(index)中的映射了，类似于数据库(database)中的表结构(table)。创建数据库表需要设置字段名称，类型，长度，约束等；索引库也一样，需要知道这个类型下有哪些字段，每个字段有哪些约束信息，这就叫做映射(mapping)</p>
<h3 id="创建映射"><a href="#创建映射" class="headerlink" title="创建映射"></a>创建映射</h3><p>在 Postman 中，向 ES 服务器发 <strong>PUT</strong> 请求 ：<a href="http://127.0.0.1:9200/student/_mapping" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_mapping</a></p>
<p>请求体内容为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"properties"</span>: &#123;</span><br><span class="line">		<span class="attr">"name"</span>:&#123;</span><br><span class="line">			<span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">			<span class="attr">"index"</span>: <span class="literal">true</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">"sex"</span>:&#123;</span><br><span class="line">			<span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">			<span class="attr">"index"</span>: <span class="literal">false</span></span><br><span class="line">		&#125;,</span><br><span class="line">    	<span class="attr">"age"</span>:&#123;</span><br><span class="line">			<span class="attr">"type"</span>: <span class="string">"long"</span>,</span><br><span class="line">            <span class="attr">"index"</span>: <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果如下：</p>
<p><img src="/images/database/es/%E5%88%9B%E5%BB%BA%E6%98%A0%E5%B0%84.png" alt="创建映射.png"></p>
<p>映射数据说明：</p>
<ul>
<li><p>字段名：任意填写，下面指定许多属性，例如：title、subtitle、images、price</p>
</li>
<li><p>type：类型，Elasticsearch 中支持的数据类型非常丰富，说几个关键的：</p>
<ul>
<li><p>String 类型，又分两种：</p>
<ul>
<li><p>text：可分词</p>
</li>
<li><p>keyword：不可分词，数据会作为完整字段进行匹配</p>
</li>
</ul>
</li>
<li><p>Numerical：数值类型，分两类</p>
<p>基本数据类型：long、integer、short、byte、double、float、half_float</p>
<p>浮点数的高精度类型：scaled_float</p>
</li>
<li><p>Date：日期类型</p>
</li>
<li><p>Array：数组类型</p>
</li>
<li><p>Object：对象</p>
</li>
<li><p>index：是否索引，默认为 true，也就是说你不进行任何配置，所有字段都会被索引。</p>
<ul>
<li><p>true：字段会被索引，则可以用来进行搜索</p>
</li>
<li><p>false：字段不会被索引，不能用来搜索</p>
</li>
</ul>
</li>
<li><p>store：是否将数据进行独立存储，默认为 false</p>
</li>
</ul>
<p>原始的文本会存储在_source 里面，默认情况下其他提取出来的字段都不是独立存储的，是从_source 里面提取出来的。当然你也可以独立的存储某个字段，只要设置”store”: true 即可，获取独立存储的字段要比从_source 中解析快得多，但是也会占用更多的空间，所以要根据实际业务需求来设置。</p>
<ul>
<li>analyzer：分词器，这里的 ik_max_word 即使用 ik 分词器,后面会有专门的章节学习</li>
</ul>
</li>
</ul>
<h4 id="查看映射"><a href="#查看映射" class="headerlink" title="查看映射"></a>查看映射</h4><p>在 Postman 中，向 ES 服务器发 <strong>GET</strong> 请求 ：<a href="http://127.0.0.1:9200/student**/_mapping" target="_blank" rel="noopener">http://127.0.0.1:9200/student**/_mapping</a>**</p>
<p>服务器响应结果如下：</p>
<p><img src="/images/database/es/%E6%9F%A5%E7%9C%8B%E6%98%A0%E5%B0%84.png" alt="查看映射.png"></p>
<h4 id="索引映射关联"><a href="#索引映射关联" class="headerlink" title="索引映射关联"></a>索引映射关联</h4><p>在 Postman 中，向 ES 服务器发 <strong>PUT</strong> 请求 ：<a href="http://127.0.0.1:9200/student1" target="_blank" rel="noopener">http://127.0.0.1:9200/student1</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">	<span class="attr">"mappings"</span>: &#123;</span><br><span class="line">		<span class="attr">"properties"</span>: &#123;</span><br><span class="line">			<span class="attr">"name"</span>:&#123;</span><br><span class="line">				<span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">				<span class="attr">"index"</span>: <span class="literal">true</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">"sex"</span>:&#123;</span><br><span class="line">				<span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">				<span class="attr">"index"</span>: <span class="literal">false</span></span><br><span class="line">			&#125;,</span><br><span class="line">            <span class="attr">"age"</span>:&#123;</span><br><span class="line">				<span class="attr">"type"</span>: <span class="string">"long"</span>,</span><br><span class="line">				<span class="attr">"index"</span>: <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果如下：</p>
<p><img src="/images/database/es/%E7%B4%A2%E5%BC%95%E6%98%A0%E5%B0%84%E5%85%B3%E8%81%94.png" alt="索引映射关联.png"></p>
<h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><p>Elasticsearch 提供了基于 JSON 提供完整的查询 DSL 来定义查询</p>
<h4 id="查询所有文档"><a href="#查询所有文档" class="headerlink" title="查询所有文档"></a>查询所有文档</h4><p>在 Postman 中，向 ES 服务器发 <strong>GET</strong> 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span>: &#123;</span><br><span class="line">		<span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"># "query"：这里的 query代表一个查询对象，里面可以有不同的查询属性</span><br><span class="line"># "match_all"：查询类型，例如：match_all(代表查询所有)， match，term ， range 等等</span><br><span class="line"># &#123;查询条件&#125;：查询条件会根据类型的不同，写法也有差异</span><br></pre></td></tr></table></figure>

<p>服务器响应结果如下：</p>
<p><img src="/images/database/es/%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E6%96%87%E6%A1%A3.png" alt="查询所有文档.png"></p>
<p><img src="/images/database/es/%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E6%96%87%E6%A1%A32.png" alt="查询所有文档2.png"></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"took【查询花费时间，单位毫秒】"</span> : <span class="number">1116</span>,</span><br><span class="line">	<span class="attr">"timed_out【是否超时】"</span> : <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"_shards【分片信息】"</span> : &#123;</span><br><span class="line">		<span class="attr">"total【总数】"</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="attr">"successful【成功】"</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="attr">"skipped【忽略】"</span> : <span class="number">0</span>,</span><br><span class="line">		<span class="attr">"failed【失败】"</span> : <span class="number">0</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"hits【搜索命中结果】"</span> : &#123;</span><br><span class="line">		"total"【搜索条件匹配的文档总数】: &#123;</span><br><span class="line">			"value"【总命中计数的值】: 3,</span><br><span class="line">			"relation"【计数规则】: "eq" # eq 表示计数准确， gte表示计数不准确</span><br><span class="line">	&#125;,</span><br><span class="line">		"max_score【匹配度分值】" : 1.0,</span><br><span class="line">		"hits【命中结果集合】" : [</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h4><p>match 匹配类型查询，会把查询条件进行分词，然后进行查询，多个词条之间是 or 的关系在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span>: &#123;</span><br><span class="line">		<span class="attr">"match"</span>: &#123;</span><br><span class="line">			<span class="attr">"name"</span>:<span class="string">"zhangsan"</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果为：</p>
<p><img src="/images/database/es/%E5%8C%B9%E9%85%8D%E6%9F%A5%E8%AF%A2.png" alt="匹配查询.png"></p>
<h4 id="字段匹配查询"><a href="#字段匹配查询" class="headerlink" title="字段匹配查询"></a>字段匹配查询</h4><p>multi_match 与 match 类似，不同的是它可以在多个字段中查询。</p>
<p>在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span>: &#123;</span><br><span class="line">		<span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">			<span class="attr">"query"</span>: <span class="string">"zhangsan"</span>,</span><br><span class="line">			<span class="attr">"fields"</span>: [<span class="string">"name"</span>,<span class="string">"nickname"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E5%AD%97%E6%AE%B5%E5%8C%B9%E9%85%8D%E6%9F%A5%E8%AF%A2.png" alt="字段匹配查询.png"></p>
<h4 id="关键字精确查询"><a href="#关键字精确查询" class="headerlink" title="关键字精确查询"></a>关键字精确查询</h4><p>term 查询，精确的关键词匹配查询，不对查询条件进行分词。</p>
<p>在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span>: &#123;</span><br><span class="line">		<span class="attr">"term"</span>: &#123;</span><br><span class="line">			<span class="attr">"name"</span>: &#123;</span><br><span class="line">				<span class="attr">"value"</span>: <span class="string">"zhangsan"</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E5%85%B3%E9%94%AE%E5%AD%97%E7%B2%BE%E7%A1%AE%E6%9F%A5%E8%AF%A2.png" alt="关键字精确查询.png"></p>
<h4 id="多关键字精确查询"><a href="#多关键字精确查询" class="headerlink" title="多关键字精确查询"></a>多关键字精确查询</h4><p>terms 查询和 term 查询一样，但它允许你指定多值进行匹配。</p>
<p>如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件，类似于 mysql 的 in在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span>: &#123;</span><br><span class="line">		<span class="attr">"terms"</span>: &#123;</span><br><span class="line">			<span class="attr">"name"</span>: [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E5%A4%9A%E5%85%B3%E9%94%AE%E5%AD%97%E7%B2%BE%E7%A1%AE%E6%9F%A5%E8%AF%A2.png" alt="多关键字精确查询.png"></p>
<h4 id="指定查询字段"><a href="#指定查询字段" class="headerlink" title="指定查询字段"></a>指定查询字段</h4><p>默认情况下，Elasticsearch 在搜索的结果中，会把文档中保存在_source 的所有字段都返回。如果我们只想获取其中的部分字段，我们可以添加_source 的过滤</p>
<p>在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"_source"</span>: [<span class="string">"name"</span>,<span class="string">"nickname"</span>],</span><br><span class="line">	<span class="attr">"query"</span>: &#123;</span><br><span class="line">		<span class="attr">"terms"</span>: &#123;</span><br><span class="line">			<span class="attr">"nickname"</span>: [<span class="string">"zhangsan"</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E6%8C%87%E5%AE%9A%E6%9F%A5%E8%AF%A2%E5%AD%97%E6%AE%B5.png" alt="指定查询字段.png"></p>
<h4 id="过滤字段"><a href="#过滤字段" class="headerlink" title="过滤字段"></a>过滤字段</h4><p>我们也可以通过：</p>
<p>​    includes：来指定想要显示的字段</p>
<p>​    excludes：来指定不想要显示的字段</p>
<p>在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"_source"</span>: &#123;</span><br><span class="line">		<span class="attr">"includes"</span>: [<span class="string">"name"</span>,<span class="string">"nickname"</span>]</span><br><span class="line">	&#125;,</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">		<span class="attr">"terms"</span>: &#123;</span><br><span class="line">			<span class="attr">"nickname"</span>: [<span class="string">"zhangsan"</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E8%BF%87%E6%BB%A4%E5%AD%97%E6%AE%B5.png" alt="过滤字段.png"></p>
<h4 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h4><p><code>bool</code>把各种其它查询通过<code>must</code>（必须 ）、<code>must_not</code>（必须不）、<code>should</code>（应该）的方式进行组合</p>
<p>在 Postman 中，向 ES 服务器发 <strong>GET</strong> 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span>: &#123;</span><br><span class="line">		<span class="attr">"bool"</span>: &#123;</span><br><span class="line">			<span class="attr">"must"</span>: [</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">"match"</span>: &#123;</span><br><span class="line">					<span class="attr">"name"</span>: <span class="string">"zhangsan"</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			],</span><br><span class="line">			<span class="attr">"must_not"</span>: [</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">"match"</span>: &#123;</span><br><span class="line">					<span class="attr">"age"</span>: <span class="string">"40"</span></span><br><span class="line">                    &#125;</span><br><span class="line">				&#125;</span><br><span class="line">			],</span><br><span class="line">			<span class="attr">"should"</span>: [</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">"match"</span>: &#123;</span><br><span class="line">					<span class="attr">"sex"</span>: <span class="string">"男"</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">            ]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2-%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C.png" alt="组合查询-响应结果.png"></p>
<h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>gt</td>
<td>大于&gt;</td>
</tr>
<tr>
<td>gte</td>
<td>大于等于&gt;=</td>
</tr>
<tr>
<td>lt</td>
<td>小于&lt;</td>
</tr>
<tr>
<td>lte</td>
<td>小于等于&lt;=</td>
</tr>
</tbody></table>
<p>在 Postman 中，向 ES 服务器发 <strong>GET</strong> 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span>: &#123;</span><br><span class="line">		<span class="attr">"range"</span>: &#123;</span><br><span class="line">			<span class="attr">"age"</span>: &#123;</span><br><span class="line">				<span class="attr">"gte"</span>: <span class="number">30</span>,</span><br><span class="line">				<span class="attr">"lte"</span>: <span class="number">35</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2-%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C.png" alt="范围查询-响应结果.png"></p>
<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>返回包含与搜索字词相似的字词的文档。</p>
<p>编辑距离是将一个术语转换为另一个术语所需的一个字符更改的次数。这些更改可以包括：</p>
<ul>
<li><p>更改字符（box → fox）</p>
</li>
<li><p>删除字符（black → lack）</p>
</li>
<li><p>插入字符（sic → sick）</p>
</li>
<li><p>转置两个相邻字符（act → cat）</p>
</li>
</ul>
<p>为了找到相似的术语，fuzzy 查询会在指定的编辑距离内创建一组搜索词的所有可能的变体或扩展。然后查询返回每个扩展的完全匹配。</p>
<p>通过 fuzziness 修改编辑距离。一般使用默认值 AUTO，根据术语的长度生成编辑距离。在 Postman 中，向 ES 服务器发 <strong>GET</strong> 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span>: &#123;</span><br><span class="line">		<span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">			<span class="attr">"title"</span>: &#123;</span><br><span class="line">				<span class="attr">"value"</span>: <span class="string">"zhangsan"</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2-%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C.png" alt="模糊查询-响应结果.png"></p>
<p>在 Postman 中，向 ES 服务器发 <strong>GET</strong> 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span>: &#123;</span><br><span class="line">		<span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">			<span class="attr">"title"</span>: &#123;</span><br><span class="line">				<span class="attr">"value"</span>: <span class="string">"zhangsan"</span>,</span><br><span class="line">				<span class="attr">"fuzziness"</span>: <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2-%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C2.png" alt="模糊查询-响应结果2.png"></p>
<h4 id="单字段排序"><a href="#单字段排序" class="headerlink" title="单字段排序"></a>单字段排序</h4><p>sort 可以让我们按照不同的字段进行排序，并且通过 order 指定排序的方式。desc 降序，asc升序。</p>
<p>在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span>: &#123;</span><br><span class="line">		<span class="attr">"match"</span>: &#123;</span><br><span class="line">			<span class="attr">"name"</span>:<span class="string">"zhangsan"</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"sort"</span>: [&#123;</span><br><span class="line">		<span class="attr">"age"</span>: &#123;</span><br><span class="line">			<span class="attr">"order"</span>:<span class="string">"desc"</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E5%8D%95%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F-%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C.png" alt="单字段排序-响应结果.png"></p>
<h4 id="多字段排序"><a href="#多字段排序" class="headerlink" title="多字段排序"></a>多字段排序</h4><p>假定我们想要结合使用 age 和 _score 进行查询，并且匹配的结果首先按照年龄排序，然后按照相关性得分排序</p>
<p>在 Postman 中，向 ES 服务器发 <strong>GET</strong> 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span>: &#123;</span><br><span class="line">		<span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"sort"</span>: [</span><br><span class="line">    	&#123;</span><br><span class="line">        	<span class="attr">"age"</span>: &#123;</span><br><span class="line">				<span class="attr">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">"_score"</span>:&#123;</span><br><span class="line">				<span class="attr">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E5%A4%9A%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F-%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C.png" alt="多字段排序-响应结果.png"></p>
<h4 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h4><p>在进行关键字搜索时，搜索出的内容中的关键字会显示不同的颜色，称之为高亮。</p>
<p>Elasticsearch 可以对查询内容中的关键字部分，进行标签和样式(高亮)的设置。在使用 match 查询的同时，加上一个 highlight 属性：</p>
<ul>
<li><p>pre_tags：前置标签</p>
</li>
<li><p>post_tags：后置标签</p>
</li>
<li><p>fields：需要高亮的字段</p>
</li>
<li><p>title：这里声明 title 字段需要高亮，后面可以为这个字段设置特有配置，也可以空</p>
</li>
</ul>
<p>在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span>: &#123;</span><br><span class="line">		<span class="attr">"match"</span>: &#123;</span><br><span class="line">			<span class="attr">"name"</span>: <span class="string">"zhangsan"</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"highlight"</span>: &#123;</span><br><span class="line">		<span class="attr">"pre_tags"</span>: <span class="string">"&lt;font color='red'&gt;"</span>,</span><br><span class="line">		<span class="attr">"post_tags"</span>: <span class="string">"&lt;/font&gt;"</span>,</span><br><span class="line">		<span class="attr">"fields"</span>: &#123;</span><br><span class="line">			<span class="attr">"name"</span>: &#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E9%AB%98%E4%BA%AE%E6%9F%A5%E8%AF%A2-%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C.png" alt="高亮查询-响应结果.png"></p>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>from：当前页的起始索引，默认从 0 开始。 from = (pageNum - 1) * size</p>
<p>size：每页显示多少条</p>
<p>在 Postman 中，向 ES 服务器发 <strong>GET</strong> 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span>: &#123;</span><br><span class="line">		<span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"sort"</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">"age"</span>: &#123;</span><br><span class="line">				<span class="attr">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	<span class="attr">"from"</span>: <span class="number">0</span>,</span><br><span class="line">	<span class="attr">"size"</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C.png" alt="分页查询-响应结果.png"></p>
<h4 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h4><p>聚合允许使用者对 es 文档进行统计分析，类似与关系型数据库中的 group by，当然还有很多其他的聚合，例如取最大值、平均值等等。</p>
<blockquote>
<p>对某个字段取最大值 max</p>
</blockquote>
<p>在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"aggs"</span>:&#123;</span><br><span class="line">		<span class="attr">"max_age"</span>:&#123;</span><br><span class="line">			<span class="attr">"max"</span>:&#123;<span class="attr">"field"</span>:<span class="string">"age"</span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"size"</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2-%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C.png" alt="聚合查询-响应结果.png"></p>
<blockquote>
<p>对某个字段取最小值 min</p>
</blockquote>
<p>在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"aggs"</span>:&#123;</span><br><span class="line">		<span class="attr">"min_age"</span>:&#123;</span><br><span class="line">			<span class="attr">"min"</span>:&#123;<span class="attr">"field"</span>:<span class="string">"age"</span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"size"</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2-%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C2.png" alt="聚合查询-响应结果2.png"></p>
<blockquote>
<p>对某个字段求和 sum</p>
</blockquote>
<p>在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"aggs"</span>:&#123;</span><br><span class="line">		<span class="attr">"sum_age"</span>:&#123;</span><br><span class="line">			<span class="attr">"sum"</span>:&#123;<span class="attr">"field"</span>:<span class="string">"age"</span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"size"</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2-%E6%B1%82%E5%92%8C-%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C.png" alt="聚合查询-求和-响应结果.png"></p>
<blockquote>
<p>对某个字段取平均值 avg</p>
</blockquote>
<p>在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"aggs"</span>:&#123;</span><br><span class="line">		<span class="attr">"avg_age"</span>:&#123;</span><br><span class="line">			<span class="attr">"avg"</span>:&#123;<span class="attr">"field"</span>:<span class="string">"age"</span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"size"</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p>![对某个字段取平均值 avg.png](/images/database/es/对某个字段取平均值 avg.png)</p>
<blockquote>
<p>对某个字段的值进行去重之后再取总数</p>
</blockquote>
<p>在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"aggs"</span>:&#123;</span><br><span class="line">		<span class="attr">"distinct_age"</span>:&#123;</span><br><span class="line">			<span class="attr">"cardinality"</span>:&#123;<span class="attr">"field"</span>:<span class="string">"age"</span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"size"</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p><img src="/images/database/es/%E5%AF%B9%E6%9F%90%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC%E8%BF%9B%E8%A1%8C%E5%8E%BB%E9%87%8D%E4%B9%8B%E5%90%8E%E5%86%8D%E5%8F%96%E6%80%BB%E6%95%B0.png" alt="对某个字段的值进行去重之后再取总数.png"></p>
<blockquote>
<p>State 聚合</p>
</blockquote>
<p>stats 聚合，对某个字段一次性返回 count，max，min，avg 和 sum 五个指标</p>
<p>在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"aggs"</span>:&#123;</span><br><span class="line">		<span class="attr">"stats_age"</span>:&#123;</span><br><span class="line">			<span class="attr">"stats"</span>:&#123;<span class="attr">"field"</span>:<span class="string">"age"</span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"size"</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p>![State 聚合.png](/images/database/es/State 聚合.png)</p>
<h4 id="桶聚合查询"><a href="#桶聚合查询" class="headerlink" title="桶聚合查询"></a>桶聚合查询</h4><p>桶聚和相当于 sql 中的 group by 语句</p>
<blockquote>
<p>terms 聚合，分组统计</p>
</blockquote>
<p>在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"aggs"</span>:&#123;</span><br><span class="line">		<span class="attr">"age_groupby"</span>:&#123;</span><br><span class="line">			<span class="attr">"terms"</span>:&#123;<span class="attr">"field"</span>:<span class="string">"age"</span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"size"</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p>![terms 聚合，分组统计.png](/images/database/es/terms 聚合，分组统计.png)</p>
<blockquote>
<p>在 terms 分组下再进行聚合</p>
</blockquote>
<p>在 Postman 中，向 ES 服务器发 GET 请求 ：<a href="http://127.0.0.1:9200/student/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/student/_search</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"aggs"</span>:&#123;</span><br><span class="line">		<span class="attr">"age_groupby"</span>:&#123;</span><br><span class="line">			<span class="attr">"terms"</span>:&#123;<span class="attr">"field"</span>:<span class="string">"age"</span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"size"</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器响应结果：</p>
<p>![在 terms 分组下再进行聚合.png](/images/database/es/在 terms 分组下再进行聚合.png)</p>
<h2 id="Java-API-操作"><a href="#Java-API-操作" class="headerlink" title="Java API 操作"></a><strong>Java</strong> <strong>API</strong> 操作</h2><ol>
<li><p>创建 Maven 项目</p>
</li>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- elasticsearch的客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- elasticsearch依赖2.x的log4j --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- junit单元测试 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加一个测试的entity</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learning.es.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String sex, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="创建es客户端"><a href="#创建es客户端" class="headerlink" title="创建es客户端"></a>创建es客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建es客户端</span></span><br><span class="line">        RestHighLevelClient esClient = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">                RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        esClient.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="doc操作"><a href="#doc操作" class="headerlink" title="doc操作"></a>doc操作</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import com.learning.es.entity.User;</span><br><span class="line">import org.apache.http.HttpHost;</span><br><span class="line">import org.elasticsearch.action.bulk.BulkRequest;</span><br><span class="line">import org.elasticsearch.action.bulk.BulkResponse;</span><br><span class="line">import org.elasticsearch.action.delete.DeleteRequest;</span><br><span class="line">import org.elasticsearch.action.delete.DeleteResponse;</span><br><span class="line">import org.elasticsearch.action.get.GetRequest;</span><br><span class="line">import org.elasticsearch.action.get.GetResponse;</span><br><span class="line">import org.elasticsearch.action.index.IndexRequest;</span><br><span class="line">import org.elasticsearch.action.index.IndexResponse;</span><br><span class="line">import org.elasticsearch.action.search.SearchRequest;</span><br><span class="line">import org.elasticsearch.action.search.SearchResponse;</span><br><span class="line">import org.elasticsearch.action.update.UpdateRequest;</span><br><span class="line">import org.elasticsearch.action.update.UpdateResponse;</span><br><span class="line">import org.elasticsearch.client.RequestOptions;</span><br><span class="line">import org.elasticsearch.client.RestClient;</span><br><span class="line">import org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line">import org.elasticsearch.common.unit.Fuzziness;</span><br><span class="line">import org.elasticsearch.common.unit.TimeValue;</span><br><span class="line">import org.elasticsearch.common.xcontent.XContentType;</span><br><span class="line">import org.elasticsearch.index.query.*;</span><br><span class="line">import org.elasticsearch.search.SearchHits;</span><br><span class="line">import org.elasticsearch.search.aggregations.AggregationBuilder;</span><br><span class="line">import org.elasticsearch.search.aggregations.AggregationBuilders;</span><br><span class="line">import org.elasticsearch.search.builder.SearchSourceBuilder;</span><br><span class="line">import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;</span><br><span class="line">import org.elasticsearch.search.sort.SortOrder;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Doc &#123;</span><br><span class="line">    public static RestHighLevelClient esClient;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Doc testIndex = new Doc();</span><br><span class="line">        esClient = new RestHighLevelClient(</span><br><span class="line">                RestClient.builder(new HttpHost("localhost", 9200, "http"))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        testIndex.insert();</span></span><br><span class="line"><span class="comment">//        testIndex.update();</span></span><br><span class="line"><span class="comment">//        testIndex.search();</span></span><br><span class="line"><span class="comment">//        testIndex.del();</span></span><br><span class="line"><span class="comment">//        testIndex.multiInsert();</span></span><br><span class="line"><span class="comment">//        testIndex.del();</span></span><br><span class="line"><span class="comment">//        testIndex.query();</span></span><br><span class="line">        testIndex.query2();</span><br><span class="line">        esClient.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void insert() throws IOException &#123;</span><br><span class="line">        IndexRequest request = new IndexRequest();</span><br><span class="line">        request.index("user").id("1001");</span><br><span class="line">        User zhangsan = new User("zhangsan", "男", 30);</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        String userJson = mapper.writeValueAsString(zhangsan);</span><br><span class="line">        request.source(userJson, XContentType.JSON);</span><br><span class="line">        IndexResponse res = esClient.index(request, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(res.getResult());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void update() throws IOException &#123;</span><br><span class="line">        UpdateRequest request = new UpdateRequest();</span><br><span class="line">        request.index("user").id("1001");</span><br><span class="line">        request.doc(XContentType.JSON, "sex", "女");</span><br><span class="line">        UpdateResponse res = esClient.update(request, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(res.getResult());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void search() throws IOException &#123;</span><br><span class="line">        GetRequest request = new GetRequest();</span><br><span class="line">        request.index("user").id("1001");</span><br><span class="line">        GetResponse documentFields = esClient.get(request, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(documentFields.getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void del() throws IOException &#123;</span><br><span class="line">        DeleteRequest request = new DeleteRequest();</span><br><span class="line">        request.index("user").id("1001");</span><br><span class="line">        DeleteResponse delete = esClient.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(delete.getResult());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void multiInsert() throws IOException &#123;</span><br><span class="line">        BulkRequest bulkRequest = new BulkRequest();</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        bulkRequest.add(new IndexRequest()</span><br><span class="line">                .index("user").id("1001")</span><br><span class="line">                .source(XContentType.JSON, "name","zhangsan", "sex","男", "age",30));</span><br><span class="line">        bulkRequest.add(new IndexRequest()</span><br><span class="line">                .index("user").id("1002")</span><br><span class="line">                .source(XContentType.JSON,"name","lisi", "sex","男", "age",30));</span><br><span class="line">        bulkRequest.add(new IndexRequest()</span><br><span class="line">                .index("user").id("1003")</span><br><span class="line">                .source(XContentType.JSON, "name","wangwu", "sex","女", "age",30));</span><br><span class="line">        bulkRequest.add(new IndexRequest()</span><br><span class="line">                .index("user").id("1004")</span><br><span class="line">                .source(XContentType.JSON, "name","zhangsan2", "sex","女", "age",40));</span><br><span class="line">        bulkRequest.add(new IndexRequest()</span><br><span class="line">                .index("user").id("1005")</span><br><span class="line">                .source(XContentType.JSON, "name","zhangsan3", "sex","男", "age",40));</span><br><span class="line">        BulkResponse res = esClient.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(res.getTook());</span><br><span class="line">        System.out.println(Arrays.toString(res.getItems()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void multiDel() throws IOException &#123;</span><br><span class="line">        BulkRequest bulkRequest = new BulkRequest();</span><br><span class="line"></span><br><span class="line">        bulkRequest.add(new DeleteRequest()</span><br><span class="line">                .index("user").id("1001"));</span><br><span class="line">        bulkRequest.add(new DeleteRequest()</span><br><span class="line">                .index("user").id("1002"));</span><br><span class="line">        bulkRequest.add(new DeleteRequest()</span><br><span class="line">                .index("user").id("1003"));</span><br><span class="line">        bulkRequest.add(new DeleteRequest()</span><br><span class="line">                .index("user").id("1004"));</span><br><span class="line">        bulkRequest.add(new DeleteRequest()</span><br><span class="line">                .index("user").id("1005"));</span><br><span class="line">        BulkResponse res = esClient.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(res.getTook());</span><br><span class="line">        System.out.println(Arrays.toString(res.getItems()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全量查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void query() throws IOException &#123;</span><br><span class="line">        SearchRequest request = new SearchRequest();</span><br><span class="line">        request.indices("user");</span><br><span class="line"></span><br><span class="line">        request.source(new SearchSourceBuilder().query(QueryBuilders.matchAllQuery()));</span><br><span class="line">        SearchResponse res = esClient.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        System.out.println(res.getTook());</span><br><span class="line"></span><br><span class="line">        SearchHits hits = res.getHits();</span><br><span class="line">        System.out.println(hits.getTotalHits());</span><br><span class="line">        hits.forEach((hit) -&gt; System.out.println(hit.getSourceAsString()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void query2() throws IOException &#123;</span><br><span class="line">        SearchRequest request = new SearchRequest();</span><br><span class="line">        request.indices("user");</span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 单个查询</span></span><br><span class="line"><span class="comment">//        SearchSourceBuilder builder = new SearchSourceBuilder().query(QueryBuilders.matchQuery("sex", "男"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 组合查询</span></span><br><span class="line"><span class="comment">//        SearchSourceBuilder builder = new SearchSourceBuilder();</span></span><br><span class="line"><span class="comment">//        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span></span><br><span class="line"><span class="comment">//        boolQueryBuilder.must(QueryBuilders.matchQuery("sex", "男"));</span></span><br><span class="line"><span class="comment">//        boolQueryBuilder.must(QueryBuilders.matchQuery("age", "30"));</span></span><br><span class="line"><span class="comment">//        boolQueryBuilder.mustNot(QueryBuilders.matchQuery("sex", "男"));</span></span><br><span class="line"><span class="comment">//        boolQueryBuilder.should(QueryBuilders.matchQuery("age", "30"));</span></span><br><span class="line"><span class="comment">//        boolQueryBuilder.should(QueryBuilders.matchQuery("age", "40"));</span></span><br><span class="line"><span class="comment">//        builder.query(boolQueryBuilder);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 范围查询</span></span><br><span class="line"><span class="comment">//        SearchSourceBuilder builder = new SearchSourceBuilder();</span></span><br><span class="line"><span class="comment">//        RangeQueryBuilder rangeQuery = QueryBuilders.rangeQuery("age");</span></span><br><span class="line"><span class="comment">//        rangeQuery.gte(30).lte(35);</span></span><br><span class="line"><span class="comment">//        builder.query(rangeQuery);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 模糊查询</span></span><br><span class="line"><span class="comment">//        SearchSourceBuilder builder = new SearchSourceBuilder();</span></span><br><span class="line"><span class="comment">//        // fuzziness 表示偏差多少个字符可以模糊匹配出来</span></span><br><span class="line"><span class="comment">//        FuzzyQueryBuilder fuzziness = QueryBuilders.fuzzyQuery("name", "zhangsan").fuzziness(Fuzziness.ONE);</span></span><br><span class="line"><span class="comment">//        builder.query(fuzziness);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 高亮</span></span><br><span class="line"><span class="comment">//        SearchSourceBuilder builder = new SearchSourceBuilder();</span></span><br><span class="line"><span class="comment">//        builder.query(QueryBuilders.termQuery("name", "zhangsan"));</span></span><br><span class="line"><span class="comment">//        HighlightBuilder highlightBuilder = new HighlightBuilder();</span></span><br><span class="line"><span class="comment">//        highlightBuilder.preTags("&lt;font color='red'&gt;");</span></span><br><span class="line"><span class="comment">//        highlightBuilder.postTags("&lt;/font&gt;");</span></span><br><span class="line"><span class="comment">//        highlightBuilder.field("name");</span></span><br><span class="line"><span class="comment">//        builder.highlighter(highlightBuilder);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 聚合查询</span></span><br><span class="line"><span class="comment">//        SearchSourceBuilder builder = new SearchSourceBuilder();</span></span><br><span class="line"><span class="comment">//        AggregationBuilder aggregationBuilder = AggregationBuilders.max("maxAge").field("age");</span></span><br><span class="line"><span class="comment">//        builder.aggregation(aggregationBuilder);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分组查询</span></span><br><span class="line">        SearchSourceBuilder builder = new SearchSourceBuilder();</span><br><span class="line">        AggregationBuilder aggregationBuilder = AggregationBuilders.terms("ageGroup").field("age");</span><br><span class="line">        builder.aggregation(aggregationBuilder);</span><br><span class="line">        <span class="comment">// 分页</span></span><br><span class="line">        builder.from(0);</span><br><span class="line">        builder.size(5);</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        builder.sort("age", SortOrder.DESC);</span><br><span class="line"><span class="comment">//        // 过滤字段</span></span><br><span class="line"><span class="comment">//        String[] includes = &#123;"name"&#125;;</span></span><br><span class="line"><span class="comment">//        String[] excludes = &#123;&#125;;</span></span><br><span class="line"><span class="comment">//        builder.fetchSource(includes, excludes);</span></span><br><span class="line"></span><br><span class="line">        request.source(builder);</span><br><span class="line">        SearchResponse res = esClient.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        System.out.println(res.getTook());</span><br><span class="line"></span><br><span class="line">        SearchHits hits = res.getHits();</span><br><span class="line">        System.out.println(hits.getTotalHits());</span><br><span class="line">        hits.forEach((hit) -&gt; System.out.println(hit.getSourceAsString()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Index操作"><a href="#Index操作" class="headerlink" title="Index操作"></a>Index操作</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">import org.apache.http.HttpHost;</span><br><span class="line">import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;</span><br><span class="line">import org.elasticsearch.action.support.master.AcknowledgedResponse;</span><br><span class="line">import org.elasticsearch.client.RequestOptions;</span><br><span class="line">import org.elasticsearch.client.RestClient;</span><br><span class="line">import org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line">import org.elasticsearch.client.indices.CreateIndexRequest;</span><br><span class="line">import org.elasticsearch.client.indices.CreateIndexResponse;</span><br><span class="line">import org.elasticsearch.client.indices.GetIndexRequest;</span><br><span class="line">import org.elasticsearch.client.indices.GetIndexResponse;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Index &#123;</span><br><span class="line">    public static RestHighLevelClient esClient;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Index testIndex = new Index();</span><br><span class="line">        esClient = new RestHighLevelClient(</span><br><span class="line">                RestClient.builder(new HttpHost("localhost", 9200, "http"))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        testIndex.create();</span></span><br><span class="line">        testIndex.search();</span><br><span class="line"><span class="comment">//        testIndex.delete();</span></span><br><span class="line">        esClient.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void create () throws IOException &#123;</span><br><span class="line">        <span class="comment">// 创建索引</span></span><br><span class="line">        CreateIndexRequest user = new CreateIndexRequest("user");</span><br><span class="line">        CreateIndexResponse createIndexResponse = esClient.indices().create(user, RequestOptions.DEFAULT);</span><br><span class="line">        boolean acknowledged = createIndexResponse.isAcknowledged();</span><br><span class="line">        System.out.println(acknowledged);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void search () throws IOException &#123;</span><br><span class="line">        <span class="comment">// 创建索引</span></span><br><span class="line">        GetIndexRequest user = new GetIndexRequest("user");</span><br><span class="line">        GetIndexResponse getIndexResponse = esClient.indices().get(user, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(getIndexResponse.getAliases());</span><br><span class="line">        System.out.println(getIndexResponse.getMappings());</span><br><span class="line">        System.out.println(getIndexResponse.getSettings());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void delete () throws IOException &#123;</span><br><span class="line">        <span class="comment">// 创建索引</span></span><br><span class="line">        DeleteIndexRequest user = new DeleteIndexRequest("user");</span><br><span class="line">        AcknowledgedResponse delete = esClient.indices().delete(user, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(delete.isAcknowledged());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>略</p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="路由计算-amp-分片控制"><a href="#路由计算-amp-分片控制" class="headerlink" title="路由计算 &amp; 分片控制"></a>路由计算 &amp; 分片控制</h2><p>公式：shard = hash(routing) % number_of_primary_shards</p>
<p>routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到余数 。这个分布在 0 到 number_of_primary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。</p>
<h3 id="分片控制"><a href="#分片控制" class="headerlink" title="分片控制"></a>分片控制</h3><p>我们可以发送请求到集群中的任一节点。每个节点都有能力处理任意请求。每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。在下面的例子中，如果将所有的请求发送到Node 1001，我们将其称为协调节点<strong>coordinating node</strong>。</p>
<p><img src="/images/database/es/%E5%88%86%E7%89%87%E6%8E%A7%E5%88%B6.png" alt="分片控制.png"></p>
<p>当发送请求的时候， 为了扩展负载，更好的做法是轮询集群中所有的节点。</p>
<h2 id="数据写流程"><a href="#数据写流程" class="headerlink" title="数据写流程"></a>数据写流程</h2><p>新建、索引和删除请求都是写操作， 必须在主分片上面完成之后才能被复制到相关的副本分片。</p>
<p><img src="/images/database/es/%E6%95%B0%E6%8D%AE%E5%86%99%E6%B5%81%E7%A8%8B.png" alt="数据写流程.png"></p>
<p>在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。有一些可选的请求参数允许您影响这个过程，可能以数据安全为代价提升性能。这些选项很少使用，因为 Elasticsearch 已经很快，但是为了完整起见， 请参考下文：</p>
<ul>
<li>consistency<br>即一致性。在默认设置下，即使仅仅是在试图执行一个写操作之前，主分片都会要求必须要有规定数量quorum（或者换种说法，也即必须要有大多数）的分片副本处于活跃可用状态，才会去执行写操作（其中分片副本 可以是主分片或者副本分片）。这是为了避免在发生网络分区故障（network partition）的时候进行写操作，进而导致数据不一致。 规定数量即： int((primary + number_of_replicas) / 2 ) + 1</li>
<li>consistency 参数的值可以设为：<ul>
<li>one ：只要主分片状态 ok 就允许执行写操作。</li>
<li>all：必须要主分片和所有副本分片的状态没问题才允许执行写操作。</li>
<li>quorum：默认值为quorum , 即大多数的分片副本状态没问题就允许执行写操作。</li>
</ul>
</li>
<li>注意，规定数量的计算公式中number_of_replicas指的是在索引设置中的设定副本分片数，而不是指当前处理活动状态的副本分片数。如果你的索引设置中指定了当前索引拥有3个副本分片，那规定数量的计算结果即：int((1 primary + 3 replicas) / 2) + 1 = 3，如果此时你只启动两个节点，那么处于活跃状态的分片副本数量就达不到规定数量，也因此您将无法索引和删除任何文档。</li>
<li>timeout<ol>
<li>如果没有足够的副本分片会发生什么？Elasticsearch 会等待，希望更多的分片出现。默认情况下，它最多等待 1 分钟。 如果你需要，你可以使用timeout参数使它更早终止：100是100 毫秒，30s是30秒。</li>
</ol>
</li>
</ul>
<p>新索引默认有1个副本分片，这意味着为满足规定数量应该需要两个活动的分片副本。 但是，这些默认的设置会阻止我们在单一节点上做任何事情。为了避免这个问题，要求只有当number_of_replicas 大于1的时候，规定数量才会执行。</p>
<h2 id="数据读流程"><a href="#数据读流程" class="headerlink" title="数据读流程"></a>数据读流程</h2><p><img src="/images/database/es/%E6%95%B0%E6%8D%AE%E8%AF%BB%E6%B5%81%E7%A8%8B.png" alt="数据读流程.png"></p>
<p>在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。</p>
<h2 id="更新流程-amp-批量操作流程"><a href="#更新流程-amp-批量操作流程" class="headerlink" title="更新流程 &amp; 批量操作流程"></a>更新流程 &amp; 批量操作流程</h2><h3 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h3><p>部分更新一个文档结合了先前说明的读取和写入流程：</p>
<p><img src="/images/database/es/%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B.png" alt="更新流程.png"></p>
<p>部分更新一个文档的步骤如下：</p>
<ol>
<li>客户端向Node 1发送更新请求。</li>
<li>它将请求转发到主分片所在的Node 3 。</li>
<li>Node 3从主分片检索文档，修改_source字段中的JSON，并且尝试重新索引主分片的文档。如果文档已经被另一个进程修改,它会重试步骤3 ,超过retry_on_conflict次后放弃。</li>
<li>如果 Node 3成功地更新文档，它将新版本的文档并行转发到Node 1和 Node 2上的副本分片，重新建立索引。一旦所有副本分片都返回成功，Node 3向协调节点也返回成功，协调节点向客户端返回成功。</li>
</ol>
<p>当主分片把更改转发到副本分片时， 它不会转发更新请求。 相反，它转发完整文档的新版本。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果 Elasticsearch 仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。</p>
<h3 id="批量操作流程"><a href="#批量操作流程" class="headerlink" title="批量操作流程"></a>批量操作流程</h3><p><strong>mget和 bulk API的模式类似于单文档模式。</strong>区别在于协调节点知道每个文档存在于哪个分片中。它将整个多文档请求分解成每个分片的多文档请求，并且将这些请求并行转发到每个参与节点。</p>
<p>协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返回给客户端。</p>
<p><img src="/images/database/es/%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="批量操作流程.png"></p>
<p><strong>用单个 mget 请求取回多个文档所需的步骤顺序:</strong></p>
<ol>
<li>客户端向 Node 1 发送 mget 请求。</li>
<li>Node 1为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复，Node 1 构建响应并将其返回给客户端。</li>
</ol>
<p>可以对docs数组中每个文档设置routing参数。</p>
<p>bulk API， 允许在单个批量请求中执行多个创建、索引、删除和更新请求。</p>
<p><img src="/images/database/es/%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B2.png" alt="批量操作流程2.png"></p>
<p><strong>bulk API 按如下步骤顺序执行：</strong></p>
<ol>
<li>客户端向Node 1 发送 bulk请求。</li>
<li>Node 1为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。</li>
<li>主分片一个接一个按顺序执行每个操作。当每个操作成功时,主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端</li>
</ol>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>分片是Elasticsearch最小的工作单元。但是究竟什么是一个分片，它是如何工作的？</p>
<p>传统的数据库每个字段存储单个值，但这对全文检索并不够。文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多值的能力。最好的支持是一个字段多个值需求的数据结构是倒排索引。</p>
<h3 id="倒排索引原理"><a href="#倒排索引原理" class="headerlink" title="倒排索引原理"></a>倒排索引原理</h3><p>Elasticsearch使用一种称为倒排索引的结构，它适用于快速的全文搜索。</p>
<p>见其名，知其意，有倒排索引，肯定会对应有正向索引。正向索引（forward index），反向索引（inverted index）更熟悉的名字是倒排索引。</p>
<p>所谓的正向索引，就是搜索引擎会将待搜索的文件都对应一个文件ID，搜索时将这个ID和搜索关键字进行对应，形成K-V对，然后对关键字进行统计计数。（统计？？下文有解释）</p>
<p><img src="/images/database/es/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86-%E6%AD%A3%E5%90%91%E7%B4%A2%E5%BC%95.png" alt="倒排索引原理-正向索引.png"></p>
<p>但是互联网上收录在搜索引擎中的文档的数目是个天文数字，这样的索引结构根本无法满足实时返回排名结果的要求。所以，搜索引擎会将正向索引重新构建为倒排索引，即把文件ID对应到关键词的映射转换为关键词到文件ID的映射，每个关键词都对应着一系列的文件，这些文件中都出现这个关键词。</p>
<p><img src="/images/database/es/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86-%E5%8F%8D%E5%90%91%E7%B4%A2%E5%BC%95.png" alt="倒排索引原理-反向索引.png"></p>
<h3 id="倒排索引的例子"><a href="#倒排索引的例子" class="headerlink" title="倒排索引的例子"></a>倒排索引的例子</h3><p>一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。例如，假设我们有两个文档，每个文档的content域包含如下内容：</p>
<ul>
<li>The quick brown fox jumped over the lazy dog</li>
<li>Quick brown foxes leap over lazy dogs in summer</li>
</ul>
<p>为了创建倒排索引，我们首先将每个文档的content域拆分成单独的词（我们称它为词条或tokens )，创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。结果如下所示：</p>
<p><img src="/images/database/es/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="倒排索引的例子.png"></p>
<p>现在，如果我们想搜索 quick brown ，我们只需要查找包含每个词条的文档：</p>
<p><img src="/images/database/es/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BE%8B%E5%AD%902.png" alt="倒排索引的例子2.png"></p>
<p>两个文档都匹配，但是第一个文档比第二个匹配度更高。如果我们使用仅计算匹配词条数量的简单相似性算法，那么我们可以说，对于我们查询的相关性来讲，第一个文档比第二个文档更佳。</p>
<p>但是，我们目前的倒排索引有一些问题：</p>
<ul>
<li><p>Quick和quick以独立的词条出现，然而用户可能认为它们是相同的词。</p>
</li>
<li><p>fox和foxes非常相似，就像dog和dogs；他们有相同的词根。</p>
</li>
<li><p>jumped和leap，尽管没有相同的词根，但他们的意思很相近。他们是同义词。</p>
</li>
</ul>
<p>使用前面的索引搜索+Quick +fox不会得到任何匹配文档。(记住，＋前缀表明这个词必须存在）。</p>
<p>只有同时出现Quick和fox 的文档才满足这个查询条件，但是第一个文档包含quick fox ，第二个文档包含Quick foxes 。</p>
<p>我们的用户可以合理的期望两个文档与查询匹配。我们可以做的更好。</p>
<p>如果我们将词条规范为标准模式，那么我们可以找到与用户搜索的词条不完全一致，但具有足够相关性的文档。例如：</p>
<ul>
<li>Quick可以小写化为quick。</li>
<li>foxes可以词干提取变为词根的格式为fox。类似的，dogs可以为提取为dog。</li>
<li>jumped和leap是同义词，可以索引为相同的单词jump 。</li>
</ul>
<p>现在索引看上去像这样：</p>
<p><img src="/images/database/es/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BE%8B%E5%AD%903.png" alt="倒排索引的例子3.png"></p>
<p>这还远远不够。我们搜索+Quick +fox 仍然会失败，因为在我们的索引中，已经没有Quick了。但是，如果我们对搜索的字符串使用与content域相同的标准化规则，会变成查询+quick +fox，这样两个文档都会匹配！分词和标准化的过程称为分析，这非常重要。你只能搜索在索引中出现的词条，所以索引文本和查询字符串必须标准化为相同的格式。</p>
<h2 id="文档搜索"><a href="#文档搜索" class="headerlink" title="文档搜索"></a>文档搜索</h2><h3 id="不可改变的倒排索引"><a href="#不可改变的倒排索引" class="headerlink" title="不可改变的倒排索引"></a>不可改变的倒排索引</h3><p>早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。 一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到。</p>
<p>倒排索引被写入磁盘后是不可改变的：它永远不会修改。</p>
<ul>
<li><p>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。</p>
</li>
<li><p>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</p>
</li>
<li><p>其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</p>
</li>
<li><p>写入单个大的倒排索引允许数据被压缩，减少磁盘IO和需要被缓存到内存的索引的使用量。</p>
</li>
</ul>
<p>当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。</p>
<h3 id="动态更新索引"><a href="#动态更新索引" class="headerlink" title="动态更新索引"></a>动态更新索引</h3><p>如何在保留不变性的前提下实现倒排索引的更新？</p>
<p>答案是：用更多的索引。通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到,从最早的开始查询完后再对结果进行合并。</p>
<p>Elasticsearch基于Lucene，这个java库引入了按段搜索的概念。每一段本身都是一个倒排索引，但索引在 Lucene 中除表示所有段的集合外，还增加了提交点的概念—一个列出了所有已知段的文件。</p>
<p>按段搜索会以如下流程执行：</p>
<p>一、新文档被收集到内存索引缓存。</p>
<p><img src="/images/database/es/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E7%B4%A2%E5%BC%95-%E6%96%B0%E6%96%87%E6%A1%A3%E8%A2%AB%E6%94%B6%E9%9B%86%E5%88%B0%E5%86%85%E5%AD%98%E7%B4%A2%E5%BC%95%E7%BC%93%E5%AD%98.png" alt="动态更新索引-新文档被收集到内存索引缓存.png"></p>
<p>二、不时地, 缓存被提交。</p>
<ol>
<li>一个新的段，一个追加的倒排索引，被写入磁盘。</li>
<li>一个新的包含新段名字的提交点被写入磁盘。</li>
<li>磁盘进行同步，所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件</li>
</ol>
<p>三、新的段被开启，让它包含的文档可见以被搜索。</p>
<p>四、内存缓存被清空，等待接收新的文档。</p>
<p><img src="/images/database/es/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E7%B4%A2%E5%BC%95-%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E6%B8%85%E7%A9%BA.png" alt="动态更新索引-内存缓存清空.png"></p>
<p>当一个查询被触发，所有已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。这种方式可以用相对较低的成本将新文档添加到索引。</p>
<p>段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。取而代之的是，每个提交点会包含一个.del 文件，文件中会列出这些被删除文档的段信息。</p>
<p>当一个<strong>文档被“删除”</strong>时，它实际上只是在 .del 文件中被标记删除。一个被标记删除的文档仍然可以被查询匹配到，但它会在最终结果被返回前从结果集中移除。</p>
<p><strong>文档更新</strong>也是类似的操作方式:当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p>
<h2 id="文档刷新-amp-文档刷写-amp-文档合并"><a href="#文档刷新-amp-文档刷写-amp-文档合并" class="headerlink" title="文档刷新 &amp; 文档刷写 &amp; 文档合并"></a>文档刷新 &amp; 文档刷写 &amp; 文档合并</h2><p><img src="/images/database/es/%E8%BF%91%E5%AE%9E%E6%97%B6%E6%90%9C%E7%B4%A2.png" alt="近实时搜索.png"></p>
<p>![文档刷新 &amp; 文档刷写.png](/images/database/es/文档刷新 &amp; 文档刷写.png)</p>
<h3 id="近实时搜索"><a href="#近实时搜索" class="headerlink" title="近实时搜索"></a>近实时搜索</h3><p>随着按段（per-segment）搜索的发展，一个新的文档从索引到可被搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。磁盘在这里成为了瓶颈。<strong>提交（Commiting）一个新的段到磁盘需要一个fsync来确保段被物理性地写入磁盘</strong>，这样在断电的时候就不会丢失数据。但是fsync操作代价很大；如果每次索引一个文档都去执行一次的话会造成很大的性能问题。</p>
<p>我们需要的是一个更轻量的方式来使一个文档可被搜索，这意味着fsync要从整个过程中被移除。在Elasticsearch和磁盘之间是<strong>文件系统缓存</strong>。像之前描述的一样，在内存索引缓冲区中的文档会被写入到一个新的段中。但是这里新段会被先写入到文件系统缓存—这一步代价会比较低，稍后再被刷新到磁盘—这一步代价比较高。不过只要文件已经在缓存中，就可以像其它文件一样被打开和读取了。</p>
<p><img src="/images/database/es/%E8%BF%91%E5%AE%9E%E6%97%B6%E6%90%9C%E7%B4%A22.png" alt="近实时搜索2.png"></p>
<p>Lucene允许新段被写入和打开，使其包含的文档在未进行一次完整提交时便对搜索可见。这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。</p>
<p><img src="/images/database/es/%E8%BF%91%E5%AE%9E%E6%97%B6%E6%90%9C%E7%B4%A23.png" alt="近实时搜索3.png"></p>
<p>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做refresh。默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch是近实时搜索：文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。</p>
<p>这些行为可能会对新用户造成困惑：他们索引了一个文档然后尝试搜索它，但却没有搜到。这个问题的解决办法是用refresh API执行一次手动刷新：/usersl_refresh</p>
<p>尽管刷新是比提交轻量很多的操作，它还是会有性能开销。当写测试的时候，手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。相反，你的应用需要意识到Elasticsearch 的近实时的性质，并接受它的不足。</p>
<p>并不是所有的情况都需要每秒刷新。可能你正在使用Elasticsearch索引大量的日志文件，你可能想优化索引速度而不是近实时搜索，可以通过设置refresh_interval ，降低每个索引的刷新频率</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    	<span class="attr">"refresh_interval"</span>: <span class="string">"30s"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>refresh_interval可以在既存索引上进行动态更新。在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># 关闭自动刷新</span><br><span class="line">PUT /users/_settings</span><br><span class="line">&#123; <span class="attr">"refresh_interval"</span>: <span class="number">-1</span> &#125;</span><br><span class="line"></span><br><span class="line"># 每一秒刷新</span><br><span class="line">PUT /users/_settings</span><br><span class="line">&#123; <span class="attr">"refresh_interval"</span>: <span class="string">"1s"</span> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="持久化变更"><a href="#持久化变更" class="headerlink" title="持久化变更"></a>持久化变更</h3><p>如果没有用fsync把数据从文件系统缓存刷（flush）到硬盘，我们不能保证数据在断电甚至是程序正常退出之后依然存在。为了保证Elasticsearch 的可靠性，需要确保数据变化被持久化到磁盘。在动态更新索引，我们说一次完整的提交会将段刷到磁盘，并写入一个包含所有段列表的提交点。Elasticsearch 在启动或重新打开一个索引的过程中使用这个提交点来判断哪些段隶属于当前分片。</p>
<p>即使通过每秒刷新(refresh）实现了近实时搜索，我们仍然需要经常进行完整提交来确保能从失败中恢复。但在两次提交之间发生变化的文档怎么办?我们也不希望丢失掉这些数据。Elasticsearch 增加了一个translog ，或者叫事务日志，在每一次对Elasticsearch进行操作时均进行了日志记录。</p>
<p>整个流程如下:</p>
<p>一、一个文档被索引之后，就会被添加到内存缓冲区，并且追加到了 translog</p>
<p><img src="/images/database/es/%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%98%E6%9B%B4.png" alt="持久化变更.png"></p>
<p>二、刷新（refresh）使分片每秒被刷新（refresh）一次：</p>
<ul>
<li>这些在内存缓冲区的文档被写入到一个新的段中，且没有进行fsync操作。</li>
<li>这个段被打开，使其可被搜索。</li>
<li>内存缓冲区被清空。</li>
</ul>
<p><img src="/images/database/es/%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%98%E6%9B%B42.png" alt="持久化变更2.png"></p>
<p>三、这个进程继续工作，更多的文档被添加到内存缓冲区和追加到事务日志。</p>
<p><img src="/images/database/es/%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%98%E6%9B%B43.png" alt="持久化变更3.png"></p>
<p>四、每隔一段时间—例如translog变得越来越大，索引被刷新（flush）；一个新的translog被创建，并且一个全量提交被执行。</p>
<ul>
<li><p>所有在内存缓冲区的文档都被写入一个新的段。</p>
</li>
<li><p>缓冲区被清空。</p>
</li>
<li><p>一个提交点被写入硬盘。</p>
</li>
<li><p>文件系统缓存通过fsync被刷新（flush） 。</p>
</li>
<li><p>老的translog被删除。</p>
</li>
</ul>
<p>translog 提供所有还没有被刷到磁盘的操作的一个持久化纪录。当Elasticsearch启动的时候，它会从磁盘中使用最后一个提交点去恢复己知的段，并且会重放translog 中所有在最后一次提交后发生的变更操作。</p>
<p>translog 也被用来提供实时CRUD。当你试着通过ID查询、更新、删除一个文档，它会在尝试从相应的段中检索之前，首先检查 translog任何最近的变更。这意味着它总是能够实时地获取到文档的最新版本。</p>
<p><img src="/images/database/es/%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%98%E6%9B%B44.png" alt="持久化变更4.png"></p>
<p>执行一个提交并且截断translog 的行为在 Elasticsearch被称作一次flush。分片每30分钟被自动刷新（flush)，或者在 translog 太大的时候也会刷新。</p>
<p>你很少需要自己手动执行flush操作，通常情况下，自动刷新就足够了。这就是说，在重启节点或关闭索引之前执行 flush有益于你的索引。当Elasticsearch尝试恢复或重新打开一个索引，它需要重放translog中所有的操作，所以如果日志越短，恢复越快。</p>
<p>translog 的目的是保证操作不会丢失，在文件被fsync到磁盘前，被写入的文件在重启之后就会丢失。默认translog是每5秒被fsync刷新到硬盘，或者在每次写请求完成之后执行（e.g. index, delete, update, bulk）。这个过程在主分片和复制分片都会发生。最终，基本上，这意味着在整个请求被fsync到主分片和复制分片的translog之前，你的客户端不会得到一个200 OK响应。</p>
<p>在每次请求后都执行一个fsync会带来一些性能损失，尽管实践表明这种损失相对较小（特别是 bulk 导入，它在一次请求中平摊了大量文档的开销）。</p>
<p>但是对于一些大容量的偶尔丢失几秒数据问题也并不严重的集群，使用异步的 fsync还是比较有益的。比如，写入的数据被缓存到内存中，再每5秒执行一次 fsync 。如果你决定使用异步translog 的话，你需要保证在发生 crash 时，丢失掉 sync_interval时间段的数据也无所谓。请在决定前知晓这个特性。如果你不确定这个行为的后果，最好是使用默认的参数{“index.translog.durability”: “request”}来避免数据丢失。</p>
<h3 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h3><p>由于自动刷新流程每秒会创建一个新的段，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。每一个段都会消耗文件句柄、内存和 cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。</p>
<p>Elasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。</p>
<p>段合并的时候会将那些旧的已删除文档从文件系统中清除。被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。</p>
<p>启动段合并不需要你做任何事。进行索引和搜索时会自动进行。</p>
<p>一、当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用。</p>
<p>二、合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。这并不会中断索引和搜索。</p>
<p><img src="/images/database/es/%E6%AE%B5%E5%90%88%E5%B9%B6.png" alt="段合并.png"></p>
<p>三、一旦合并结束，老的段被删除</p>
<ul>
<li>新的段被刷新(flush)到了磁盘。</li>
<li>写入一个包含新段且排除旧的和较小的段的新提交点。</li>
<li>新的段被打开用来搜索。老的段被删除。</li>
</ul>
<p>合并大的段需要消耗大量的 I/O 和 CPU 资源，如果任其发展会影响搜索性能。 Elasticsearch在默认情况下会对合并流程进行资源限制，所以搜索仍然有足够的资源很好地执行。</p>
<h2 id="文档分析"><a href="#文档分析" class="headerlink" title="文档分析"></a>文档分析</h2><p>分析包含下面的过程：</p>
<ul>
<li>将一块文本分成适合于倒排索引的独立的词条。</li>
<li>将这些词条统一化为标准格式以提高它们的“可搜索性”，或者recall。</li>
</ul>
<p>分析器执行上面的工作。分析器实际上是将三个功能封装到了一个包里：</p>
<ul>
<li>字符过滤器：首先，字符串按顺序通过每个 字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉 HTML，或者将 &amp; 转化成 and。</li>
<li>分词器：其次，字符串被分词器分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。</li>
<li>Token 过滤器：最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条（例如，小写化Quick ），删除词条（例如， 像 a， and， the 等无用词），或者增加词条（例如，像jump和leap这种同义词）</li>
</ul>
<h2 id="文档控制"><a href="#文档控制" class="headerlink" title="文档控制"></a>文档控制</h2><p>使用乐观锁（版本号）</p>
<h1 id="SpringData集成"><a href="#SpringData集成" class="headerlink" title="SpringData集成"></a>SpringData集成</h1><p><a href="https://spring.io/projects/spring-data-elasticsearch" target="_blank" rel="noopener">Spring Data Elasticsearch 官网</a></p>
<ol>
<li><p>创建Maven项目。</p>
</li>
<li><p>修改pom文件，增加依赖关系。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringDataWithES<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>增加配置文件application.properties</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># es 服务地址</span></span><br><span class="line"><span class="meta">elasticsearch.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># es 服务端口</span></span><br><span class="line"><span class="meta">elasticsearch.port</span>=<span class="string">9200</span></span><br><span class="line"><span class="comment"># 配置日志级别,开启 debug 日志</span></span><br><span class="line"><span class="meta">logging.level.com.atguigu.es</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>主启动类</li>
<li>数据实体类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Document;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Field;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.FieldType;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"shopping"</span>, shards = <span class="number">3</span>, replicas = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">//必须有 id,这里的 id 是全局唯一的标识，等同于 es 中的"_id"</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//商品唯一标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * type : 字段数据类型</span></span><br><span class="line"><span class="comment">     * analyzer : 分词器类型</span></span><br><span class="line"><span class="comment">     * index : 是否索引(默认:true)</span></span><br><span class="line"><span class="comment">     * Keyword : 短语,不进行分词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Text, analyzer = <span class="string">"ik_max_word"</span>)</span><br><span class="line">    <span class="keyword">private</span> String title;<span class="comment">//商品名称</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Keyword)</span><br><span class="line">    <span class="keyword">private</span> String category;<span class="comment">//分类名称</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Double)</span><br><span class="line">    <span class="keyword">private</span> Double price;<span class="comment">//商品价格</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Keyword, index = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String images;<span class="comment">//图片地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>配置类</li>
</ol>
<ul>
<li>ElasticsearchRestTemplate是spring-data-elasticsearch项目中的一个类,和其他spring项目中的 template类似。</li>
<li>在新版的spring-data-elasticsearch 中，ElasticsearchRestTemplate 代替了原来的ElasticsearchTemplate。</li>
<li>原因是ElasticsearchTemplate基于TransportClient，TransportClient即将在8.x 以后的版本中移除。所以，我们推荐使用ElasticsearchRestTemplate。</li>
<li>ElasticsearchRestTemplate基于RestHighLevelClient客户端的。需要自定义配置类，继承AbstractElasticsearchConfiguration，并实现elasticsearchClient()抽象方法，创建RestHighLevelClient对象。</li>
</ul>
<p>需要自定义配置类，继承AbstractElasticsearchConfiguration，并实现elasticsearchClient()抽象方法，创建RestHighLevelClient对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.config.AbstractElasticsearchConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"elasticsearch"</span>)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchConfig</span> <span class="keyword">extends</span> <span class="title">AbstractElasticsearchConfiguration</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host ;</span><br><span class="line">    <span class="keyword">private</span> Integer port ;</span><br><span class="line">    <span class="comment">//重写父类方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">elasticsearchClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestClientBuilder builder = RestClient.builder(<span class="keyword">new</span> HttpHost(host, port));</span><br><span class="line">        RestHighLevelClient restHighLevelClient = <span class="keyword">new</span></span><br><span class="line">                RestHighLevelClient(builder);</span><br><span class="line">        <span class="keyword">return</span> restHighLevelClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>DAO 数据访问对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.model.Product;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductDao</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Product</span>, <span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="框架集成-SpringData-集成测试-索引操作"><a href="#框架集成-SpringData-集成测试-索引操作" class="headerlink" title="框架集成-SpringData-集成测试-索引操作"></a>框架集成-SpringData-集成测试-索引操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.model.Product;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringDataESIndexTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入 ElasticsearchRestTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticsearchRestTemplate elasticsearchRestTemplate;</span><br><span class="line">    <span class="comment">//创建索引并增加映射配置</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建索引，系统初始化会自动创建索引</span></span><br><span class="line">        System.out.println(<span class="string">"创建索引"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建索引，系统初始化会自动创建索引</span></span><br><span class="line">        <span class="keyword">boolean</span> flg = elasticsearchRestTemplate.deleteIndex(Product<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"删除索引 = "</span> + flg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="框架集成-SpringData-集成测试-文档操作"><a href="#框架集成-SpringData-集成测试-文档操作" class="headerlink" title="框架集成-SpringData-集成测试-文档操作"></a>框架集成-SpringData-集成测试-文档操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.dao.ProductDao;</span><br><span class="line"><span class="keyword">import</span> com.lun.model.Product;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.PageRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Sort;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringDataESProductDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductDao productDao;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.setId(<span class="number">2L</span>);</span><br><span class="line">        product.setTitle(<span class="string">"华为手机"</span>);</span><br><span class="line">        product.setCategory(<span class="string">"手机"</span>);</span><br><span class="line">        product.setPrice(<span class="number">2999.0</span>);</span><br><span class="line">        product.setImages(<span class="string">"http://www.atguigu/hw.jpg"</span>);</span><br><span class="line">        productDao.save(product);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//POSTMAN, GET http://localhost:9200/product/_doc/2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.setId(<span class="number">2L</span>);</span><br><span class="line">        product.setTitle(<span class="string">"小米 2 手机"</span>);</span><br><span class="line">        product.setCategory(<span class="string">"手机"</span>);</span><br><span class="line">        product.setPrice(<span class="number">9999.0</span>);</span><br><span class="line">        product.setImages(<span class="string">"http://www.atguigu/xm.jpg"</span>);</span><br><span class="line">        productDao.save(product);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//POSTMAN, GET http://localhost:9200/product/_doc/2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 id 查询</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Product product = productDao.findById(<span class="number">2L</span>).get();</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Iterable&lt;Product&gt; products = productDao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (Product product : products) &#123;</span><br><span class="line">            System.out.println(product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.setId(<span class="number">2L</span>);</span><br><span class="line">        productDao.delete(product);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//POSTMAN, GET http://localhost:9200/product/_doc/2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量新增</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Product&gt; productList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Product product = <span class="keyword">new</span> Product();</span><br><span class="line">            product.setId(Long.valueOf(i));</span><br><span class="line">            product.setTitle(<span class="string">"["</span>+i+<span class="string">"]小米手机"</span>);</span><br><span class="line">            product.setCategory(<span class="string">"手机"</span>);</span><br><span class="line">            product.setPrice(<span class="number">1999.0</span> + i);</span><br><span class="line">            product.setImages(<span class="string">"http://www.atguigu/xm.jpg"</span>);</span><br><span class="line">            productList.add(product);</span><br><span class="line">        &#125;</span><br><span class="line">        productDao.saveAll(productList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分页查询</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByPageable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置排序(排序方式，正序还是倒序，排序的 id)</span></span><br><span class="line">        Sort sort = Sort.by(Sort.Direction.DESC,<span class="string">"id"</span>);</span><br><span class="line">        <span class="keyword">int</span> currentPage=<span class="number">0</span>;<span class="comment">//当前页，第一页从 0 开始， 1 表示第二页</span></span><br><span class="line">        <span class="keyword">int</span> pageSize = <span class="number">5</span>;<span class="comment">//每页显示多少条</span></span><br><span class="line">        <span class="comment">//设置查询分页</span></span><br><span class="line">        PageRequest pageRequest = PageRequest.of(currentPage, pageSize,sort);</span><br><span class="line">        <span class="comment">//分页查询</span></span><br><span class="line">        Page&lt;Product&gt; productPage = productDao.findAll(pageRequest);</span><br><span class="line">        <span class="keyword">for</span> (Product Product : productPage.getContent()) &#123;</span><br><span class="line">            System.out.println(Product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="框架集成-SpringData-集成测试-文档搜索"><a href="#框架集成-SpringData-集成测试-文档搜索" class="headerlink" title="框架集成-SpringData-集成测试-文档搜索"></a>框架集成-SpringData-集成测试-文档搜索</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.dao.ProductDao;</span><br><span class="line"><span class="keyword">import</span> com.lun.model.Product;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.QueryBuilders;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.TermQueryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.PageRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringDataESSearchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductDao productDao;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * term 查询</span></span><br><span class="line"><span class="comment">     * search(termQueryBuilder) 调用搜索方法，参数查询构建器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">termQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">"title"</span>, <span class="string">"小米"</span>);</span><br><span class="line">                Iterable&lt;Product&gt; products = productDao.search(termQueryBuilder);</span><br><span class="line">        <span class="keyword">for</span> (Product product : products) &#123;</span><br><span class="line">            System.out.println(product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * term 查询加分页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">termQueryByPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentPage= <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> pageSize = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//设置查询分页</span></span><br><span class="line">        PageRequest pageRequest = PageRequest.of(currentPage, pageSize);</span><br><span class="line">        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">"title"</span>, <span class="string">"小米"</span>);</span><br><span class="line">                Iterable&lt;Product&gt; products =</span><br><span class="line">                        productDao.search(termQueryBuilder,pageRequest);</span><br><span class="line">        <span class="keyword">for</span> (Product product : products) &#123;</span><br><span class="line">            System.out.println(product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="为什么要使用-Elasticsearch？"><a href="#为什么要使用-Elasticsearch？" class="headerlink" title="为什么要使用 Elasticsearch？"></a>为什么要使用 Elasticsearch？</h2><p>系统中的数据， 随着业务的发展，时间的推移， 将会非常多， 而业务中往往采用模糊查询进行数据的搜索， 而模糊查询会导致查询引擎放弃索引，导致系统查询数据时都是全表扫描，在百万级别的数据库中，查询效率是非常低下的，而我们使用 ES 做一个全文索引，将经常查询的系统功能的某些字段，比如说电商系统的商品表中商品名，描述、价格还有 id 这些字段我们放入 ES 索引库里，可以提高查询速度。</p>
<h2 id="Elasticsearch-的-master-选举流程？"><a href="#Elasticsearch-的-master-选举流程？" class="headerlink" title="Elasticsearch 的 master 选举流程？"></a>Elasticsearch 的 master 选举流程？</h2><ul>
<li>Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）<br>和Unicast（单播模块包含-一个主机列表以控制哪些节点需要ping通）这两部分。</li>
<li>对所有可以成为master的节点（node master: true）根据nodeId字典排序，每次选举每个节点都把自<br>己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。</li>
<li>如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，<br>那这个节点就是master。否则重新选举一直到满足上述条件。</li>
<li>master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http<br>功能。</li>
</ul>
<h2 id="Elasticsearch-集群脑裂问题？"><a href="#Elasticsearch-集群脑裂问题？" class="headerlink" title="Elasticsearch 集群脑裂问题？"></a>Elasticsearch 集群脑裂问题？</h2><p>“脑裂”问题可能的成因：</p>
<ul>
<li>网络问题：集群间的网络延迟导致一些节点访问不到master, 认为master 挂掉了从而选举出新的master,并对master上的分片和副本标红，分配新的主分片。</li>
<li>节点负载：主节点的角色既为master又为data,访问量较大时可能会导致ES停止响应造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。</li>
<li>内存回收：data 节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应。</li>
</ul>
<p>脑裂问题解决方案：</p>
<ul>
<li><p>减少误判：discovery.zen ping_ timeout 节点状态的响应时间，默认为3s，可以适当调大，如果master在该响应时间的范围内没有做出响应应答，判断该节点已经挂掉了。调大参数（如6s，discovery.zen.ping_timeout:6），可适当减少误判。</p>
</li>
<li><p>选举触发：discovery.zen.minimum. <em>master</em> nodes:1，该参數是用于控制选举行为发生的最小集群主节点数量。当备选主节点的个數大于等于该参数的值，且备选主节点中有该参数个节点认为主节点挂了，进行选举。官方建议为(n / 2) +1, n为主节点个数（即有资格成为主节点的节点个数）。</p>
</li>
<li><p>角色分离：即master节点与data节点分离，限制角色</p>
<ul>
<li>主节点配置为：node master: true，node data: false</li>
<li>从节点配置为：node master: false，node data: true</li>
</ul>
</li>
</ul>
<h2 id="Elasticsearch-索引文档的流程？"><a href="#Elasticsearch-索引文档的流程？" class="headerlink" title="Elasticsearch 索引文档的流程？"></a>Elasticsearch 索引文档的流程？</h2><p>![Elasticsearch 索引文档的流程.png](/images/database/es/Elasticsearch 索引文档的流程.png)</p>
<ul>
<li>协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合适的分片：shard = hash(document_id) % (num_of_primary_shards)</li>
<li>当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 Memory Buffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache，这个从 Memory Buffer 到 Filesystem Cache 的过程就叫做 refresh；</li>
<li>当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会丢失， ES 是通过 translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中，当 Filesystemcache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 flush；</li>
<li>在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync 将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。</li>
<li>flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认为 512M）时；</li>
</ul>
<h2 id="Elasticsearch-更新和删除文档的流程？"><a href="#Elasticsearch-更新和删除文档的流程？" class="headerlink" title="Elasticsearch 更新和删除文档的流程？"></a>Elasticsearch 更新和删除文档的流程？</h2><ul>
<li>删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更；</li>
<li>磁盘上的每个段都有一个相应的.del 文件。当删除请求发送后，文档并没有真的被删除，而是在.del文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入新段。</li>
<li>在新的文档被创建时， Elasticsearch 会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</li>
</ul>
<h2 id="Elasticsearch-搜索的流程？"><a href="#Elasticsearch-搜索的流程？" class="headerlink" title="Elasticsearch 搜索的流程？"></a>Elasticsearch 搜索的流程？</h2><p>![Elasticsearch 搜索的流程.png](/images/database/es/Elasticsearch 搜索的流程.png)</p>
<ul>
<li>搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；</li>
<li>在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。 PS：在搜索的时候是会查询Filesystem Cache 的，但是有部分数据还在 Memory Buffer，所以搜索是近实时的。</li>
<li>每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</li>
<li>接下来就是取回阶段， 协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并丰富文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</li>
<li>Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确， DFS Query Then Fetch 增加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，但是性能会变差。</li>
</ul>
<h2 id="Elasticsearch-在部署时，对-Linux-的设置有哪些优化方法？"><a href="#Elasticsearch-在部署时，对-Linux-的设置有哪些优化方法？" class="headerlink" title="Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？"></a>Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？</h2><ul>
<li><p>64 GB 内存的机器是非常理想的， 但是 32 GB 和 16 GB 机器也是很常见的。少于 8 GB 会适得其反。</p>
</li>
<li><p>如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率。</p>
</li>
<li><p>如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查询和索引性能都有提升。如果你负担得起， SSD 是一个好的选择。</p>
</li>
<li><p>即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离。</p>
</li>
<li><p>请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在 Elasticsearch 的几个地方，使用 Java 的本地序列化。</p>
</li>
<li><p>通过设置 gateway.recover_after_nodes、 gateway.expected_nodes、 gateway.recover_after_time 可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟。</p>
</li>
<li><p>Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。</p>
</li>
<li><p>不要随意修改垃圾回收器（CMS）和各个线程池的大小。</p>
</li>
<li><p>把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过 ES_HEAP_SIZE 环境变量设置。</p>
</li>
<li><p>内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个 100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起来。 不难看出 swapping 对于性能是多么可怕。</p>
</li>
<li><p>Lucene 使用了大量的文件。同时， Elasticsearch 在节点和 HTTP 客户端之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你应该增加你的文件描述符，设置一个很大的值，如 64,000。</p>
</li>
</ul>
<h2 id="GC-方面，在使用-Elasticsearch-时要注意什么？"><a href="#GC-方面，在使用-Elasticsearch-时要注意什么？" class="headerlink" title="GC 方面，在使用 Elasticsearch 时要注意什么？"></a>GC 方面，在使用 Elasticsearch 时要注意什么？</h2><p>倒排词典的索引需要常驻内存，无法 GC，需要监控 data node 上 segment memory 增长趋势。</p>
<p>各类缓存， field cache, filter cache, indexing cache, bulk queue 等等，要设置合理的大小，并且要应该根据最坏的情况来看 heap 是否够用，也就是各类缓存全部占满的时候，还有 heap 空间可以分配给其他任务吗？避免采用 clear cache 等“自欺欺人”的方式来释放内存。</p>
<p>避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用 scan &amp; scroll api 来实现。</p>
<p>cluster stats 驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过 tribe node 连接。</p>
<p>想知道 heap 够不够，必须结合实际应用场景，并对集群的 heap 使用情况做持续的监控。</p>
<h2 id="Elasticsearch-对于大数据量（上亿量级）的聚合如何实现？"><a href="#Elasticsearch-对于大数据量（上亿量级）的聚合如何实现？" class="headerlink" title="Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？"></a>Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？</h2><p>Elasticsearch 提供的首个近似聚合是 cardinality 度量。它提供一个字段的基数，即该字段的 distinct或者 unique 值的数目。它是基于 HLL 算法的。 HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</p>
<h2 id="在并发情况下，-Elasticsearch-如果保证读写一致？"><a href="#在并发情况下，-Elasticsearch-如果保证读写一致？" class="headerlink" title="在并发情况下， Elasticsearch 如果保证读写一致？"></a>在并发情况下， Elasticsearch 如果保证读写一致？</h2><ul>
<li><p>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</p>
</li>
<li><p>另外对于写操作，一致性级别支持 quorum/one/all，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</p>
</li>
<li><p>对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查询主分片，确保文档是最新版本。</p>
</li>
</ul>
<h2 id="如何监控-Elasticsearch-集群状态？"><a href="#如何监控-Elasticsearch-集群状态？" class="headerlink" title="如何监控 Elasticsearch 集群状态？"></a>如何监控 Elasticsearch 集群状态？</h2><ol>
<li>elasticsearch-head 插件。</li>
<li>通过 Kibana 监控 Elasticsearch。你可以实时查看你的集群健康状态和性能，也可以分析过去的集群、索引和节点指标</li>
</ol>
<h2 id="是否了解字典树？"><a href="#是否了解字典树？" class="headerlink" title="是否了解字典树？"></a>是否了解字典树？</h2><p>字典树又称单词查找树， Trie 树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p>
<p>Trie 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。它有 3 个基本性质：</p>
<ul>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ul>
<p>对于中文的字典树，每个节点的子节点用一个哈希表存储，这样就不用浪费太大的空间，而且查询速度上可以保留哈希的复杂度 O(1)。</p>
<h2 id="Elasticsearch-中的集群、节点、索引、文档、类型是什么？"><a href="#Elasticsearch-中的集群、节点、索引、文档、类型是什么？" class="headerlink" title="Elasticsearch 中的集群、节点、索引、文档、类型是什么？"></a>Elasticsearch 中的集群、节点、索引、文档、类型是什么？</h2><ul>
<li>集群是一个或多个节点（服务器）的集合，它们共同保存您的整个数据，并提供跨所有节点的联合索引和搜索功能。群集由唯一名 称标识，默认情况下为”elasticsearch”。此名称很重要，因为如果节点设置为按名称加入群集，则该节点只能是群集的一部分。</li>
<li>节点是属于集群一部分的单个服务器。它存储数据并参与群集索引和搜索功能。</li>
<li>索引就像关系数据库中的“数据库”。它有一个定义多种类型的映射。索引是逻辑名称空间，映射到一个或多个主分片，并且可以有零个或多个副本分片。MySQL =&gt;数据库，Elasticsearch=&gt;索引。</li>
<li>文档类似于关系数据库中的一行。不同之处在于索引中的每个文档可以具有不同的结构(字段)，但是对于通用字段应该具有相同的数据类型。MySQL =&gt; Databases =&gt; Tables =&gt; Columns / Rows，Elasticsearch=&gt; Indices =&gt; Types =&gt;具有属性的文档Doc。</li>
<li>类型是索引的逻辑类别/分区，其语义完全取决于用户。</li>
</ul>
<h2 id="Elasticsearch-中的倒排索引是什么？"><a href="#Elasticsearch-中的倒排索引是什么？" class="headerlink" title="Elasticsearch 中的倒排索引是什么？"></a>Elasticsearch 中的倒排索引是什么？</h2><p>倒排索引是搜索引擎的核心。搜索引擎的主要目标是在查找发生搜索条件的文档时提供快速搜索。ES中的倒排索引其实就是 lucene 的倒排索引，区别于传统的正向索引， 倒排索引会再存储数据时将关键词和数据进行关联，保存到倒排表中，然后查询时，将查询内容进行分词后在倒排表中进行查询，最后匹配数据即可。</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 学习笔记 - 字节码与类的加载器</title>
    <url>/2021/06/04/java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1PJ411n7xZ" target="_blank" rel="noopener">尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）</a>学习记录</p>
<a id="more"></a>

<blockquote>
<p>笔记来源：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ" target="_blank" rel="noopener">尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）</a></p>
<p>参考笔记：<a href="https://github.com/sxlong0205/JavaBasicKnowledge/tree/main/JVM" target="_blank" rel="noopener">JavaBasicKnowledge/JVM at main · sxlong0205/JavaBasicKnowledge (github.com)</a></p>
</blockquote>
<h1 id="Class-文件结构"><a href="#Class-文件结构" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="字节码文件的跨平台性"><a href="#字节码文件的跨平台性" class="headerlink" title="字节码文件的跨平台性"></a>字节码文件的跨平台性</h3><ol>
<li><p><strong>Java 语言，跨平台的（write once，run anywhere）</strong></p>
<ul>
<li>当 Java 源代码成功编译成字节码后，如果想在不同的平台上面运行，则无须再次编译。</li>
<li>这个优势不再那么吸引人了。Python、PHP、Perl、Ruby、Lisp 等有强大的解释器。</li>
<li>跨平台似乎已经快称为一门语言必选的特性。</li>
</ul>
</li>
<li><p><strong>Java 虚拟机：跨语言的平台</strong></p>
<p><strong>Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与”Class 文件”这种特定的二进制文件格式所关联。</strong>无论使用何种语言进行软件开发， 只要能将源文件编译为正确的 Class 文件，那么这种语言就可以在 Java 虚拟机上执行，可以说，统一而强大的 Class 文件结构，就是 Java 虚拟机的基石、桥梁。</p>
<p><a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/index.html</a>，所有的 JVM 全部遵守 Java 虚拟机规范，也就是说所有的 JVM 环境都是一样的， 这样一来字节码文件可以在各种 JVM 上进行。</p>
</li>
<li><p><strong>想要让一个 Java 程序正确地运行在 JVM 中，Java 源码就是必须要被编译为符合 JVM 规范的字节码</strong></p>
<ul>
<li>前端编译器的主要任务就是负责将符合 Java 语法规范的 Java 代码转换为符合 JVM 规范的字节码文件。</li>
<li>javac 是一种能够将 Java 源码编译为字节码的前端编译器。</li>
<li>javac 编译器在将 Java 源码编译为一个有效的字节码文件过程中经历了 4 个步骤，分别是<strong>词法分析、语法分析、语义分析以及生成字节码。</strong></li>
</ul>
<p><img src="/images/java/jvm/%E4%B8%AD%E7%AF%87_%E7%AC%AC1%E7%AB%A0%EF%BC%9AJVM%E7%BB%93%E6%9E%84.jpg" alt="中篇_第1章：JVM结构.jpg"></p>
</li>
</ol>
<p>Oracle 的 JDK 软件包括两部分内容：</p>
<ul>
<li>一部分是将 Java 源代码编译成 Java 虚拟机的指令集的编译器。</li>
<li>另一部分是用于实现 Java 虚拟机的运行时环境。</li>
</ul>
<h3 id="Java-的前端编译器"><a href="#Java-的前端编译器" class="headerlink" title="Java 的前端编译器"></a>Java 的前端编译器</h3><p><img src="/images/java/jvm/%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.jpg" alt="理解执行引擎.jpg"></p>
<p>前端编译器 VS 后端编译器</p>
<p>Java 源代码的编译结果是字节码，那么肯定需要有一种编译器能够将 Java 源码编译为字节码，承担这个重要责任的就是配置在 path 环境变量中的 <strong>javac 编译器</strong>。javac 是一种能够将 Java 源码编译为字节码的<strong>前端编译器</strong>。</p>
<p>HotSpot VM 并没有强制要求前端编译器只能使用 javac 来编译字节码，其实只要编译结果符合 JVM 规范都可以被 JVM 所识别即可。在 Java 的前端编译器领域，除了 javac 之外，还有一种被大家经常用到的前端编译器，那就是内置在 Eclipse 中的 <strong>ECJ (Eclipse Compiler for Java)编译器</strong>。和 javac 的全量式编译不同，ECJ 是一种增量式编译器。</p>
<ul>
<li>在 Eclipse 中，当开发人员编写完代码后，使用”Ctrl + S”快捷键时，ECJ 编译器所采取的<strong>编译方案</strong>是把未编译部分的源码逐行进行编译，而非每次都全量编译。因此 ECJ 的编译效率会比 javac 更加迅速和高效，当然编译质量和 javac 相比大致还是一样的。</li>
<li>ECJ 不仅是 Eclipse 的默认内置前端编译器，在 Tomcat 中同样也是使用 ECJ 编译器来编译 JSP 文件。由于 ECJ 编译器是采用 GPLv2 的开源协议进行源代码公开，所以，大家可以登录 Eclipse 官网下载 ECJ 编译器的源码进行二次开发。</li>
<li>默认情况下，IntelliJ IDEA 使用 javac 编译器（还可以自己设置为 AspectJ 编译器 ajc）。</li>
</ul>
<p>前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给 HotSpot 的 JIT 编译器负责。</p>
<h3 id="透过字节码指令看代码细节"><a href="#透过字节码指令看代码细节" class="headerlink" title="透过字节码指令看代码细节"></a>透过字节码指令看代码细节</h3><ol>
<li>BAT 面试题<ol>
<li>类文件结构有几个部分？</li>
<li>知道字节码吗？字节码都有哪些？Integer x = 5; int y = 5; 比较 x == y 都经过哪些步骤？</li>
</ol>
</li>
<li>代码举例</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="number">10</span>;</span><br><span class="line">        Integer i2 = <span class="number">10</span>;</span><br><span class="line">        System.out.println(i1 == i2);</span><br><span class="line">        </span><br><span class="line">        Integer i3 = <span class="number">128</span>;</span><br><span class="line">        Integer i4 = <span class="number">128</span>;</span><br><span class="line">        System.out.println(i3 == i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">"hello"</span>) + <span class="keyword">new</span> String(<span class="string">"world"</span>);</span><br><span class="line">        String str1 = <span class="string">"helloworld"</span>;</span><br><span class="line">        System.out.println(str == str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father f = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(f.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        x = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Father.x = "</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        x = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son.x = "</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">Son.x = 0</span><br><span class="line">Son.x = 30</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<h2 id="虚拟机的基石：Class-文件"><a href="#虚拟机的基石：Class-文件" class="headerlink" title="虚拟机的基石：Class 文件"></a>虚拟机的基石：Class 文件</h2><h3 id="字节码文件里是什么？"><a href="#字节码文件里是什么？" class="headerlink" title="字节码文件里是什么？"></a>字节码文件里是什么？</h3><p>源代码经过编译器编译之后便会生成一个字节码文件，字节码是一种二进制的类文件，它的内容是 JVM 的指令，而不像 C、C++ 经由编译器直接生成机器码。</p>
<h3 id="什么事字节码指令（byte-code）？"><a href="#什么事字节码指令（byte-code）？" class="headerlink" title="什么事字节码指令（byte code）？"></a>什么事字节码指令（byte code）？</h3><p>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的<strong>操作码（opcode）</strong>以及跟随其后的零至多个代表此操作所需参数的<strong>操作数（operand）</strong>所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。</p>
<p>比如：</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4.png" alt="字节码指令.png"></p>
<h3 id="如何解读供虚拟机解释执行的二进制字节码？"><a href="#如何解读供虚拟机解释执行的二进制字节码？" class="headerlink" title="如何解读供虚拟机解释执行的二进制字节码？"></a>如何解读供虚拟机解释执行的二进制字节码？</h3><p>方式一：一个一个二进制的看，这里用到的是 Notepad++，需要安装一个 HEX-Editor 插件，或者使用 Binary Viewer；</p>
<p>方式二：使用 javap 指令，JDK 自带的反解析工具；</p>
<p>方式三：使用 IDEA 插件，jclasslib 或 jclasslib bytecode viewer 客户端工具。</p>
<h2 id="Class-文件结构-1"><a href="#Class-文件结构-1" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h2><ul>
<li><strong>官方文档位置</strong></li>
</ul>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p>
<ul>
<li><strong>Class 类的本质</strong></li>
</ul>
<p>任何一个 Class 文件都对应着唯一一个类或接口的定义信息，但反过来说，Class 文件实际上它并不一定以磁盘文件形式存在。Class 文件是一组以 8 位字节为基础单位的<strong>二进制流。</strong></p>
<ul>
<li><strong>Class 文件格式</strong></li>
</ul>
<p>Class 的结构不像 XML 等描述语言，由于它没有任何分隔符号。所以在其中的数据项，无论是字节顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。</p>
<p>Class 文件格式采用一种类似于 C 语言结构体的方式进行数据存储，这种结构中只有两种数据类型：<strong>无符号数</strong>和<strong>表。</strong></p>
<ol>
<li>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节、8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。</li>
<li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以”_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明。</li>
</ol>
<ul>
<li><strong>代码举例</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        num = num + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码文件：</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B.png" alt="字节码文件示例.png"></p>
<p><strong>换句话说，充分理解了每一个字节码文件的细节，自己也可以反编译出 Java 源文件来。</strong></p>
<ul>
<li><strong>Class 文件结构概述</strong></li>
</ul>
<p>Class 文件的结构并不是一成不变的，随着 Java 虚拟机的不断发展，总是不可避免地会对 Class 文件结构做出一些调整，但是其基本结构和框架是非常稳定的。</p>
<p>Class 文件的总体结构如下：</p>
<ol>
<li>魔数</li>
<li>Class 文件版本</li>
<li>常量池</li>
<li>访问标志</li>
<li>类索引、父类索引、接口索引集合</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>属性表集合</li>
</ol>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">说明</th>
<th align="center">长度</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u4</td>
<td align="center">magic</td>
<td align="center">魔数,识别Class文件格式</td>
<td align="center">4个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">minor_version</td>
<td align="center">副版本号(小版本)</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">major_version</td>
<td align="center">主版本号(大版本)</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">constant_pool_count</td>
<td align="center">常量池计数器</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">cp_info</td>
<td align="center">constant_pool</td>
<td align="center">常量池表</td>
<td align="center">n个字节</td>
<td align="center">constant_pool_count-1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">访问标识</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">this_class</td>
<td align="center">类索引</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">super_class</td>
<td align="center">父类索引</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces_count</td>
<td align="center">接口计数器</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces</td>
<td align="center">接口索引集合</td>
<td align="center">2个字节</td>
<td align="center">interfaces_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">fields_count</td>
<td align="center">字段计数器</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">field_info</td>
<td align="center">fields</td>
<td align="center">字段表</td>
<td align="center">n个字节</td>
<td align="center">fields_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">methods_count</td>
<td align="center">方法计数器</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">method_info</td>
<td align="center">methods</td>
<td align="center">方法表</td>
<td align="center">n个字节</td>
<td align="center">methods_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">属性计数器</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">属性表</td>
<td align="center">n个字节</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<h3 id="魔数：Class-文件的标志"><a href="#魔数：Class-文件的标志" class="headerlink" title="魔数：Class 文件的标志"></a>魔数：Class 文件的标志</h3><p>Magic Number（魔数）</p>
<ul>
<li>每个 Class 文件开头的 4 个字节的无符号整数称为魔数（Magic Number）。</li>
<li>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的 Class 文件。即：魔数是 Class 文件的标识符。</li>
<li>魔数值固定为 0xCAFEBABE。不会改变。</li>
<li>如果一个 Class 文件不以 0xCAFEBABE 开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：</li>
</ul>
<blockquote>
<p>Error: A JNI error has occurred, please check your installation and try again </p>
<p>Exception in thread “main” java.lang.ClassFormatError: Incompatible magic value 1885430635 in class file StringTest</p>
</blockquote>
<ul>
<li>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。</li>
</ul>
<h3 id="Class-文件版本号"><a href="#Class-文件版本号" class="headerlink" title="Class 文件版本号"></a>Class 文件版本号</h3><ul>
<li>紧接着魔数的 4 个字节存储的是 Class 文件的版本号。同样也是 4 个字节。第 5 个和第 6 个字节所代表的含义就是编译的副版本号 minor_version，而第 7 个和第 8 个字节就是编译的主版本号 major_version。</li>
<li>它们共同构成了 Class 文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个 Class 文件的格式版本号就确定为 M.m。</li>
<li>版本号和 Java 编译器的对应关系如下表：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">主版本（十进制）</th>
<th align="center">副版本（十进制）</th>
<th align="center">编译器版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">45</td>
<td align="center">3</td>
<td align="center">1.1</td>
</tr>
<tr>
<td align="center">46</td>
<td align="center">0</td>
<td align="center">1.2</td>
</tr>
<tr>
<td align="center">47</td>
<td align="center">0</td>
<td align="center">1.3</td>
</tr>
<tr>
<td align="center">48</td>
<td align="center">0</td>
<td align="center">1.4</td>
</tr>
<tr>
<td align="center">49</td>
<td align="center">0</td>
<td align="center">1.5</td>
</tr>
<tr>
<td align="center">50</td>
<td align="center">0</td>
<td align="center">1.6</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">0</td>
<td align="center">1.7</td>
</tr>
<tr>
<td align="center">52</td>
<td align="center">0</td>
<td align="center">1.8</td>
</tr>
<tr>
<td align="center">53</td>
<td align="center">0</td>
<td align="center">1.9</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">0</td>
<td align="center">1.10</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">0</td>
<td align="center">1.11</td>
</tr>
</tbody></table>
<ul>
<li>Java 的版本号是从 45 开始的，JDK 1.1 之后的每个 JDK 大版本发布主版本号向上加 1。</li>
<li><strong>不同版本的 Java 编译器编译的 Class 文件对应的版本是不一样的。目前，高版本的 Java 虚拟机可以执行由低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行由高版本编译器生成的 Class 文件。否则 JVM 会抛出 <code>java.lang.UnsupportedClassVersionError</code> 异常（向下兼容）。</strong></li>
<li>在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的 JDK 版本和生产环境的 JDK 版本是否一致。<ul>
<li>虚拟机 JDK 版本为 1.k（k &gt;= 2）时，对应的 Class 文件格式版本号的范围为 45.0 - 44 + k.0（含两端）。</li>
</ul>
</li>
</ul>
<h3 id="常量池：存放所有常量"><a href="#常量池：存放所有常量" class="headerlink" title="常量池：存放所有常量"></a>常量池：存放所有常量</h3><ul>
<li>常量池是 Class 文件中内容最为丰富的区域之一。常量池对于 Class 文件中的字段和方法解析也有着至关重要的作用。</li>
<li>随着 Java 虚拟机的不断发展，常量池的内容也日渐丰富，可以说，常量池是整个 Class 文件的基石。</li>
<li>在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。</li>
<li>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池容量计数值（constant_pool_count），与 Java 中语言习惯不一样的是，这个容量计数是从 1 而不是 0 开始的。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2(无符号数)</td>
<td align="center">constant_pool_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">cp_info(表)</td>
<td align="center">constant_pool</td>
<td align="center">constant_pool_count - 1</td>
</tr>
</tbody></table>
<p>由上表可见，Class 文件使用了一个前置的容量计数器（constant_pool_count）加若干个连续的数据项（constant_pool）的形式来描述常量池内容，我们把这一系列连续常量池数据称为常量池集合。</p>
<ul>
<li><strong>常量池表项</strong>中，用于存放编译时期生成的各种<strong>字面量</strong>和<strong>符号引用</strong>，这部分内容将在类加载后进入方法区的<strong>运行时常量池</strong>中存放。</li>
</ul>
<h4 id="常量池计数器：存放所有常量"><a href="#常量池计数器：存放所有常量" class="headerlink" title="常量池计数器：存放所有常量"></a>常量池计数器：存放所有常量</h4><ul>
<li>由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。</li>
<li>常量池容量计数值（u2 类型）：从 1 开始，表示常量池中有多少项常量。即 constant_pool_count = 1 表示常量池中有 0 个常量项。</li>
<li>Demo 的值为：</li>
</ul>
<p><img src="/images/java/jvm/%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AE%A1%E6%95%B0%E5%99%A8demo.png" alt="常量池计数器demo.png"></p>
<p>其值为 0x0016，对应的十进制值为 22。</p>
<p>需要注意的是，这实际上只有 21 项常量。索引为范围是 1-21。为什么呢？</p>
<blockquote>
<p>通常我们写代码时都是从 0 开始的，但是这里的常量池却是从 1 开始，因为它把第 0 项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达”不引用任何一个常量池项目”的含义，这种情况可用索引值 0 来表示。</p>
</blockquote>
<h4 id="常量池表"><a href="#常量池表" class="headerlink" title="常量池表"></a>常量池表</h4><ul>
<li>constant_pool 是一种表结构，以 1 ~ constant_pool_count - 1 为索引。表明了后面有多少个常量项。</li>
<li>常量池主要存放两大类常量：<strong>字面量（Literal）</strong>和<strong>符号引用（Symbolic References）。</strong></li>
<li>它包含了 Class 文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第 1 个字节作为类型标记，用于确定该项的格式，这个字节称为 tag byte（标记字节、标签字节）。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">标志(或标识)</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONSTANT_utf8_info</td>
<td align="center">1</td>
<td align="center">UTF-8 编码的字符串</td>
</tr>
<tr>
<td align="center">CONSTANT_Integer_info</td>
<td align="center">3</td>
<td align="center">整型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Float_info</td>
<td align="center">4</td>
<td align="center">浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Long_info</td>
<td align="center">5</td>
<td align="center">长整型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Double_info</td>
<td align="center">6</td>
<td align="center">双精度浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Class_info</td>
<td align="center">7</td>
<td align="center">类或接口的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_String_info</td>
<td align="center">8</td>
<td align="center">字符串类型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Fieldref_info</td>
<td align="center">9</td>
<td align="center">字段的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_Methodref_info</td>
<td align="center">10</td>
<td align="center">类中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_InterfaceMethodref_info</td>
<td align="center">11</td>
<td align="center">接口中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_NameAndType_info</td>
<td align="center">12</td>
<td align="center">字段或方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodHandle_info</td>
<td align="center">15</td>
<td align="center">表示方法句柄</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodType_info</td>
<td align="center">16</td>
<td align="center">标志方法类型</td>
</tr>
<tr>
<td align="center">CONSTANT_InvokeDynamic_info</td>
<td align="center">18</td>
<td align="center">表示一个动态方法调用点</td>
</tr>
</tbody></table>
<h5 id="字面量和符号引用"><a href="#字面量和符号引用" class="headerlink" title="字面量和符号引用"></a>字面量和符号引用</h5><p>在对这些常量解读前，需要搞清楚几个概念：</p>
<p>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。如下表：</p>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">具体的常量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字面量</td>
<td align="center">文本字符串</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">声明为 final 的常量值</td>
</tr>
<tr>
<td align="center">符号引用</td>
<td align="center">类和接口的全限定名</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">字段的名称和描述符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">方法的名称和描述符</td>
</tr>
</tbody></table>
<h6 id="全限定名"><a href="#全限定名" class="headerlink" title="全限定名"></a>全限定名</h6><p>com/atguigu/test/Demo 这个就是类的全限定名，仅仅是把包的”.”替换成”/“，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个”;”表示全限定名结束。</p>
<h6 id="简单名称"><a href="#简单名称" class="headerlink" title="简单名称"></a>简单名称</h6><p>简单名称是指没有类型和参数修饰的方法或者字段名称，上面例子中的类的 add() 方法和 num 字段的简单名称分别是 add 和 num。</p>
<h6 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h6><p><strong>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</strong>根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的 void 类型都用一个大写字符来表示，而对象类型则用字符 L 加对象的全限定名表示，详见下表：</p>
<table>
<thead>
<tr>
<th align="center">标志符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B</td>
<td align="center">基本数据类型 byte</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">基本数据类型 char</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">基本数据类型 double</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">基本数据类型 float</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">基本数据类型 int</td>
</tr>
<tr>
<td align="center">J</td>
<td align="center">基本数据类型 long</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">基本数据类型 short</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">基本数据类型 boolean</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">代表 void 类型</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td align="center">[</td>
<td align="center">数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td>
</tr>
</tbody></table>
<p>用描述符来藐视方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号”()”之内，如方法 <code>java.lang.String toString()</code>的描述符为 <code>() Ljava/lang/String;</code>，方法 <code>int abc(int[] x ,int y)</code>描述符为<code>([II) I</code></p>
<blockquote>
<p>虚拟机在加载 Class 文件时才会进行动态链接，也就是说，Class 文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。<strong>当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。</strong></p>
<p>这里说明下符号引用和直接引用的区别与关联：</p>
<ul>
<li>符号引用：符号引用以<strong>一组符号</strong>来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。<strong>符号引用与虚拟机实现的内存布局无关</strong>，引用的目标并不一定已经加载到内存中</li>
<li>直接引用：直接引用可以是直接指<strong>向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，</strong>同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</li>
</ul>
</blockquote>
<h5 id="常量类型和结构"><a href="#常量类型和结构" class="headerlink" title="常量类型和结构"></a>常量类型和结构</h5><p>常量池中每一项常量都是一个表，JDK 1.7 之后共 14 种不同的表结构数据。如下表格所示：</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">常量</th>
<th align="center">描述</th>
<th align="center">细节</th>
<th align="center">长度</th>
<th align="center">细节描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">CONSTANT_utf8_info</td>
<td align="center">UTF-8 编码的字符串</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为1</td>
</tr>
<tr>
<td align="center">length</td>
<td align="center">u2</td>
<td align="center">UTF-8 编码的字符串占用的字符数</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">bytes</td>
<td align="center">u1</td>
<td align="center">长度为 length 的 UTF-8 编码的字符串</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">CONSTANT_Integer_info</td>
<td align="center">整型字面量</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为3</td>
</tr>
<tr>
<td align="center">bytes</td>
<td align="center">u4</td>
<td align="center">按照高位在前存储的 int 值</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">CONSTANT_Float_info</td>
<td align="center">浮点型字面量</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为4</td>
</tr>
<tr>
<td align="center">bytes</td>
<td align="center">u4</td>
<td align="center">按照高位在前存储的 float 值</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">CONSTANT_Long_info</td>
<td align="center">长整型字面量</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为5</td>
</tr>
<tr>
<td align="center">bytes</td>
<td align="center">u8</td>
<td align="center">按照高位在前存储的 long 值</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">CONSTANT_Double_info</td>
<td align="center">双精度浮点型字面量</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为6</td>
</tr>
<tr>
<td align="center">bytes</td>
<td align="center">u8</td>
<td align="center">按照高位在前存储的 double 值</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">CONSTANT_Class_info</td>
<td align="center">类或接口的符号引用</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为7</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向全限定名常量项的索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">CONSTANT_String_info</td>
<td align="center">字符串类型字面量</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为8</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向字符串字面量的索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">CONSTANT_Fieldref_info</td>
<td align="center">字段的符号引用</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为9</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向声明字段的类或接口描述符 CONSTANT_Class_info 的索引项</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向字段描述符 CONSTANT_NameAndType 的索引项</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">CONSTANT_Methodref_info</td>
<td align="center">类中方法的符号引用</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为10</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向声明方法的类描述符 CONSTANT_Class_Info 的索引项</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向名称及类型描述符 CONSTANT_NameAndType 的索引项</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">CONSTANT_InterfaceMethodref_info</td>
<td align="center">接口中方法的符号引用</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为11</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向声明方法的接口描述符 CONSTANT_Class_Info 的索引项</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向名称及类型描述符 CONSTANT_NameAndType 的索引项</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">CONSTANT_NameAndType_info</td>
<td align="center">字段或方法的符号引用</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为12</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向该字段或方法名称常量项的索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向该字段或方法描述符常量项的索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">CONSTANT_MethodHandle_info</td>
<td align="center">表示方法句柄</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为15</td>
</tr>
<tr>
<td align="center">reference_kind</td>
<td align="center">u1</td>
<td align="center">值必须在 1-9 之间，它决定了方法句柄的类型方法句柄类型的值表示方法句柄的字节码行为</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">reference_index</td>
<td align="center">u2</td>
<td align="center">值必须是对常量池的有效索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">CONSTANT_MethodType_info</td>
<td align="center">标志方法类型</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为16</td>
</tr>
<tr>
<td align="center">descriptor_index</td>
<td align="center">u2</td>
<td align="center">值必须是对常量池的有效索引，常量池在该索引处的项必须是 CONSTANT_Utf8_info 结构，表示方法的描述符</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">CONSTANT_InvokeDynamic_info</td>
<td align="center">表示一个动态方法调用点</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为18</td>
</tr>
<tr>
<td align="center">bootstrap_method_attr</td>
<td align="center">u2</td>
<td align="center">值必须是对当前 Class 文件中引导方法表的 bootstrap_methods[] 数组的有效索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">name_and_type_index</td>
<td align="center">u2</td>
<td align="center">值必须是对当前常量池的有效索引，常量池在该索引处的项必须是 CONSTANT_NameAndType_Info 结构，表示方法名和方法描述符</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>根据上图每个类型的描述我们也可以知道每个类型是用来描述常量池中那些内容（主要是字面量、符号引用）的。比如： CONSTANT_Integer_info 是用来描述常量池中字面量信息的，而且只是整型字面量信息。</li>
<li>标志为 15、16、18 的常量项类型是用来支持动态语言调用的（JDK 1.7 时才加入）。</li>
<li>细节说明<ul>
<li>CONSTANT_Class_info 结构用于表示类或接口。</li>
<li>CONSTANT_Fieldref_info、CONSTANT_Methodref_info 和 CONSTANT_InterfaceMethodref_info 结构表示字段、方法和接口方法。</li>
<li>CONSTANT_String_info 结构用于表示 String 类型的常量对象。</li>
<li>CONSTANT_Integer_info 和 CONSTANT_Float_info 表示 4 字节（int 和 float）的数值常量。</li>
<li>CONSTANT_Long_info 和 CONSTANT_Double_info 结构表示 8 字节（long 和 double）的数值常量。<ul>
<li>在 Class 文件的常量池中，所有的 8 字节常量均占两个表成员（项）的空间，如果一个 CONSTANT_Long_info 或 CONSTANT_Double_info 结构的项在常量池表中的索引位 n，则常量池表中下一个可用项的索引位 n + 2，此时常量池表中索引为 n + 1，的项仍然有效但必须视为不可用的。</li>
</ul>
</li>
<li>CONSTANT_NameAndType_info 结构用于表示字段或方法，但是和之前的 3 个结构不同，CONSTANT_NameAndType_info 结构没有指明该字段或方法所属的类或接口。</li>
<li>CONSTANT_Utf8_info 用于表示字符常量的值。</li>
<li>CONSTANT_MethodHandle_info 结构用于表示方法句柄。</li>
<li>CONSTANT_MethodType_info 结构表示方法类型。</li>
<li>CONSTANT_InvokeDynamic_info 结构用于表示 invokedynamic 指令所用到的引导方法（bootstrap method）、引导方法所用到的动态调用名称（dynamic invocation name）、参数和返回类型，并可以给引导方法传入一系列称为静态参数（static argument）的常量。</li>
</ul>
</li>
<li>解析方式<ul>
<li>一个字节一个字节的解析。</li>
<li>使用 javap 命令解析：javap -verbose Demo.class 或 jclasslib 工具会更方便。</li>
</ul>
</li>
</ul>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul>
<li>这 14 种表（或者常量项结构）的共同点是：表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</li>
<li>在常量池列表中，CONSTANT_Utf8_info 常量项是一种使用改进过的 UTF-8 编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。</li>
<li>这 14 种常量项结构还有一个特点是，其中 13 个常量项占用的字节固定，只有 CONSTANT_Utf8_info 占用字节不固定，其大小由 length 决定。为什么？<strong>因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定，</strong>比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过 UTF-8 编码，就可以知道其长度。</li>
<li>常量池：可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用 Class 文件空间最大的数据项目之一。</li>
<li>常量池中为什么包含这些内容？</li>
</ul>
<blockquote>
<p>Java 代码在进行 javac 编译的时候，并不像 C 和 C++ 那样有”连接”这一步骤，而是在虚拟机加载 Class 文件的时候进行动态链接。也就是说，<strong>在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。</strong>当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
</blockquote>
<h3 id="访问标识"><a href="#访问标识" class="headerlink" title="访问标识"></a>访问标识</h3><ul>
<li>在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。各种访问标记如下所示：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">标志名称</th>
<th align="center">标志值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACC_PUBLIC</td>
<td align="center">0x0001</td>
<td align="center">标志为 public 类型</td>
</tr>
<tr>
<td align="center">ACC_FINAL</td>
<td align="center">0x0010</td>
<td align="center">标志被声明为 final，只有类可以设置</td>
</tr>
<tr>
<td align="center">ACC_SUPER</td>
<td align="center">0x0020</td>
<td align="center">标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2 之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td>
</tr>
<tr>
<td align="center">ACC_INTERFACE</td>
<td align="center">0x0200</td>
<td align="center">标志这是一个接口</td>
</tr>
<tr>
<td align="center">ACC_ABSTRACT</td>
<td align="center">0x0400</td>
<td align="center">是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td align="center">ACC_SYNTHETIC</td>
<td align="center">0x1000</td>
<td align="center">标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td>
</tr>
<tr>
<td align="center">ACC_ANNOTATION</td>
<td align="center">0x2000</td>
<td align="center">标志这是一个注解</td>
</tr>
<tr>
<td align="center">ACC_ENUM</td>
<td align="center">0x4000</td>
<td align="center">标志这是一个枚举</td>
</tr>
</tbody></table>
<ul>
<li>类的访问权限通常为 ACC_ 开头的常量。</li>
<li>每一个种类型的表示都是通过设置访问标记的 32 位中的特定位来实现的。比如，若是 public final 的类，则该标记为 ACC_PUBLIC | ACC_FINAL。</li>
<li>使用 ACC_SUPER 可以让类更准确地定位到父类的方法 super.method()，现代编译器都会设置并且使用这个标记。</li>
</ul>
<blockquote>
<ol>
<li>带有 ACC_INTERFACE 标志的 Class 文件表示的是接口而不是类，反之则表示的是类而不是接口。<ol>
<li>如果一个 Class 文件被设置了 ACC_INTERFACE 标志，那么同时也得设置 ACC_ABSTRACT 标志。同时它不能再设置 ACC_FINAL、ACC_SUPER 或 ACC_ENUM 标志。</li>
<li>如果没有设置 ACC_INTERFACE 标志，那么这个 Class 问价可以具有上表中除 ACC_ANNOTATION 外的其他所有标志。当然，ACC_FINAL 和 ACC_ABSTRACT 这类互斥的标志除外。这两个标志不能同时设置。</li>
</ol>
</li>
<li>ACC_SUPER 标志用于确定类或接口里面的 invokespecial 指令使用的是哪一种执行语义。<strong>针对 Java 虚拟机指令集的编译器都应当设置这个标志。</strong>对于 Java SE 8 及后续版本来说，无论 Class 文件中这个标志的实际值是什么，也不管 Class 文件的版本。</li>
<li>ACC_SYNTHETIC 标志意味着该类或接口是由编译器生成的，而不是由源代码生成的。</li>
<li>注解类型必须设置 ACC_ANNOTATION 标志。如果设置了 ACC_ANNOTATION 标志，那么也必须设置 ACC_INTERFACE 标志。</li>
<li>ACC_ENUM 标志标明该类或其父类为枚举类型。</li>
<li>表中没有使用的 access_flags 标志是为未来扩充而预留的，这些预留的标志在编译器中应该设置为 0，Java 虚拟机实现也应该忽略他们。</li>
</ol>
</blockquote>
<h3 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="headerlink" title="类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h3><ul>
<li>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">长度</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">this_class</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">super_class</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces[interfaces_count]</td>
</tr>
</tbody></table>
<ul>
<li>这三项数据来确定这个类的继承关系<ul>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名。由于 Java 语言不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。</li>
<li>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。</li>
</ul>
</li>
</ul>
<ol>
<li>this_class（类索引）</li>
</ol>
<ul>
<li>2 字节无符号整数，指向常量池的索引。它提供了类的全限定名，如 com/atguigu/java1/Demo。this_class 的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为 CONSTANT_Class_info 类型结构体，该结构体表示这个 Class 文件所定义的类或接口。</li>
</ul>
<ol start="2">
<li>super_class（父类索引）</li>
</ol>
<ul>
<li>2 字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是 java/lang/Object 类。同时，由于 Java 不支持多继承，所以其父类只有一个。</li>
<li>superclass 指向的父类不能是 final。</li>
</ul>
<ol start="3">
<li>interfaces</li>
</ol>
<ul>
<li><p>指向常量池索引集合，它提供了一个符号引用到所有已实现的接口。</p>
</li>
<li><p>由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的 CONSTANT_Class（当然这里就必须是接口，而不是类）。</p>
<p>3.1 interfaces_count（接口计数器）</p>
<p>interfaces_count 项的值表示当前类或接口的直接超接口数量。</p>
<p>3.2 interface[] （接口索引集合）</p>
<p>interfaces[] 中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 interfaces_count。每个成员 interfaces[i] 必须为 CONSTANT_Class_info 结构，其中 0 &lt;= i &lt; interfaces_count。在 interfaces[] 中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即 interfaces[0] 对应的是源代码中最左边的接口。</p>
</li>
</ul>
<h3 id="字段表集合（Fields）"><a href="#字段表集合（Fields）" class="headerlink" title="字段表集合（Fields）"></a>字段表集合（Fields）</h3><ul>
<li>用于描述接口或类中声明的变量。字段（field）包括<strong>类级变量以及实例级变量</strong>，但是不包括方法内部、代码块内部声明的局部变量。</li>
<li>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</li>
<li>它指向常量池索引集合，它描述了每个字段的完整信息。比如<strong>字段的标识符、访问修饰符（public、private 或 protected）、是类变量还是实例变量（static 修饰符）、是否是常量（final 修饰符）</strong>等。</li>
</ul>
<blockquote>
<p>注意事项：</p>
<ul>
<li>字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原 Java 代码中不存在的字段，譬如在内部类中为了保持对外部类的方文星，会自动添加指向外部类实例的字段。</li>
<li>在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</li>
</ul>
</blockquote>
<h4 id="字段计数器（fields-count）"><a href="#字段计数器（fields-count）" class="headerlink" title="字段计数器（fields_count）"></a>字段计数器（fields_count）</h4><p>fields_count 的值表示当前 Class 文件 fields 表的成员个数，使用两个字节来表示。</p>
<p>fields 表中每个成员都是一个 field_info 结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。</p>
<h4 id="fields-（字段表）"><a href="#fields-（字段表）" class="headerlink" title="fields []（字段表）"></a>fields []（字段表）</h4><p>fields 表中的每个成员都必须是一个 fields_info 结构的数据项，用于表示当前类或接口中某个字段的完整描述。</p>
<p>一个字段的信息包括如下这些信息，这些信息中，<strong>各个修饰符都是布尔值，要么有，要么没有</strong>。</p>
<ul>
<li>作用域（public、private、protected 修饰符）</li>
<li>是实例变量还是类变量（static 修饰符）</li>
<li>可变性（final）</li>
<li>并发可见性（volatile 修饰符，是否强制从主内存读写）</li>
<li>可否序列化（transient 修饰符）</li>
<li>字段数据类型（基本数据类型、对象、数组）</li>
<li>字段名称</li>
</ul>
<p>字段表结构：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">含义</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">访问标志</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">name_index</td>
<td align="center">字段名索引</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">descriptor_index</td>
<td align="center">描述符索引</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">属性计数器</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">属性集合</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<h5 id="字段表访问标识"><a href="#字段表访问标识" class="headerlink" title="字段表访问标识"></a>字段表访问标识</h5><p>我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符（public、private、protected）、static 修饰符、final 修饰符、volatile 修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些：</p>
<table>
<thead>
<tr>
<th align="center">标志名称</th>
<th align="center">标志值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACC_PUBLIC</td>
<td align="center">0x0001</td>
<td align="center">字段是否为 public</td>
</tr>
<tr>
<td align="center">ACC_PRIVATE</td>
<td align="center">0x0002</td>
<td align="center">字段是否为 private</td>
</tr>
<tr>
<td align="center">ACC_PROTECTED</td>
<td align="center">0x0004</td>
<td align="center">字段是否为 protected</td>
</tr>
<tr>
<td align="center">ACC_STATIC</td>
<td align="center">0x0008</td>
<td align="center">字段是否为 static</td>
</tr>
<tr>
<td align="center">ACC_FINAL</td>
<td align="center">0x0010</td>
<td align="center">字段是否为 final</td>
</tr>
<tr>
<td align="center">ACC_VOLATILE</td>
<td align="center">0x0040</td>
<td align="center">字段是否为 volatile</td>
</tr>
<tr>
<td align="center">ACC_TRANSTENT</td>
<td align="center">0x0080</td>
<td align="center">字段是否为 transient</td>
</tr>
<tr>
<td align="center">ACC_SYNCHETIC</td>
<td align="center">0x1000</td>
<td align="center">字段是否为由编译器自动产生</td>
</tr>
<tr>
<td align="center">ACC_ENUM</td>
<td align="center">0x4000</td>
<td align="center">字段是否为 enum</td>
</tr>
</tbody></table>
<h5 id="字段名索引"><a href="#字段名索引" class="headerlink" title="字段名索引"></a>字段名索引</h5><p>根据字段名索引的值，查询常量池中的指定索引项即可。</p>
<h5 id="描述符索引"><a href="#描述符索引" class="headerlink" title="描述符索引"></a>描述符索引</h5><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）及代表无返回值的 void 类型都用一个大写字符来表示，而对象则用字符L加对象的全限定名来表示，如下所示：</p>
<table>
<thead>
<tr>
<th align="center">标志符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B</td>
<td align="center">基本数据类型 byte</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">基本数据类型 char</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">基本数据类型 double</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">基本数据类型 float</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">基本数据类型 int</td>
</tr>
<tr>
<td align="center">J</td>
<td align="center">基本数据类型 long</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">基本数据类型 short</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">基本数据类型 boolean</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">代表 void 类型</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td align="center">[</td>
<td align="center">数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td>
</tr>
</tbody></table>
<h5 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h5><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在 attribute_count 中，属性具体内容存放在 attributes 数组中。</p>
<p>以常量属性为例，结构为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConstantValue_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 constantvalue_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：对于常量属性而言，attribute_length 值恒为 <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>methods: 指向常量池索引集合，它完整描述了每个方法的签名。</p>
<ul>
<li>在字节码文件中，每一个 method_info 项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符（public、private 或 protected），方法的返回值类型以及方法的参数信息等。</li>
<li>如果这个方法不是抽象的或者不是 native 的，那么字节码中会体现出来。</li>
<li>一方面，methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods 表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如：类（接口）初始化方法 <clinit>() 和实例初始化方法 <init>()）</li>
</ul>
<blockquote>
<p>使用注意事项：</p>
<p>在 Java 语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 Class 文件中。</p>
<p>也就是说，尽管 Java 语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和 Java 语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。</p>
</blockquote>
<h4 id="methods-count（方法计数器）"><a href="#methods-count（方法计数器）" class="headerlink" title="methods_count（方法计数器）"></a>methods_count（方法计数器）</h4><p>methods_count 的值表示当前 Class 文件 methods 表的成员个数，使用两个字节来表示。</p>
<p>methods 表中每个成员都是一个 method_info 结构。</p>
<h4 id="methods-（方法表）"><a href="#methods-（方法表）" class="headerlink" title="methods[] （方法表）"></a>methods[] （方法表）</h4><ul>
<li>methods 表中的每个成员都必须是一个 method_info 结构，用于表示当前类或接口中某个方法的完整描述。如果某个 method_info 结构的 access_flags 项既没有设置 ACC_NATIVE 标志也没有设置 ACC_ABSTRACT 标志，那么该结构中也应包含实现这个方法所有的 Java 虚拟机指令。</li>
<li>method_info 结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法。</li>
<li>方法表的结构实际跟字段表是一样的，方法表结构如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">含义</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">访问标志</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">name_index</td>
<td align="center">方法名索引</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">descriptor_index</td>
<td align="center">描述符索引</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">属性计数器</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">属性集合</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<h5 id="方法表访问标志"><a href="#方法表访问标志" class="headerlink" title="方法表访问标志"></a>方法表访问标志</h5><p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下：</p>
<table>
<thead>
<tr>
<th align="center">标记名</th>
<th align="center">值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACC_PUBLIC</td>
<td align="center">0x0001</td>
<td align="center">public，方法可以从包外访问</td>
</tr>
<tr>
<td align="center">ACC_PRIVATE</td>
<td align="center">0x0002</td>
<td align="center">private，方法只能本类中访问</td>
</tr>
<tr>
<td align="center">ACC_PROTECTED</td>
<td align="center">0X0004</td>
<td align="center">protected，方法在自身和子类可以访问</td>
</tr>
<tr>
<td align="center">ACC_STATIC</td>
<td align="center">0x0008</td>
<td align="center">static，静态方法</td>
</tr>
</tbody></table>
<h3 id="属性表结合"><a href="#属性表结合" class="headerlink" title="属性表结合"></a>属性表结合</h3><p>方法表集合之后的属性表集合，<strong>指的是 Class 文件所携带的辅助信息</strong>，比如该 Class 文件的源文件的名称。以及任何带有 RetentionPolicy.CLASS 或者 RetentionPolicy.RUNTIME 的注解。这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试，<strong>一般无需深入了解</strong>。</p>
<p>此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。</p>
<p>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但 Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<h4 id="attributes-count（属性计数器）"><a href="#attributes-count（属性计数器）" class="headerlink" title="attributes_count（属性计数器）"></a>attributes_count（属性计数器）</h4><p>attributes_count 的值表示当前 Class 文件属性表的成员个数。属性表中每一项都是一个 attribute_info 结构。</p>
<h4 id="attributes-（属性表）"><a href="#attributes-（属性表）" class="headerlink" title="attributes[] （属性表）"></a>attributes[] （属性表）</h4><p>属性表的每个项的值必须是 attribute_info 结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。</p>
<h5 id="属性的通用格式"><a href="#属性的通用格式" class="headerlink" title="属性的通用格式"></a>属性的通用格式</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">attribute_name_index</td>
<td align="center">1</td>
<td align="center">属性名索引</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">attribute_length</td>
<td align="center">1</td>
<td align="center">属性长度</td>
</tr>
<tr>
<td align="center">u1</td>
<td align="center">info</td>
<td align="center">attribute_length</td>
<td align="center">属性表</td>
</tr>
</tbody></table>
<p>即只需说明属性的名称以及占用位数的长度即可，属性表具体的结构可以去自定义。</p>
<h5 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h5><p>属性表实际上可以有很多类型，上面看到的 Code 属性只是其中一种， Java 8 里面定义了 23 种属性。</p>
<p>下面这些是虚拟机中预定义的属性：</p>
<table>
<thead>
<tr>
<th align="center">属性名称</th>
<th align="center">使用位置</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Code</td>
<td align="center">方法表</td>
<td align="center">Java 代码编译成的字节码指令</td>
</tr>
<tr>
<td align="center">ConstantValue</td>
<td align="center">字段表</td>
<td align="center">final 关键字定义的常量池</td>
</tr>
<tr>
<td align="center">Deprecated</td>
<td align="center">类、方法、字段表</td>
<td align="center">被声明为 deprecated 的方法和字段</td>
</tr>
<tr>
<td align="center">Exceptions</td>
<td align="center">方法表</td>
<td align="center">方法抛出的异常</td>
</tr>
<tr>
<td align="center">EnclosingMethod</td>
<td align="center">类文件</td>
<td align="center">仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td>
</tr>
<tr>
<td align="center">InnerClass</td>
<td align="center">类文件</td>
<td align="center">内部类列表</td>
</tr>
<tr>
<td align="center">LineNumberTable</td>
<td align="center">Code 属性</td>
<td align="center">Java 源码的行号与字节码指令的对应关系</td>
</tr>
<tr>
<td align="center">LocalVariableTable</td>
<td align="center">Code 属性</td>
<td align="center">方法的局部变量描述</td>
</tr>
<tr>
<td align="center">StackMapTable</td>
<td align="center">Code 属性</td>
<td align="center">JDK 1.6 中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数所需要的类是否匹配</td>
</tr>
<tr>
<td align="center">Signature</td>
<td align="center">类、方法表、字段表</td>
<td align="center">用于支持泛型情况下的方法签名</td>
</tr>
<tr>
<td align="center">SourceFile</td>
<td align="center">类文件</td>
<td align="center">记录源文件名称</td>
</tr>
<tr>
<td align="center">SourceDebugExtension</td>
<td align="center">类文件</td>
<td align="center">用于存储额外的调试信息</td>
</tr>
<tr>
<td align="center">Synthetic</td>
<td align="center">类、方法表、字段表</td>
<td align="center">标志方法或字段为编译器自动生成的</td>
</tr>
<tr>
<td align="center">LocalVariableTypeTable</td>
<td align="center">类</td>
<td align="center">使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td>
</tr>
<tr>
<td align="center">RuntimeVisibleAnnotations</td>
<td align="center">类、方法表、字段表</td>
<td align="center">为动态注解提供支持</td>
</tr>
<tr>
<td align="center">RuntimeInvisibleAnnotations</td>
<td align="center">表、方法表、字段表</td>
<td align="center">用于指明哪些注解是运行时不可见的</td>
</tr>
<tr>
<td align="center">RuntimeVisibleParameterAnnotation</td>
<td align="center">方法表</td>
<td align="center">作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象为方法</td>
</tr>
<tr>
<td align="center">RuntimeInvisibleParameterAnnotation</td>
<td align="center">方法表</td>
<td align="center">作用与 RuntimeInvisibleAnnotations 属性类似，作用对象哪个为方法参数</td>
</tr>
<tr>
<td align="center">AnnotationDefault</td>
<td align="center">方法表</td>
<td align="center">用于记录注解类元素的默认值</td>
</tr>
<tr>
<td align="center">BootstrapMethods</td>
<td align="center">类文件</td>
<td align="center">用于保存 invokeddynamic 指令引用的引导方式限定符</td>
</tr>
</tbody></table>
<h5 id="部分属性详解"><a href="#部分属性详解" class="headerlink" title="部分属性详解"></a>部分属性详解</h5><ul>
<li>ConstantValue 属性</li>
</ul>
<p>ConstantValue 属性表示一个常量字段的值。位于 field_info 结构的属性表中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConstantValue_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 constantvalue_index; <span class="comment">//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。(例如，值是 long 型的，在常量池中便是 CONSTANT_Long)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Deprecated 属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deprecated_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Code 属性</li>
</ul>
<p>Code 属性就是存放方法体里面的代码，但是，并非所有方法表都有 Code 属性，像接口或者抽象方法，他们没有具体的方法体，因此也就不会有 Code 属性了。</p>
<p>Code 属性表的结构，如下：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">attribute_name_index</td>
<td align="center">1</td>
<td align="center">属性名索引</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">attribute_length</td>
<td align="center">1</td>
<td align="center">属性长度</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">max_stack</td>
<td align="center">1</td>
<td align="center">操作数栈深度的最大值</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">max_locals</td>
<td align="center">1</td>
<td align="center">局部变量表所需的存续空间</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">code_length</td>
<td align="center">1</td>
<td align="center">字节码指令的长度</td>
</tr>
<tr>
<td align="center">u1</td>
<td align="center">code</td>
<td align="center">code_length</td>
<td align="center">存储字节码指令</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">exception_table_length</td>
<td align="center">1</td>
<td align="center">异常表长度</td>
</tr>
<tr>
<td align="center">exception_info</td>
<td align="center">exception_table</td>
<td align="center">exception_length</td>
<td align="center">异常表</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
<td align="center">属性集合计数器</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
<td align="center">属性集合</td>
</tr>
</tbody></table>
<p>可以看到：Code 属性表的前两项跟属性表是一致的，即 Code 属性表遵循属性表的结构，后面那些则是他自定义的结构。</p>
<ul>
<li>InnerClasses 属性</li>
</ul>
<p>为了方便说明特别定义一个表示类或接口的 Class 格式为 C。如果 C 的常量池中包含某个 CONSTANT_Class_info 成员，且这个成员所表示的类或接口不属于任何一个包，那么 C 的 ClassFile 结构的属性表中就必须含有对应的 InnerClasses 属性。InnerClasses 属性是在 JDK 1.1 中为了支持内部类和内部接口而引入的，位于 ClassFile 结构的属性表。</p>
<ul>
<li>LineNumberTable 属性</li>
</ul>
<p>LineNumberTable 属性是可选变长属性，位于 Code 结构的属性表。</p>
<p>LineNumberTable 属性是<strong>用来描述 Java 源码行号与字节码行号之间的对应关系</strong>，这个属性可以用来在调试的时候定位代码执行的行数。</p>
<blockquote>
<p>start_pc，即字节码行号；line_number，即 Java 源代码行号</p>
</blockquote>
<p>在 Code 属性的属性表中，LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable 属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件的行一一对应。</p>
<p>LineNumberTable 属性表结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc;</span><br><span class="line">        u2 line_number;</span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>LocalVariableTable 属性</li>
</ul>
<p>LocalVariableTable 是可选变长属性，位于 Code 属性的属性表中。它被调试器<strong>用于确定方法在执行过程中局部变量的信息。</strong>在 Code 属性的属性中，LocalVariableTable 属性可以按照任意顺序出现。Code 属性中的每个局部变量最多只能有一个 LocalVariableTable 属性。</p>
<ol>
<li>start_pc + length 表示这个变量在字节码中的生命周期起始和结束的偏移位置（this 生命周期从头0到结尾10）</li>
<li>index 就是这个变量在局部变量表中的槽位（槽位可复用）</li>
<li>name 就是变量名称</li>
<li>Descriptor 表示局部变量类型描述</li>
</ol>
<p>LocalVariableTable 属性表结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc;</span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;</span><br><span class="line">        u2 descriptor_index;</span><br><span class="line">        u2 index;</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Signature 属性</li>
</ul>
<p>Signature 属性是可选的定长属性，位于 ClassFile，field_info 或 method_info 结构的属性表中。在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会为它记录泛型签名信息。</p>
<ul>
<li>SourceFile 属性</li>
</ul>
<p>SourceFile 属性结构</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">attribute_name_index</td>
<td align="center">1</td>
<td align="center">属性名索引</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">attribute_length</td>
<td align="center">1</td>
<td align="center">属性长度</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">sourcefile_index</td>
<td align="center">1</td>
<td align="center">源码文件索引</td>
</tr>
</tbody></table>
<p>可以看到，其长度总是固定的 8 个字节。</p>
<ul>
<li>其他属性</li>
</ul>
<p>Java 虚拟机中预定义的属性有 20 多个，这里就不一一介绍了，通过上面几个属性的介绍，只要领会其精髓，其他属性的解读也是易如反掌。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>通过手动去解读字节码文件，终于大概了解到其构成和原理了。</p>
<p>实际上，我们可以使用各种工具来帮我们去解读字节码文件，而不用直接去看这些 16 进制，太繁琐了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>本章主要介绍了 Class 文件的基本格式。</p>
<p>随着 Java 平台的不断发展，在将来，Class 文件的内容也一定会做进一步的扩充，但是其基本的格式和结构不会做重大调整。</p>
<p>从 Java 虚拟机的角度看，通过 Class 文件，可以让更多的计算机语言支持 Java 虚拟机平台。因此，Class 文件结构不仅仅是 Java 虚拟机的执行入口，更是 Java 生态圈的基础和核心。</p>
<h2 id="使用-javap-指令解析-Class-文件"><a href="#使用-javap-指令解析-Class-文件" class="headerlink" title="使用 javap 指令解析 Class 文件"></a>使用 javap 指令解析 Class 文件</h2><p>自己分析类文件结构太麻烦了！Oracle 提供了 javap 工具。</p>
<p>当然这些信息中，有些信息（如本地变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等等）需要在使用 javac 编译成 Class 文件时，指定参数才能输出，比如，你直接 javac xx.java，就不会再生成对应的局部变量表等信息，如果你使用 javac -g xx.java 就可以生成所有相关信息了。如果你使用的是 Eclipse，则默认情况下，Eclipse 在编译时会帮你生成局部变量表、指令和代码行盘一辆映射表等信息</p>
<p>通过反编译生成的汇编代码，我们可以深入的了解 Java 代码的工作机制。比如我们看到的 i++，这行代码实际运行时是先获取变量 i 的值，然后将这个值加 1，最后再将加 1 后的值赋值给变量 i。</p>
<h3 id="解析字节码的作用"><a href="#解析字节码的作用" class="headerlink" title="解析字节码的作用"></a>解析字节码的作用</h3><p>通过反编译生成的字节码文件，我们可以深入的了解 Java 代码的工作机制。但是，自己分析类文件结构太麻烦了，除了使用第三方的 jclasslib 工具之外，Oracle 官方也提供了工具：javap。</p>
<p>javap 是 JDK 自带的反解析工具。它的作用就是根据 Class 字节码文件，反解析出当前类对应的 Code 区（字节码指令）、局部变量表、异常表和代码行偏移量映射表、常量池等信息。</p>
<p>通过局部变量表，我们可以查看局部变量的作用域范围、所在槽位等信息，甚至可以看到槽位复用等信息。</p>
<h3 id="javac-g-操作"><a href="#javac-g-操作" class="headerlink" title="javac -g 操作"></a>javac -g 操作</h3><p>解析字节码文件得到的信息中，有些信息（如局部变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等等）需要在使用 javac 编译成 Class 文件时，指定参数才能输出。</p>
<p>比如，你直接 javac xx.java，就不会在生成对应的局部变量表等信息，如果你使用 javac -g xx.java 就可以生成所有相关信息了。如果你使用的 Eclipse 或 IDEA，则默认情况下，Eclipse、IDEA 在编译时会帮你生成局部变量表、指令和代码行偏移量映射表等信息。</p>
<h3 id="javap-的用法"><a href="#javap-的用法" class="headerlink" title="javap 的用法"></a>javap 的用法</h3><p>javap 的用法格式：javap <options> <classes></p>
<p>其中，classes 就是你要反编译的 Class 文件。</p>
<p>在命令行中直接输入 javap 或 javap -help 可以看到 javap 的 options 有如下选项：</p>
<p>![javap options.png](/images/java/jvm/javap options.png)</p>
<p>一般常用的是 -v -l -c 三个选项：</p>
<ul>
<li><p>javap -l 会输出行号和本地变量表信息</p>
</li>
<li><p>javap -c 会对当前 Class 字节码进行反编译生成汇编代码</p>
</li>
<li><p>javap -v classxx 除了包含 -c 内容外，还会输出行号、局部变量表信息、常量池等信息</p>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>通过 javap 命令可以查看一个 Java 类反汇编得到的 Class 文件版本号、常量池、访问标识、变量表、指令代码行号表等信息。不显式类索引、父类索引、接口索引集合、<clinit>()、<init>() 等结构。</li>
<li>通过对前面的例子代码反汇编文件的简单分析，可以发现，一个方法的执行通常会涉及下面几块内存的操作：<ol>
<li>Java 栈中：局部变量表、操作数栈</li>
<li>Java 堆： 通过对象的地址引用去操作</li>
<li>常量池</li>
<li>其他如帧数据区、方法区的剩余部分等情况，测试中没有显示出来，这里说明一下</li>
</ol>
</li>
<li>平常，我们比较关注的是 Java 类中每个方法的反汇编中的指令操作过程，这些指令都是顺序执行的，可以参考官方文档查看每个指令含义。</li>
</ol>
<h1 id="字节码指令集与解析举例"><a href="#字节码指令集与解析举例" class="headerlink" title="字节码指令集与解析举例"></a>字节码指令集与解析举例</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Java 字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行命令。</li>
<li>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为<strong>操作码，Opcode</strong>）以及跟随其后的零至多个代表此操作所需参数（称为<strong>操作数，Operands</strong>）而构成，由于 <strong>Java 虚拟机采用面向操作数栈而不是寄存器的结构</strong>，所以大多数的指令都不包含操作数，只有一个操作码。</li>
<li>由于限制了 Java 虚拟机操作码的长度为一个字节（即 0~255），这意味着指令集的操作码总数不可能超过 256 条。</li>
<li>官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html</a></li>
<li>熟悉虚拟机的指令对于动态字节码生成、反编译 Class 文件、 Class 文件修补都有着非常重要的价值。因此，阅读字节码作为了解 Java 虚拟机的基础技能，需要熟练掌握常见指令。</li>
</ul>
<h3 id="执行模型"><a href="#执行模型" class="headerlink" title="执行模型"></a>执行模型</h3><p>如果不考虑异常处理的话，那么 Java 虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    自动计算 PC 寄存器的值加 <span class="number">1</span>;</span><br><span class="line">    根据 PC 寄存器的指示位置，从字节码流中取出操作码;</span><br><span class="line">    <span class="keyword">if</span>(字节码存在操作数) 从字节码流中取出操作数;</span><br><span class="line">    执行操作码所定义的操作;</span><br><span class="line">&#125;<span class="keyword">while</span>(字节码长度 &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>在 Java 虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload 指令用于从局部变量表中加载 int 类型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据。</p>
<p>对于大部分与数据类型相关的字节码指令，<strong>它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：</strong></p>
<ul>
<li>i 代表对 int 类型的数据操作</li>
<li>l 代表 long</li>
<li>s 代表 short</li>
<li>b 代表 byte</li>
<li>c 代表 char</li>
<li>f 代表 float</li>
<li>d 代表 double</li>
</ul>
<p>也有一些指令的助记符中<strong>没有明确地指明操作类型的字母</strong>，如 arraylength 指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。</p>
<p>还有另一些指令，如无条件跳转指令 goto 则是与<strong>数据类型无关的</strong>。</p>
<p>大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。编译器会在编译器或运行期将 byte 和short 类型的数据带符号扩展（Sign-Extend）为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展（Zero-Extend）为相应的 int 类型数据。与之类似，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 init 类型的字节码指令来处理。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的 int 类型作为运算类型。</p>
<h3 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h3><p>由于完全介绍和学习这些指令需要花费大量时间，为了让大家能够更快地熟悉和了解这些基本指令，这里将 JVM 中的字节码指令集按用途大致分成 9 类：</p>
<ul>
<li>加载与存储指令</li>
<li>算术指令</li>
<li>类型转换指令</li>
<li>对象的创建与访问指令</li>
<li>方法调用与返回指令</li>
<li>操作数栈管理指令</li>
<li>比较控制指令</li>
<li>异常处理指令</li>
<li>同步控制指令</li>
</ul>
<p>在做值相关操作时：</p>
<ul>
<li>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用等中取得数据，这些数据（可能是值，可能是对象的引用）被压入操作数栈。</li>
<li>一个指令，也可以从操作数栈中取出一到多个值（pop 多次），完成赋值、加减乘除、方法传参、系统调用等操作。</li>
</ul>
<h2 id="加载与存储指令"><a href="#加载与存储指令" class="headerlink" title="加载与存储指令"></a>加载与存储指令</h2><ul>
<li>作用</li>
</ul>
<p>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递。</p>
<ul>
<li>常用指令<ul>
<li>「局部变量压栈指令」将一个局部变量加载到操作数栈：<code>xload、xload_&lt;n&gt;</code>(<code>其中 x 为 i、l、f、d、a，n 为 0 到 3</code>)；<code>xaload、xaload&lt;n&gt;</code>(<code>其 x 为 i、l、f、d、a、b、c、s，n 为 0 到 3</code>)</li>
<li>「常量入栈指令」将一个常量加载到操作数栈：<code>bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_&lt;i&gt;、iconst_&lt;l&gt;、fconst_&lt;f&gt;、dconst_&lt;d&gt;</code></li>
<li>「出栈装入局部变量表指令」将一个数值从操作数栈存储到局部变量表：<code>xstore、xstore_&lt;n&gt;</code>(<code>其中 x 为 i、l、f、d、a，n 为 0 到 3</code>); <code>xastore</code>(<code>其中 x 为 i、l、f、d、a、b、c、s</code>)</li>
<li>扩充局部变量表的访问索引的指令：<code>wide</code></li>
</ul>
</li>
</ul>
<p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如<code>iload_&lt;n&gt;</code>）。这些指令助记符实际上代表了一组指令（例如<code>iload_&lt;n&gt;</code>代表了<code>iload_0、iload_1、iload_2和iload_3</code>这几个指令）。这几组指令都是某个带有一个操作数的通用指令（例如 <code>iload</code>）的特殊形式，<strong>对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。</strong></p>
<p>除此之外，它们的语义与原生的通用指令完全一致（例如 <code>iload_0</code>的语义与操作数为 0 时的<code>iload</code>指令语义完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，<code>&lt;n&gt;</code>代表非负的整数，<code>&lt;i&gt;</code>代表是 int 类型数据，<code>&lt;l&gt;</code>代表 long 类型，<code>&lt;f&gt;</code>代表 float 类型，<code>&lt;d&gt;</code>代表 double 类型。</p>
<p>操作 byte、char、short 和 boolean 类型数据时，经常用 int 类型的指令来表示。</p>
<h3 id="复习：再谈操作数栈与局部变量表"><a href="#复习：再谈操作数栈与局部变量表" class="headerlink" title="复习：再谈操作数栈与局部变量表"></a>复习：再谈操作数栈与局部变量表</h3><ol>
<li><strong>操作数栈（Operand Stacks）</strong></li>
</ol>
<p>我们知道，Java 字节码是 Java 虚拟机所使用的指令集。因此，它与 Java 虚拟机基于栈的计算模型是密不可分的。</p>
<p>在解释执行过程中，每当为 Java 方法分配栈帧时，Java 虚拟机往往需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果。</p>
<p>具体来说便是：执行每一条指令之前，Java 虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java 虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。</p>
<p>以加法指令 iadd 为例。假设在执行该指令之前，栈顶的两个元素分别为 int 值 1 和 int 值 2，那么 iadd 指令将弹出这两个 int，并将求得的和 int 值为 3 压入栈中。</p>
<ol start="2">
<li><strong>局部变量表（Local Variables）</strong></li>
</ol>
<p>Java 方法栈帧的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。</p>
<p>实际上，Java 虚拟机将局部变量区当成一个数组，依次存放 this 指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。</p>
<p>和操作数栈一样，long 类型以及 double 类型的值将占据两个单元，其余类型仅占据一个单元。</p>
<p><img src="/images/java/jvm/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8.png" alt="局部变量表.png"></p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">long</span> l, <span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    String s = <span class="string">"Hello, World"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/java/jvm/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E4%B8%BE%E4%BE%8B.png" alt="局部变量表举例.png"></p>
<p>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<p>在方法执行时，虚拟机使用局部变量表完成方法的传递。</p>
<h3 id="局部变量压栈指令"><a href="#局部变量压栈指令" class="headerlink" title="局部变量压栈指令"></a>局部变量压栈指令</h3><p>局部变量压栈指令将给定的局部变量表中的数据压入操作数栈。</p>
<p>这类指令大体可以分为：</p>
<ul>
<li><code>xload_&lt;n&gt;</code>(<code>x</code>为<code>i、l、f、d、a，n为 0 到 3</code>)</li>
<li><code>xload</code>(<code>x</code>为<code>i、l、f、d、a</code>)</li>
</ul>
<p>说明：在这里，<code>x</code>的取值表示数据类型。</p>
<p>指令<code>xload_n</code>表示将第<code>n</code>个局部变量压入操作数栈，比如<code>iload_1、fload_0、aload_0</code>等指令，其中<code>aload_n</code>表示将一个对象引用压栈。</p>
<p>指令<code>xload</code>通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了 4 个，比如指令<code>iload、fload</code>等。</p>
<h3 id="常量入栈指令"><a href="#常量入栈指令" class="headerlink" title="常量入栈指令"></a>常量入栈指令</h3><p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为 const 系列、push 系列和 ldc 指令。</p>
<p><strong>指令 const 系列：</strong>用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有：<code>iconst_&lt;i&gt;（i 从 -1 到 5）、lconst_&lt;l&gt;（l 从 0 到 1）、fconst_&lt;f&gt;（f 从 0 到 2）、dconst_&lt;d&gt;（d 从 0 到 1）、aconst_null</code></p>
<p>比如：</p>
<ul>
<li>iconst_m1 将 -1 压入操作数栈</li>
<li>iconst_x（x 为 0 到 5）将 x 压入栈</li>
<li>lconst_0、lconst_1 分别将长整数 0 和 1 压入栈</li>
<li>fconst_0、fconst_1、fconst_2 分别将浮点数 0、1、2 压入栈</li>
<li>dconst_0 和 dconst_1 分别将 double 型 0 和 1 压入栈</li>
<li>aconst_null 将 null 压入操作数栈</li>
</ul>
<p>从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i 表示整数，l 表示长整型，f 表示浮点数，d 表示双精度浮点，习惯上用 a 表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。</p>
<p><strong>指令 push 系列：</strong>主要包括 bipush 和 sipush，它们的区别在于接受数据类型的不同，bipush 接收 8 位整数作为参数，sipush 接收 16 位整数，它们都将参数压入栈。</p>
<p><strong>指令 ldc 系列：</strong>如果以上指令都不能满足需求，那么可以使用万能的 ldc 指令，它可以接收一个 8 位的参数，该参数指向常量池中的 int、float 或者 String 的索引，将指定的内容压入堆栈。</p>
<p>类似的还有 ldc_w，它接收两个 8 位参数，能支持的索引范围大于 ldc。</p>
<p>如果要压入的元素是 long 或者 double 类型的，则使用 ldc2_w 指令，使用方式都是类似的。</p>
<p>总结如下：</p>
<p><img src="/images/java/jvm/%E5%B8%B8%E9%87%8F%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93.png" alt="常量入栈指令总结.png"></p>
<h3 id="出栈装入局部变量表指令"><a href="#出栈装入局部变量表指令" class="headerlink" title="出栈装入局部变量表指令"></a>出栈装入局部变量表指令</h3><p>出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。</p>
<p>这类指令主要以 store 的形式存在，比如 xstore （x 为 i、l、f、d、a）、xstore_n（x 为 i、l、f、d、a，n 为 0 至 3）和 pasture（x 为 i、l、f、d、a、b、c、s）。</p>
<ul>
<li>其中，指令 istore_n 将从操作数栈中弹出一个整数，并把它赋值给局部变量 n。</li>
<li>指令 xstore 由于没有隐含参数信息，故需要提供一个 byte 类型的参数类指定目标局部变量表的位置。</li>
<li>xastore 则专门针对数组操作，以 iastore 为例，它用于给一个 int 数组的给定索引赋值。在 iastore 执行前，操作数栈顶需要以此准备 3 个元素：值、索引、数组引用，iastore 会弹出这 3 个值，并将值赋给数组中指定索引的位置。</li>
</ul>
<p>一般说来，类似像 store 这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是，为了尽可能压缩指令大小，使用专门的 istore_1 指令表示将弹出的元素放置在局部变量表第 1 个位置。类似的还有 istore_0、istore_2、istore_3，它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第 0、2、3 个位置。</p>
<p>由于局部变量表前几个位置总是非常常用，因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积。如果局部变量表很大，需要存储的槽位大于 3，那么可以使用 istore 指令，外加一个参数，用来表示需要存放的槽位位置。</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B2-%E5%87%BA%E6%A0%88%E8%A3%85%E5%85%A5%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E6%8C%87%E4%BB%A4.png" alt="字节码指令执行流程2-出栈装入局部变量表指令.png"></p>
<h2 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h2><ol>
<li><strong>作用</strong></li>
</ol>
<ul>
<li>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。</li>
</ul>
<ol start="2">
<li><strong>分类</strong></li>
</ol>
<ul>
<li>大体上算术指令可以分为两种：对<strong>整型数据</strong>进行运算的指令与对<strong>浮点型类型数据</strong>进行运算的指令。</li>
</ul>
<ol start="3">
<li><strong>byte、short、char 和 boolean 类型说明</strong></li>
</ol>
<ul>
<li>在每一大类中，都有针对 Java 虚拟机具体数据类型的专用算术指令。但没有直接支持 byte、short、char 和 boolean 类型的算术指令，对于这些数据的运算，都使用 int 类型的指令来处理。此外，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 int 类型的字节码指令来处理。</li>
</ul>
<p><img src="/images/java/jvm/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97%E7%B1%BB%E5%9E%8B.png" alt="Java虚拟机中的实际类型与运算类型.png"></p>
<ol start="4">
<li><strong>运算时的溢出</strong></li>
</ol>
<ul>
<li>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实 Java 虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为 0 时会导致虚拟机抛出异常 ArithmeticException。</li>
</ul>
<ol start="5">
<li><strong>运算模式</strong></li>
</ol>
<ul>
<li>向最接近数舍入模式：JVM 要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的。</li>
<li>向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果。</li>
</ul>
<ol start="6">
<li><strong>NaN 值使用</strong></li>
</ol>
<ul>
<li>当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用 NaN 值来表示。而且所有使用 NaN 值作为操作数的算术操作，结果都会返回 NaN。</li>
</ul>
<h3 id="所有算数指令"><a href="#所有算数指令" class="headerlink" title="所有算数指令"></a>所有算数指令</h3><p>所有算术指令包括：</p>
<ul>
<li>加法指令：iadd、ladd、fadd、dadd</li>
<li>减法指令：isub、lsub、fsub、dsub</li>
<li>乘法指令：imul、lmul、fmul、dmul</li>
<li>除法指令：idiv、ldiv、fdiv、ddiv</li>
<li>求余指令：irem、lrem、frem、drem（remainder：余数）</li>
<li>取反指令：ineg、lneg、fneg、dneg（negation：取反）</li>
<li>自增指令：iinc</li>
<li>位运算指令，又可分为：<ul>
<li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li>
<li>按位或指令：ior、lor</li>
<li>按位与指令：iand、land</li>
<li>按位异或指令：ixor、lxor</li>
</ul>
</li>
<li>比较指令：dcmpg、dcmlp、fcmpg、fcmpl、lcmp</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((i + <span class="number">1</span>) - <span class="number">2</span>) * <span class="number">3</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令对应的图示：</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4-%E7%AE%97%E6%95%B0%E6%8C%87%E4%BB%A4%E7%A4%BA%E4%BE%8B.png" alt="字节码指令-算数指令示例.png"></p>
<h3 id="比较指令的说明"><a href="#比较指令的说明" class="headerlink" title="比较指令的说明"></a>比较指令的说明</h3><ul>
<li>比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈</li>
<li>比较指令有：dcmpg、dcmpl、fcmpg、fcmpl、lcmp<ul>
<li>与前面讲解的指令类似，首字符 d 表示 double 类型，f 表示 float，l 表示 long</li>
</ul>
</li>
<li>对于 double 和 float 类型的数字，由于 NaN 的存在，各有两个版本的比较指令，以 float 为例，有 fcmpg 和 fcmpl 两个指令，它们的区别在于在数字比较时，若遇到 NaN 值，处理结果不同</li>
<li>指令 dcmpl 和 dcmpg 也是类似的，根据其命名可以推测其含义，在此不再赘述</li>
<li>指令 lcmp 针对 long 型整数，由于 long 型整数没有 NaN 值，故无需准备两套指令</li>
</ul>
<p>举例：</p>
<p>指令 fcmpg 和 fcmpl 都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为 v2， 栈顶顺位第 2 位元素为 v1，若 v1 = v2，则压入 0；若 v1 &gt;  v2 则压入 1；若 v1 &lt; v2 则压入 -1。</p>
<p>两个指令的不同之处在于，如果遇到 NaN 值，fcmpg 会压入 1，而 fcmpl 会压入 -1。</p>
<blockquote>
<p>  数值类型的数据才可以谈大小，boolean、引用数据类型不能比较大小。</p>
</blockquote>
<h2 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h2><p>类型转换指令说明：</p>
<ol>
<li>类型转换指令可以将两种不同的数值类型进行相互转换。</li>
<li>这些转换操作一般用于实现用户代码中的<strong>显式类型转换操作</strong>，或者用来处理<strong>字节码指令集中数据类型相关指令</strong>无法与<strong>数据类型</strong>一一对应的问题。</li>
</ol>
<h3 id="宽化类型转换（Widening-Numeric-Conversions）"><a href="#宽化类型转换（Widening-Numeric-Conversions）" class="headerlink" title="宽化类型转换（Widening Numeric Conversions）"></a>宽化类型转换（Widening Numeric Conversions）</h3><ol>
<li><strong>转换规则</strong></li>
</ol>
<p>Java 虚拟机直接支持以下数值的宽化类型转换（Widening Numeric Conversion，小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行，包括：</p>
<ul>
<li>从 int 类型到 long、float 或者 double 类型，对应的指令为：i2l、i2f、i2d</li>
<li>从 long 类型到 float、double 类型。对应的指令为：l2f、l2d</li>
<li>从 flaot 类型到 double 类型。对应的指令为：f2d</li>
</ul>
<p>简化为：int –&gt; long –&gt; float –&gt; double</p>
<ol start="2">
<li><strong>精度损失问题</strong><ol>
<li>宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从 int 转换到 long，或者从 int 转换到 double，都不会丢失任何信息，转换前后的值是精确相等的。</li>
<li>从 int、long 类型数值转换到 float，或者 long 类型树脂转换到 double 时，将可能发生丢失精度——可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据 IEEE754 最接近舍入模式所得到的正确整数数值。尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致 Java 虚拟机抛出运行时异常。</li>
<li><strong>从 byte、char 和 short 类型到 int 类型的宽化类型转换实际上是不存在的</strong>，对于 byte 类型转换为 int，虚拟机并没有做实质性的转化处理，知识简单地通过操作数栈交换了两个数据。而 byte 转为 long 时，使用的是 i2l，可以看到在内部 byte 在这里已经等同于 int 类型处理，类似的还有 short 类型，这种处理方式有两个特点：<ol>
<li>一方面可以减少实际的数据类型，如果为 short 和 byte 都准备一套指令，那么指令的数量就会大增，而<strong>虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过 256 个，为了节省指令资源，将 short 和 byte 当作 int 处理也是情理之中。</strong></li>
<li>另一方面，由于局部变量表中的槽位固定为 32 位，无论是 byte 或者 short 存入局部变量表，都会占用 32 位空间。从这个角度来说，也没有必要特意区分这几种数据类型。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="窄化类型转换（Narrowing-Numeric-Conversion）"><a href="#窄化类型转换（Narrowing-Numeric-Conversion）" class="headerlink" title="窄化类型转换（Narrowing Numeric Conversion）"></a>窄化类型转换（Narrowing Numeric Conversion）</h3><ol>
<li>转换规则</li>
</ol>
<p>Java 虚拟机也直接支持以下窄化类型转换：</p>
<ul>
<li>从 int 类型至 byte、short 或者 char 类型。对应的指令有：i2b、i2c、i2s</li>
<li>从 long 类型到 int 类型。对应的指令有：l2i</li>
<li>从 float 类型到 int 或者 long 类型。对应的指令有：f2i、f2l</li>
<li>从 double 类型到 int、long 或者 float 类型。对应的指令有：d2i、d2l、d2f</li>
</ul>
<ol start="2">
<li>精度损失问题</li>
</ol>
<p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会<strong>导致数值丢失精度。</strong></p>
<p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是 Java 虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。</p>
<ol start="3">
<li><p>补充说明</p>
<ol>
<li>当一个浮点值窄化转换为整数类型 T（T 限于 int 或 long 类型之一）的时候，将遵循以下转换规则：<ol>
<li>如果浮点值是 NaN，那转换结果就是 int 或 long 类型的 0。</li>
<li>如果浮点值不是无穷大的话，浮点值使用 IEEE754 的向零舍入模式取整，获得整数值 v，如果 v 在目标类型 T（int 或 long）的表示范围之内，那转换结果就是 v。否则，将根据 v 的符号，转换为 T 所能表示的最大或者最小正数。</li>
</ol>
</li>
<li>当一个 double 类型窄化转换为 float 类型时，将遵循以下转换规则：</li>
</ol>
<p>通过向最接近数舍入模式舍入一个可以使用 float 类型表示的数字。最后结果根据下面这 3 条规则判断：</p>
<ul>
<li>如果转换结果的绝对值太小而无法使用 float 来表示，将返回 float 类型的正负零。</li>
<li>如果转换结果的绝对值太大而无法使用 float 来表示，将返回 float 类型的正负无穷大。</li>
<li>对于 double 类型的 NaN 值将按规定转换为 float 类型的 NaN 值。</li>
</ul>
</li>
</ol>
<h2 id="对象的创建与访问指令"><a href="#对象的创建与访问指令" class="headerlink" title="对象的创建与访问指令"></a>对象的创建与访问指令</h2><p>Java 是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令和类型检查指令。</p>
<h3 id="创建指令"><a href="#创建指令" class="headerlink" title="创建指令"></a>创建指令</h3><p>虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令</p>
<ol>
<li><strong>创建类实例的指令：</strong></li>
</ol>
<p>创建类实例的指令：new</p>
<ul>
<li>它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈。</li>
</ul>
<ol start="2">
<li><strong>创建数组的指令：</strong></li>
</ol>
<p>创建数组的指令：newarray、anewarray、multianewarray</p>
<ul>
<li>newarray：创建基本类型数组</li>
<li>anewarray：创建引用类型数组</li>
<li>multianewarray：创建多维数组</li>
</ul>
<p>上述创建指令可以用于创建对象或者数组，由于对象和数组在 Java 中的广泛使用，这些指令的使用频率也很高。</p>
<h3 id="字段访问指令"><a href="#字段访问指令" class="headerlink" title="字段访问指令"></a>字段访问指令</h3><p>对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。</p>
<ul>
<li>访问类字段（static 字段，或者称为类变量）的指令：getstatic、putstatic</li>
<li>访问类实例字段（非 static 字段，或者称为实例变量）的指令：getfield、putfield</li>
</ul>
<p>举例：</p>
<p>以 getstatic 指令为例，它含有一个操作数，为指向常量池的 Fieldref 索引，它的作用就是获取 Fieldref 指定的对象或者值，并将其压入操作数栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 getstatic #8 &lt;java&#x2F;lang&#x2F;System.out&gt;</span><br><span class="line">3 ldc #9 &lt;Hello&gt;</span><br><span class="line">5 invokevirtual #10 &lt;java&#x2F;io&#x2F;PrintStream.println&gt;</span><br><span class="line">8 return</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4%E7%A4%BA%E4%BE%8B1.png" alt="字节码指令-对象创建与访问指令示例1.png"></p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4%E7%A4%BA%E4%BE%8B2.png" alt="字节码指令-对象创建与访问指令示例2.png"></p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4%E7%A4%BA%E4%BE%8B3.png" alt="字节码指令-对象创建与访问指令示例3.png"></p>
<h3 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h3><p>数组操作指令主要有：xastore 和 xaload 指令。具体为：</p>
<ul>
<li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload</li>
<li>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore</li>
</ul>
<p>即：</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4.png" alt="字节码指令-数组操作指令.png"></p>
<ul>
<li>取数组长度的指令：arraylength<ul>
<li>该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈</li>
</ul>
</li>
</ul>
<p>说明：</p>
<ul>
<li>指令 xaload 表示将数组的元素压栈，比如 saload、caload 分别表示压入 short 数组和 char 数组。指令 xaload 在执行时，要求操作数中栈顶元素为数组索引 i，栈顶顺位第 2 个元素为数组引用 a，该指令会弹出栈顶这两个元素，并将 a[i] 重新压入堆栈。</li>
<li>xastore 则专门针对数组操作，以 iastore 为例，它用于给一个 int 数组的给定索引赋值。在 iastore 执行前，操作数栈顶需要以此准备 3 个元素：值、索引、数组饮用，iastore 会弹出这 3 个值，并将值赋给数组中指定索引的位置。</li>
</ul>
<h3 id="类型检查指令"><a href="#类型检查指令" class="headerlink" title="类型检查指令"></a>类型检查指令</h3><p>检查类实例或数组类型的指令：instanceof、checkcast</p>
<ul>
<li>指令 checkcast 用于检查类型强制转换是否可以进行。如果可以进行，那么 checkcast 指令不会改变操作数栈，否则它会抛出 ClassCastException 异常。</li>
<li>指令 instanceof 用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈。</li>
</ul>
<h2 id="方法调用与返回指令"><a href="#方法调用与返回指令" class="headerlink" title="方法调用与返回指令"></a>方法调用与返回指令</h2><h3 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h3><p>方法调用指令：invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic</p>
<p>以下 5 条指令用于方法调用：</p>
<ul>
<li>invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是 Java 语言中<strong>最常见的方法分派方式。</strong></li>
<li>invokeinterface 指令用于<strong>调用接口方法</strong>，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。</li>
<li>invokespecial 指令用于调用一些需要特殊处理的实例方法，包括<strong>实例初始化方法（构造器）、私有方法和父类方法</strong>。这些方法都是<strong>静态类型绑定</strong>的，不会在调用时进行动态派发。</li>
<li>invokestatic 指令用于调用命名<strong>类中的类方法（static 方法）</strong>，这是<strong>静态绑定</strong>的。</li>
<li>invokedynamic 调用动态绑定的方法，这个是 JDK 1.7 后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面 4 条调用指令的分派逻辑都固化在 Java 虚拟机内部，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<h3 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h3><p>方法调用结束前，需要进行返回。方法返回指令是<strong>根据返回值的类型区分</strong>的。</p>
<ul>
<li>包括 ireturn（当返回值是 boolean、byte、char、short 和 int 类型时使用）、lreturn、freturn、dreturn 和 areturn。</li>
<li>另外还有一条 return 指令供声明为 void 的方法、实例初始化方法以及类和接口的类初始化方法使用。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">返回类型</th>
<th align="center">返回指令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void</td>
<td align="center">return</td>
</tr>
<tr>
<td align="center">Int(boolean、byte、char、short)</td>
<td align="center">ireturn</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">lreturn</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">freturn</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">dreturn</td>
</tr>
<tr>
<td align="center">reference</td>
<td align="center">Return</td>
</tr>
</tbody></table>
<p>举例：</p>
<p>通过 ireturn 指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃。</p>
<p>如果当前返回的是 synchronized 方法，那么还会执行一个隐含的 monitorexit 指令，退出临界区。</p>
<p>最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。</p>
<h2 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h2><p>如同操作一个普通数据结构中的堆栈那样，JVM 提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。</p>
<p>这类指令包括如下内容：</p>
<ul>
<li>将一个或两个元素从栈顶弹出，并且直接废弃：pop、pop2</li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、du p_x2、dup2_x2</li>
<li>将栈最顶端的两个 Slot 数值位置交换：swap、Java 虚拟机没有提供交换两个 64 位数据类型（long、double）数值的指令</li>
<li>指令 nop 是一个非常特殊的指令，它的字节码为 0x00。和汇编语言中的 nop 一样，它表示什么都不做，这条指令一般可用于调试、占位等</li>
</ul>
<p>这些指令属于通用型，对栈的压入或者弹出无需知名数据类型。</p>
<p>说明：</p>
<ul>
<li>不带 _x 的指令是复制栈顶数据并压入栈顶。包括两个指令，dup 和 dup2，dup 的系数代表要复制的 Slot 个数<ul>
<li>dup 开头的指令用于复制 1 个 Slot 的数据。例如 1 个 int 或 1 个 reference 类型数据</li>
<li>dup2 开头的指令用于复制 2 个 Slot 的数据。例如 1 个 long，或 2 个 int，或 1 个 int 加 1 个 float 类型数据</li>
</ul>
</li>
<li>带 _x 的指令是复制栈顶数据并插入栈顶以下的某个位置。共有 4 个指令，dup_x1、dup2_x1、dup_x2、dup2_x2。对于带 _x 的复制插入指令，只要将指令的 dup 和 x 的系数相加，结果即为需要插入的位置。因此<ul>
<li>dup_x1 插入位置：1+1=2，即栈顶 2 个 Slot 下面</li>
<li>dup_x2 插入位置：1+2=3，即栈顶 3 个 Slot 下面</li>
<li>dup2_x1 插入位置：2+1=3，即栈顶 3 个 Slot 下面</li>
<li>dup2_x2 插入位置：2+2=4，即栈顶 4 个 Slot 下面</li>
</ul>
</li>
<li>pop：将栈顶的 1 个 Slot 数值出栈。例如 1 个 short 类型数值</li>
<li>pop2：将栈顶的 2 个 Slot 数值出栈。例如 1 个 double 类型数值，或者 2 个 int 类型数值</li>
</ul>
<h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><p>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为比较指令、条件跳转指令、比较条件跳转指令、多条件分支跳转指令、无条件跳转指令等。</p>
<h3 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h3><p>条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。</p>
<p>条件跳转指令有：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull。这些指令都接收两个字节的操作数，用于计算跳转的位置（16 位符号整数作为当前位置的 offset）。</p>
<p>它们的统一含义为：<strong>弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置</strong>。</p>
<p><strong>具体说明：</strong></p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4-%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4.png" alt="字节码指令-条件跳转指令.png"></p>
<p><strong>注意：</strong></p>
<ol>
<li>与前面运算规则一致</li>
</ol>
<ul>
<li>对于 boolean、byte、char、short 类型的条件分支比较操作，都是使用 int 类型的比较指令完成。</li>
<li>对于 long、float、double 类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转。</li>
</ul>
<ol start="2">
<li>由于各类型的比较最终都会转为 int 类型的比较操作，所以 Java 虚拟机提供的 int 类型的条件分支指令是最为丰富和强大的。</li>
</ol>
<h3 id="比较条件跳转指令"><a href="#比较条件跳转指令" class="headerlink" title="比较条件跳转指令"></a>比较条件跳转指令</h3><p>比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。</p>
<p>这类指令有：if_icmped、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmped 和 if_acmpne</p>
<p>其中指令助记符加上 “if_” 后，以字符 “i” 开头的指令针对 int 型整数操作（也包括 short 和 byte 类型），以字符 “a” 开头的指令表示对象引用的比较。</p>
<p><strong>具体说明：</strong></p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4-%E6%AF%94%E8%BE%83%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4.png" alt="字节码指令-比较条件跳转指令.png"></p>
<p>这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入栈。<strong>如果预设条件成立，则执行跳转，否则，继续执行下一条语句。</strong></p>
<h3 id="多条件分支跳转"><a href="#多条件分支跳转" class="headerlink" title="多条件分支跳转"></a>多条件分支跳转</h3><p>多条件分支跳转指令是专为 switch-case 语句设计的，主要有 tableswitch 和 lookupswitch。</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4-%E6%97%A0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4.png" alt="字节码指令-无条件分支跳转指令.png"></p>
<p>从助记符上看，两者都是 switch 语句的实现，它们的区别：</p>
<ul>
<li>tableswitch 要求<strong>多个条件分支值是连续的</strong>，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数 index，可以立即定位到跳转偏移量位置，<strong>因此效率比较高。</strong></li>
<li>lookupswitch 内部<strong>存放着各个离散的 case-offset 对</strong>，每次执行都要搜索全部的 case-offset 对，找到匹配的 case 值，并根据对应的 offset 计算跳转地址，<strong>因此效率较低。</strong></li>
</ul>
<p>指令 tableswitch 的示意图如下图所示。由于 tableswitch 的 case 值是连续的，因此只需要记录最低值和最高值，以及每一项对应的 offset 偏移量，根据给定的 index 值通过简单的计算即可直接定位到 offset。</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4-tableswitch%E5%9B%BE%E7%A4%BA.png" alt="字节码指令-tableswitch图示.png"></p>
<p>指令 lookupswitch 处理的是离散的 case 值，但是出于效率考虑，将 case-offset 对按照 case 值大小排序，给定 index 时，需要查找与 index 相等的 case，获得其 offset，如果找不到则跳转到 default。指令 lookupswitch 如下图所示</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4-lookupswitch%E5%9B%BE%E7%A4%BA.png" alt="字节码指令-lookupswitch图示.png"></p>
<h3 id="无条件跳转"><a href="#无条件跳转" class="headerlink" title="无条件跳转"></a>无条件跳转</h3><p>目前主要的无条件跳转指令为 goto，指令 goto 接收两个字节的操作数，共同组成一个带符号的整数，<strong>用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处。</strong></p>
<p>如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令 goto_w，它和 goto 有相同的作用，但是它接收 4 个字节的操作数，可以表示更大的地址范围。</p>
<p>指令 jsr、jsr_w、ret 虽然也是无条件跳转的，但主要用于 try-finally 语句，且已经被虚拟机逐渐废弃，故不在这里介绍这两个指令。</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4-%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC.png" alt="字节码指令-无条件跳转.png"></p>
<h2 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h2><h3 id="抛出异常指令"><a href="#抛出异常指令" class="headerlink" title="抛出异常指令"></a>抛出异常指令</h3><ol>
<li>athrow 指令</li>
</ol>
<p>在 Java 程序中显式抛出异常的操作（throw 语句）都是由 athrow 指令来实现的。</p>
<p>除了使用 throw 语句显式抛出异常情况之外，<strong>JVM 规范还规定了许多运行时一场会在其它 Java 虚拟机指令检测到异常状况时自动抛出</strong>。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 idiv 或 ldiv 指令中抛出 ArithmeticException 异常。</p>
<ol start="2">
<li>注意</li>
</ol>
<p>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是<strong>在抛异常时，Java 虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上</strong></p>
<p>异常及异常的处理：</p>
<p>过程一：异常对象的生成过程 —&gt; throw(手动/自动) —&gt; 指令：athrow</p>
<p>过程二：异常的处理：抓抛模型 try-catch-finally —&gt; 使用异常表</p>
<h3 id="异常处理与异常表"><a href="#异常处理与异常表" class="headerlink" title="异常处理与异常表"></a>异常处理与异常表</h3><ol>
<li>处理异常</li>
</ol>
<p>在 Java 虚拟机中，处理异常（catch 语句）不是由字节码指令来实现的（早期使用 jsr、ret 指令），而是<strong>采用异常表来完成的。</strong></p>
<ol start="2">
<li>异常表</li>
</ol>
<p>如果一个方法定义了一个 try-catch 或者 try-finally 的异常处理，就会创建一个异常表。它包含了每个异常处理或者 finally 块的信息。异常表保存了每个异常处理信息。比如：</p>
<ul>
<li>起始位置</li>
<li>结束位置</li>
<li>程序计数器记录的代码处理的偏移地址</li>
<li>被捕获的异常类在常量池中的索引</li>
</ul>
<p><strong>当一个异常被抛出时，JVM 会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，</strong>并且异常会重新抛给上层调用的方法(在调用方法栈帧)。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个县城将终止。如果这个异常在最后一个非守护线程里抛出，将会导致 JVM 自己终止，比如这个线程是个 main 线程。</p>
<p><strong>不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。</strong>在这种情况下， 如果方法结束后没有抛出异常，仍然执行 finally 块，在 return 前，它直接跳到 finally 块来完成目标。</p>
<h2 id="同步控制指令"><a href="#同步控制指令" class="headerlink" title="同步控制指令"></a>同步控制指令</h2><p>Java 虚拟机支持两种同步结构：<strong>方法级同步</strong> 和 <strong>方法内部一段指令序列的同步</strong>，这两种同步都是使用 monitor 来支持的。</p>
<h3 id="方法级的同步"><a href="#方法级的同步" class="headerlink" title="方法级的同步"></a>方法级的同步</h3><p>方法级的同步：是隐式的，即无需通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否声明为同步方法。</p>
<p>当调用方法时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否设置。</p>
<ul>
<li>如果设置了，执行线程将先持有同步锁，然后执行方法，最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁</li>
<li>在方法执行期间，执行线程持有了同步锁，其它任何线程都无法再获得同一个锁</li>
<li>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 aload_0</span><br><span class="line">1 dup</span><br><span class="line">2 getdield #2 &lt;com&#x2F;atguigu&#x2F;java1&#x2F;SynchronizedTest.i&gt;</span><br><span class="line">5 iconst_1</span><br><span class="line">6 iadd</span><br><span class="line">7 putfield #2 &lt;com&#x2F;atguigu&#x2F;java1&#x2F;SynchronizedTest.i&gt;</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>这段代码和普通的无同步操作的代码没有什么不同，没有使用 monitorenter 和 monitorexit 进行同步区控制。这是因为，对于同步方法而言，当虚拟机通过方法的访问标识符判断是一个同步方法时，会自动在方法调用前进行加锁，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。因此，对于同步方法而言，monitorenter 和 monitorexit 指令是隐式存在的，并未直接出现在字节码中。</p>
<h3 id="方法内指定指令序列的同步"><a href="#方法内指定指令序列的同步" class="headerlink" title="方法内指定指令序列的同步"></a>方法内指定指令序列的同步</h3><p>同步一段指令集序列：通常是由 Java 中的 synchronized 语句块来表示的。JVM 的指令集有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义。</p>
<p>当一个线程进入同步代码块时，它使用 monitorenter 指令请求进入。如果当前对象的监视器计数器为 0，则它会被准许进入，若为 1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为 0，才会被允许进入同步块。</p>
<p>当线程退出同步块时，需要使用 monitorexit 声明退出。在 Java 虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</p>
<p>指令 monitorenter 和 monitorexit 在执行时，都需要在操作数栈顶压入对象，之后 monitorenter 和 monitorexit 的锁定和释放都是针对这个对象的监视器进行的。</p>
<p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都必须执行其对应的 monitorexit 指令，而无论这个方法是正常结束还是异常结束。</p>
<p>为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，<strong>编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常</strong>，它的目的就是用来执行 monitorexit 指令。</p>
<h1 id="类的加载过程详解"><a href="#类的加载过程详解" class="headerlink" title="类的加载过程详解"></a>类的加载过程详解</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>在 Java 中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</p>
<p>按照 Java 虚拟机规范，从 Class 文件到加载到内存中的类，到类卸载出内存位置，它的整个生命周期包括如下七个阶段：</p>
<p><img src="/images/java/jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E6%96%B0%EF%BC%89.png" alt="类的加载过程（新）.png"></p>
<p>其中，验证、准备、解析3个部分统称为链接（Linking）。</p>
<h3 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><p>蚂蚁金服：</p>
<p>描述一下 JVM 加载 Class 文件的原理机制？</p>
<p>一面：类加载过程</p>
<p>百度：</p>
<p>类加载的机制</p>
<p>Java 类加载过程？</p>
<p>简述 Java 类加载机制？</p>
<p>腾讯：</p>
<p>JVM 中类加载机制，类加载过程？</p>
<p>滴滴：</p>
<p>JVM 类加载机制</p>
<p>美团：</p>
<p>Java 类加载过程</p>
<p>描述一下 JVM 加载 Class 文件的原理机制</p>
<h2 id="过程一：Loading（加载）阶段"><a href="#过程一：Loading（加载）阶段" class="headerlink" title="过程一：Loading（加载）阶段"></a>过程一：Loading（加载）阶段</h2><h3 id="加载完成的操作"><a href="#加载完成的操作" class="headerlink" title="加载完成的操作"></a>加载完成的操作</h3><h4 id="加载的理解"><a href="#加载的理解" class="headerlink" title="加载的理解"></a>加载的理解</h4><p><strong>所谓加载，简而言之就是将 Java 类的字节码文件加载到机器内存中，并在内存中构建出 Java 类的原型——类模板对象。</strong>所谓类模板对象，其实就是 Java 类在 JVM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到模板中，这样 JVM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用。</p>
<p>反射的机制即基于这一基础。如果 JVM 没有将 Java 类的声明信息存储起来，则 JVM 在运行期也无法反射。</p>
<h4 id="加载完成的操作-1"><a href="#加载完成的操作-1" class="headerlink" title="加载完成的操作"></a>加载完成的操作</h4><p><strong>加载阶段，简言之，查找并加载类的二进制数据，生成 Class 的实例。</strong></p>
<p>在加载类时，Java 虚拟机必须完成以下 3 件事情：</p>
<ul>
<li>通过类的全名，获取类的二进制数据流；</li>
<li>解析类的二进制数据流为方法区内的数据结构（Java 类模型）；</li>
<li>创建 java.lang.Class 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h3 id="二进制流的获取方式"><a href="#二进制流的获取方式" class="headerlink" title="二进制流的获取方式"></a>二进制流的获取方式</h3><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（只要所读取的字节码符合 JVM 规范即可）</p>
<ul>
<li>虚拟机可能通过文件系统读入一个 Class 后缀的文件（最常见）</li>
<li>读入 jar、zip 等归档数据包，提取类文件</li>
<li>事先存放在数据库中的类的二进制数据</li>
<li>使用类似于 HTTP 之类的协议通过网络进行加载</li>
<li>在运行时生成一段 Class 的二进制信息等</li>
</ul>
<p>在获取到类的二进制信息后，Java 虚拟机就会处理这些数据，并最终转为一个 java.lang.Class 的实例。</p>
<p>如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p>
<h3 id="类模型与-Class-实例的位置"><a href="#类模型与-Class-实例的位置" class="headerlink" title="类模型与 Class 实例的位置"></a>类模型与 Class 实例的位置</h3><ol>
<li><strong>类模型的位置</strong></li>
</ol>
<p>加载的类在 JVM 中创建相应的类结构，类结构会存储在方法区（JDK 1.8之前：永久代；JDK 1.8之后：元空间）。</p>
<ol start="2">
<li><strong>Class 实例的位置</strong></li>
</ol>
<p>类将 .class 文件加载至元空间后，会在堆中创建一个 java.lang.Class 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象。</p>
<ol start="3">
<li><strong>图示</strong></li>
</ol>
<p>![类模型与 Class 实例的位置.png](/images/java/jvm/类模型与 Class 实例的位置.png)</p>
<p>外部可以通过访问代表 Order 类的 Class 对象来获取 Order 的类数据结构。</p>
<ol start="4">
<li><strong>再说明</strong></li>
</ol>
<p>Class 类的构造方法是私有的，只有 JVM 能够创建。</p>
<p>java.lang.Class 实例是访问类型元数据的接口，也是实现反射的关键数据、入口。通过 Class 类提供的接口，可以获得目标类所关联的 .class 文件中具体的数据结构：方法、字段等信息。</p>
<h3 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h3><p>创建数组类的情况稍微有些特殊，因为<strong>数组类本身并不是由类加载器负责创建</strong>，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称 A）的过程：</p>
<ol>
<li>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组 A 的元素类型。</li>
<li>JVM 使用指定的元素类型和数组唯独来创建新的数组类。</li>
</ol>
<p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为 public。</p>
<h2 id="过程二：Linking（链接）阶段"><a href="#过程二：Linking（链接）阶段" class="headerlink" title="过程二：Linking（链接）阶段"></a>过程二：Linking（链接）阶段</h2><h3 id="环节1-链接阶段之-Verification-（验证）"><a href="#环节1-链接阶段之-Verification-（验证）" class="headerlink" title="环节1:链接阶段之 Verification （验证）"></a>环节1:链接阶段之 Verification （验证）</h3><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p>
<p><strong>它的目的是保证加载的字节码是合法、合理并符合规范的。</strong></p>
<p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上 Java 虚拟机需要做以下检查，如图所示：</p>
<p><img src="/images/java/jvm/%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E4%B9%8B%E9%AA%8C%E8%AF%81.png" alt="链接阶段之验证.png"></p>
<p><strong>整体说明：</strong></p>
<p>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</p>
<ul>
<li>其中<strong>格式验证会和加载阶段一起执行</strong>。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</li>
<li><strong>格式验证之外的验证操作将会在方法区中进行。</strong></li>
</ul>
<p>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。</p>
<p><strong>具体说明：</strong></p>
<ol>
<li><strong>格式验证</strong>：是否以魔数 0xCAFEBABE 开头，主版本和副版本号是否在当前 Java 虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</li>
<li>Java 虚拟机会进行字节码的<strong>语义检查</strong>，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</li>
</ol>
<ul>
<li>是否所有的类都有父类的存在（在 Java 里，除了 Object 外，其他类都应该有父类）</li>
<li>是否一些被定义为 final 的方法或者类被重写或继承了</li>
<li>非抽象类是否实现了所有抽象方法或者接口方法</li>
<li>是否存在不兼容的方法（比如方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度；absract 情况下的方法，就不能是final 的了）</li>
</ul>
<ol start="3">
<li>Java 虚拟机还会进行<strong>字节码验证</strong>，字节码验证也是<strong>验证过程中最为复杂的一个过程</strong>。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：</li>
</ol>
<ul>
<li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li>
<li>函数的调用是否传递了正确类型的参数</li>
<li>变量的赋值是不是给了正确的数据类型等</li>
</ul>
<p>栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100% 准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。</p>
<p><strong>在前面 3 次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。</strong></p>
<ol start="4">
<li>校验器还将进行符号引用的验证。Class 文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<strong>虚拟机就会检查这些类或者方法确实是存在的</strong>，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出 NoClassDefFoundError，如果一个方法无法被找到，则会抛出 NoSuchMethdError。</li>
</ol>
<p>此阶段在解析环节才会执行</p>
<h3 id="环节2-链接阶段之-Preparation-（准备）"><a href="#环节2-链接阶段之-Preparation-（准备）" class="headerlink" title="环节2:链接阶段之 Preparation （准备）"></a>环节2:链接阶段之 Preparation （准备）</h3><p>准备阶段（Preparation），简言之，为类的静态变量分配内存，并将其初始化为默认值。</p>
<p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。</p>
<p>Java 虚拟机为各类型变量默认的初始值如表所示：</p>
<p><img src="/images/java/jvm/%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E4%B9%8B%E5%87%86%E5%A4%87.png" alt="链接阶段之准备.png"></p>
<p>注意：Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是 0，故对应的，boolean 的默认值就是 false。</p>
<p>注意：</p>
<ol>
<li><strong>这里不包含基本数据类型的字段用 static final 修饰的情况，因为 final 在编译的时候就会分配了，准备阶段会显式赋值。</strong></li>
<li>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</li>
<li>在这个阶段不会像初始化阶段中那样会有初始化或者代码被执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 基本数据类型：非 final 修饰的变量，在准备环节进行默认初始化赋值</span></span><br><span class="line"><span class="comment"> * final 修饰以后，在准备环节直接进行显式赋值</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 拓展：如果使用字面量的方式定义一个字符串的常量的话，也是在准备环节直接进行显式赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkingTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String constStr = <span class="string">"CONST"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String constStr1 = <span class="keyword">new</span> String(<span class="string">"CONST"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="环节3-链接阶段之-Resolution-（解析）"><a href="#环节3-链接阶段之-Resolution-（解析）" class="headerlink" title="环节3:链接阶段之 Resolution （解析）"></a>环节3:链接阶段之 Resolution （解析）</h3><p><strong>在准备阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。</strong></p>
<ol>
<li><strong>具体描述：</strong></li>
</ol>
<p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和内存分布无关。比较容理解的就是在 Class 类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下 println() 方法被调用时，系统需要明确知道该方法的位置。</p>
<p>举例：输出操作 System.out.println() 对应的字节码：</p>
<p>invokevirtual #24 &lt;java/io/PrintStream.println&gt;</p>
<p><img src="/images/java/jvm/%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E4%B9%8B%E8%A7%A3%E6%9E%90.png" alt="image-20201024202315773"></p>
<p>以方法为例，Java 虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<strong>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</strong></p>
<ol start="2">
<li><strong>小结</strong></li>
</ol>
<p><strong>所谓解析就是将符号引用转为直接引用</strong>，也就是得到类、字段、方法在内存中的指针或者偏移量。因此，可以说，如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构。</p>
<p>不过 Java 虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在 HotSpot VM 中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着 JVM 在执行完初始化之后再执行。</p>
<ol start="3">
<li><strong>字符串的复习</strong></li>
</ol>
<p>最后，再来看一下 CONSTANT_String 的解析。由于字符串在程序开发中有着重要的作用，因此，读者有必要了解一下 String 在 Java 虚拟机中的处理。<strong>当在 Java 代码中直接使用字符串常量时，就会在类中出现 CONSTANT_String</strong>，它表示字符串常量，并且会引用一个 CONSTANT_UTF8 的常量项。<strong>在 Java 虚拟机内部运行中的常量池，会维护一张字符串拘留表（intern），它会保存所有出现过的字符串常量，并且没有重复项</strong>。只要以 CONSTANT_String 形式出现的字符串也都会在这张表中。使用 String.intern() 方法可以得到一个字符串在拘留表中的引用，因为该表中没有重复项，所以任何字面相同的字符串的 String.intern() 方法返回总是相等的。</p>
<h2 id="过程三：Initialization（初始化）阶段"><a href="#过程三：Initialization（初始化）阶段" class="headerlink" title="过程三：Initialization（初始化）阶段"></a>过程三：Initialization（初始化）阶段</h2><p><strong>初始化阶段，简言之，为类的静态变量赋予正确的初始值</strong></p>
<ol>
<li><strong>具体描述</strong></li>
</ol>
<p>类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行 Java 字节码。（即：到了初始化阶段，才真正开始执行类中定义的 Java 程序代码）。</p>
<p><strong>初始化阶段的重要工作是执行类的初始化方法：<clinit>() 方法。</strong></p>
<ul>
<li>该方法仅能由 Java 编译器生成并由 JVM 调用，程序开发者无法自定义一个同名的方法，更无法直接在 Java 程序中调用该方法，虽然该方法也是由字节码指令所组成。</li>
<li>它是类静态成员的赋值语句以及 static 语句块合并产生的。</li>
</ul>
<ol start="2">
<li><p>说明</p>
<ol>
<li>在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的 <clinit> 总是在子类 <clinit> 之前被调用，也就是说，父类的 static 块优先级高于子类。</li>
<li>Java 编译器并不会为所有的类都产生 <clinit>() 初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含 <clinit>() 方法？</li>
</ol>
<ul>
<li>一个类中并没有声明任何的类变量，也没有静态代码块时；</li>
<li>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时；</li>
<li>一个类中包含 static final 修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式。</li>
</ul>
</li>
</ol>
<h3 id="static-与-final-的搭配问题"><a href="#static-与-final-的搭配问题" class="headerlink" title="static 与 final 的搭配问题"></a>static 与 final 的搭配问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 哪些场景下，Java 编译器就不会生成&lt;clinit&gt;()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest1</span> </span>&#123;</span><br><span class="line">  <span class="comment">//场景1:对应非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//场景2：静态的字段，没有显式的赋值，不会生成&lt;clinit&gt;()方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num1;</span><br><span class="line">  <span class="comment">//场景3：比如对于声明为 static final 的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：使用 static + final 修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</span></span><br><span class="line"><span class="comment"> * 情况1：在链接阶段的准备环节赋值</span></span><br><span class="line"><span class="comment"> * 情况2：在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> * 在链接阶段的准备环节赋值的情况：</span></span><br><span class="line"><span class="comment"> * 1. 对于基本数据类型的字段来说，如果使用 static final 修饰，则显式赋值（直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment"> * 2. 对于 String 来说，如果使用字面量的方式赋值，使用 static final 修饰的话，则显式赋值通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在初始化阶段&lt;clinit&gt;()中赋值的情况</span></span><br><span class="line"><span class="comment"> * 排除上述的在准备环节赋值的情况之外的情况</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最终结论：使用 static + final 修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或 String 类型的显式赋值，是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_CONSTANT = <span class="number">10</span>;  <span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="number">100</span>);   <span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="number">1000</span>); <span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s0 = <span class="string">"helloworld0"</span>; <span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s1 = <span class="keyword">new</span> String(<span class="string">"helloworld1"</span>); <span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="的线程安全性"><a href="#的线程安全性" class="headerlink" title="() 的线程安全性"></a><clinit>() 的线程安全性</h3><p>对于 <clinit>() 方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</p>
<p>虚拟机会保证一个类的 <clinit>() 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <clinit>() 方法，其他线程都需要阻塞等待，直到活动线程执行 <clinit>() 方法完毕。</p>
<p>正是因为函数 <clinit>() 带锁线程安全的，因此，如果一个在类的 <clinit>() 方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p>
<p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行 <clinit>() 方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。</p>
<h3 id="类的初始化情况：主动使用-vs-被动使用"><a href="#类的初始化情况：主动使用-vs-被动使用" class="headerlink" title="类的初始化情况：主动使用 vs 被动使用"></a>类的初始化情况：主动使用 vs 被动使用</h3><p>Java 程序对类的使用分为两种：主动使用 和 被动使用。</p>
<p><strong>一、主动使用</strong></p>
<p>Class 只有在必须要首次使用的时候才会被装载，Java 虚拟机不会无条件地装载 Class 类型。Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的”使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成）。</p>
<ol>
<li>当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化</li>
<li>当调用类的静态方法时，即当使用了字节码 invokestatic 指令</li>
<li>当使用类、接口的静态字段时（final 修饰特殊考虑），比如，使用 getstatic 或者 putsttic 指令。（对应访问变量、赋值变量操作）</li>
<li>当使用 java.lang.reflect 包中的方法反射类的方法时。比如：Class.forname(“com.atguigu.java.Test”)</li>
<li>当初始化子类时，如果发现其分类还没有进行过初始化，则需要先触发其父类的初始化</li>
<li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类</li>
<li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析 REF_getStatic、REF_putStatic、REF_invokeStatic 方法句柄对应的类）</li>
</ol>
<p><strong>针对 5，补充说明：</strong></p>
<p>当 Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p>
<ul>
<li>在初始化一个类时，并不会先初始化它所实现的接口</li>
<li>在初始化一个接口时，并不会先初始化它的父接口</li>
</ul>
<p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。</p>
<p><strong>针对 7，说明：</strong></p>
<p>JVM 启动的时候通过引导类加载器加载一个初始类。这个类在调用 public static void main(String[]) 方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载、链接和初始化。</p>
<p><strong>二、被动使用</strong></p>
<p>除了以上的情况属于主动使用，其他的情况均属于被动使用。<strong>被动使用不会引起类的初始化。</strong></p>
<p>也就是说：<strong>并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。</strong></p>
<ol>
<li>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化</li>
</ol>
<ul>
<li>当通过子类引用父类的静态变量，不会导致子类初始化</li>
</ul>
<ol start="2">
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用变量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了</li>
<li>调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化</li>
</ol>
<p>如果针对代码，设置参数 -XX:+TraceClassLoading，可以追踪类的加载信息并打印出来。</p>
<h2 id="过程四：类的Using（使用）"><a href="#过程四：类的Using（使用）" class="headerlink" title="过程四：类的Using（使用）"></a>过程四：类的Using（使用）</h2><p>任何一个类型在使用之前都必须经历过完整的加载、链接和初始化 3 个类加载步骤。一旦一个类型成功经历过这 3 个步骤之后，便“万事俱备，只欠东风”，就等着开发者使用了。</p>
<p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用 new 关键字为其创建对象实例。</p>
<h2 id="过程五：类的Unloading（卸载）"><a href="#过程五：类的Unloading（卸载）" class="headerlink" title="过程五：类的Unloading（卸载）"></a>过程五：类的Unloading（卸载）</h2><p><strong>一、类、类的加载器、类的实例之间的引用关系</strong></p>
<p>在类加载器的内部实现中，用一个 Java 集合来存放所加载类的引用。另一方面，一个 Class 对象总是会引用它的类加载器，调用 Class 对象的 getClassLoader() 方法，就能获得它的类加载器。由此可见，代表某个类的 Class 实例与其类的加载器之间为<strong>双向关联关系</strong>。</p>
<p>一个类的实例总是引用代表这个类的 Class 对象。在 Object 类中定义了 getClass() 方法，这个方法返回代表对象所属类的 Class 对象的引用。此外，所有的 Java 类都有一个静态属性 Class，它引用代表这个类的 Class 对象。</p>
<p><strong>二、类的生命周期</strong></p>
<p>当 Sample 类被加载、链接和初始化后，它的生命周期就开始了。当代表 Sample 类的 Class 对象不再被引用，即不可触及时，Class 对象就会结束生命周期，Sample 类在方法区内的数据也会被卸载，从而结束 Sample 类的生命周期。</p>
<p><strong>一个类何时结束生命周期，取决于代表它的 Class 对象何时结束生命周期。</strong></p>
<p><strong>三、具体例子</strong></p>
<p><img src="/images/java/jvm/Class%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Class的生命周期.png"></p>
<p>Loader1 变量和 obj 变量间接应用代表 Sample 类的 Class 对象，而 objClass 变量则直接引用它。</p>
<p>如果程序运行过程中，将上图左侧三个引用变量都置为 null，此时 Sample 对象结束生命周期，MyClassLoader 对象结束生命周期，代表 Sample 类的 Class 对象也结束生命周期，Sample 类在方法区内的二进制数据<strong>被卸载</strong>。</p>
<p>当再次有需要时，会检查 Sample 类的 Class 对象是否存在，如果存在会直接使用，不再重新加载；如果不存在 Sample 类会被重新加载，在 Java 虚拟机的堆区会生成一个新的代表 Sample 类的 Class 实例（可以通过哈希码查看是否是同一个实例）。</p>
<p><strong>四、类的卸载</strong></p>
<ol>
<li>启动类加载器加载的类型在整个运行期间是不可能被卸载的（JVM 和 JSL 规范）。</li>
<li>被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 unreachable 的可能性极小</li>
<li>被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景(比如：很多时候用户在开发自定义类的加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)</li>
</ol>
<p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能</p>
<h3 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h3><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量</strong>和<strong>不再使用的类型</strong>。</p>
<p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收。也就是 Java 堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGI、JSP 的重加载等，否则通常是很难达成的</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是”被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>
<h1 id="再谈类的加载器"><a href="#再谈类的加载器" class="headerlink" title="再谈类的加载器"></a>再谈类的加载器</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>类加载器是 JVM 执行类加载机制的前提。</p>
<p>ClassLoader 的作用：</p>
<p>ClassLoader 是 Java 的核心组件，所有的 Class 都是由 ClassLoader 进行加载的，ClassLoader 负责通过各种方式将 Class 信息的二进制数据流读入 JVM 内部，转换为一个与目标类对应的 java.lang.Class 对象实例。然后交给 Java 虚拟机进行链接、初始化等操作。因此，ClassLoader 在整个装载阶段，只能影响到类的加载，而无法通过 ClassLoader 去改变类的链接和初始化行为。至于它是否可以运行，则由 Execution Engine 决定。</p>
<p><img src="/images/java/jvm/%E5%86%8D%E8%B0%88%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="再谈类加载器.png"></p>
<p>类加载器最早出现在 Java 1.0 版本中，那个时候只是单纯地为了满足 Java Applet 应用而被研发出来，但如今类加载器却在 OSGI、字节码加解密领域大放异彩。这主要归功于 Java 虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将它绑定在 JVM 内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。</p>
<h3 id="大厂面试题-1"><a href="#大厂面试题-1" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><p><strong>蚂蚁金服：</strong></p>
<p>深入分析 ClassLoader，双亲委派机制</p>
<p>类加载器的双亲委派模型是什么？</p>
<p>一面：双亲委派机制及使用原因</p>
<p><strong>百度：</strong></p>
<p>都有哪些类加载器，这些类加载器都加载哪些文件？</p>
<p>手写一个类加载器 Demo</p>
<p>Class 的 forName(“java.lang.String”) 和 Class 的 getClassLoader() 的 loadClass(“java.lang.String”)有什么区别？</p>
<p><strong>腾讯：</strong></p>
<p>什么是双亲委派模型？</p>
<p>类加载器有哪些？</p>
<p><strong>小米：</strong></p>
<p>双亲委派模型介绍一下</p>
<p><strong>滴滴：</strong></p>
<p>简单说说你了解的类加载器</p>
<p>一面：讲一下双亲委派模型，以及其优点</p>
<p>字节跳动：</p>
<p>什么事类加载器，类加载器有哪些？</p>
<p><strong>京东：</strong></p>
<p>类加载器的双亲委派模型是什么？</p>
<p>双亲委派机制可以打破吗？为什么？</p>
<h3 id="类加载的分类"><a href="#类加载的分类" class="headerlink" title="类加载的分类"></a>类加载的分类</h3><p><strong>类的加载分类：显式加载 vs 隐式加载</strong></p>
<p>Class 文件的显式加载与隐式加载的方式是指 JVM 加载 Class 文件到内存的方式。</p>
<ul>
<li>显式加载指的是在代码中通过调用 ClassLoader 加载 Class 对象，如直接使用 Class.forName(name) 或 this.getClass().getClassLoader().loadClass() 加载 Class 对象。</li>
<li>隐式加载则是不直接在代码中调用 ClassLoader 的方法加载 Class 对象，而是通过虚拟机自动加载到内存中，如在加载某个类的 Class 文件时，该类的 Class 文件中引用了另外一个类的对象，此时额外引用的类将通过 JVM 自动加载到内存中。</li>
</ul>
<p>在日常开发中以上两种方式一般会混合使用。</p>
<h3 id="类加载器的必要性"><a href="#类加载器的必要性" class="headerlink" title="类加载器的必要性"></a>类加载器的必要性</h3><p>一般情况下，Java 开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p>
<ul>
<li>避免在开发中遇到 java.lang.ClassNotFoundException 异常或 java.lang.NoClassDeFoundError 异常时手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题。</li>
<li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li>
<li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</li>
</ul>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><ol>
<li>何为类的唯一性？</li>
</ol>
<p>对于任意一个类，<strong>都需要由加载它的类加载器和这个类本身一同确认其在 Java 虚拟机中的唯一性</strong>。每一个类加载器，都拥有一个独立的类名称空间：<strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。</strong>否则，即使这两个类源自同一个 Class 文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<ol start="2">
<li>命名空间</li>
</ol>
<ul>
<li>每个类加载器都有自己的命名空间，命名空间由该加载器所有的父加载器所加载的类组成</li>
<li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li>
<li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li>
</ul>
<p><strong>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</strong></p>
<h3 id="类加载机制的基本特征"><a href="#类加载机制的基本特征" class="headerlink" title="类加载机制的基本特征"></a>类加载机制的基本特征</h3><p>通常类加载机制有三个基本特征：</p>
<ul>
<li>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如 JDK 内部的 ServiceProvider/ServiceLoader 机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li>
<li>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li>
<li>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器”邻居”间，同一类型仍然可以被加载多次，因为相互并不可见。</li>
</ul>
<h2 id="复习：类的加载器分类"><a href="#复习：类的加载器分类" class="headerlink" title="复习：类的加载器分类"></a>复习：类的加载器分类</h2><p>JVM 支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p>
<p><img src="/images/java/jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB.png" alt="类的加载器分类.png"></p>
<ul>
<li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的”父类”加载器。</li>
<li>不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">  ClassLoader parent; <span class="comment">//父类加载器</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ParentClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ChildClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//parent = new ParentClassLoader();</span></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><p>启动类加载器（引导类加载器）</p>
<ul>
<li>这个类加载使用 C/C++ 语言实现的，嵌套在 JVM 内部</li>
<li>它用来加载 Java 的核心库（JAVA_HOME/jre/lib/rt.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类</li>
<li>并不继承自 java.lang.ClassLoader，没有父加载器</li>
<li>出于安全考虑，Bootstrap 启动类加载器之加载包名为 java、javax、sun 等开头的类</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li>
</ul>
<p>使用 -XX:+TraceClassLoading 参数</p>
<p>启动类加载器使用 C++ 编写的？Yes！</p>
<ul>
<li>C/C++：指针函数 &amp; 函数指针、C++ 支持多继承、更加高效</li>
<li>Java ：由 C++ 演变而来，(C++)– 版，单继承</li>
</ul>
<h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>扩展类加载器（Extension ClassLoader）</p>
<ul>
<li>Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现</li>
<li>继承于 ClassLoader 类</li>
<li>父类加载器为启动类加载器</li>
<li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
<h3 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p>应用程序类加载器（系统类加载器，AppClassLoader）</p>
<ul>
<li>Java 语言编写，由 sun.misc.Launcher$AppClassLoader 实现</li>
<li>继承于 ClassLoader 类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库</li>
<li><strong>应用程序中的类加载器默认是系统类加载器</strong></li>
<li>它是用户自定义类加载器的默认父加载器</li>
<li>通过 ClassLoader 的 getSystemClassLoader() 方法可以获取到该类加载器</li>
</ul>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><ul>
<li>在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式</li>
<li>体现 Java 语言强大生命力和巨大魅力的关键因素之一便是，Java 开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的 JAR 包，也可以是网络上的远程资源</li>
<li>通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例不胜枚举。例如，著名的 OSGI 组件框架，再如 Eclipse 的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无需重新打包发布应用程序就能实现</li>
<li>同时，自定义加载器能够实现应用隔离，例如 Tomcat、Spring 等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比 C/C++ 程序要好太多，想不修改 C/C++ 程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡所有美好的设想</li>
<li>自定义类加载器通常需要继承于 ClassLoader</li>
</ul>
<h2 id="测试不同的类加载器"><a href="#测试不同的类加载器" class="headerlink" title="测试不同的类加载器"></a>测试不同的类加载器</h2><p>每个 Class 对象都会包含一个定义它的 ClassLoader 的一个引用。</p>
<p>获取 ClassLoader 的途径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取当前类的 ClassLoader</span><br><span class="line">clazz.getClassLoader();</span><br><span class="line"></span><br><span class="line">获得当前线程上下文的 ClassLoader</span><br><span class="line">Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">获得系统的 ClassLoader</span><br><span class="line">ClassLoader.getSystemClassLoader();</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加载器，引导类加载器是使用 C++ 语言编写而成的，而另外两种类加载器则是使用 Java 语言编写的。由于引导类加载器压根儿就不是一个 Java 类，因此在 Java 程序中只能打印出空值。</p>
<p>数组类的 Class 对象，不是由类加载器去创建的，而是在 Java 运行期 JVM 根据需要自动创建的。对于数组类的类加载器来说，是通过 Class.geetClassLoader() 返回的，与数组当中元素类型的类加载器是一样的：如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strArr = <span class="keyword">new</span> String[<span class="number">6</span>];</span><br><span class="line">System.out.println(strArr.getClass().getClassLoader());</span><br><span class="line"><span class="comment">//运行结果：null</span></span><br><span class="line"></span><br><span class="line">ClassLoaderTest[] test = <span class="keyword">new</span> ClassLoaderTest[<span class="number">1</span>];</span><br><span class="line">System.out.println(test.getClass().getClassLoader());</span><br><span class="line"><span class="comment">//运行结果：sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] inst = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(inst.getClass().getClassLoader());</span><br><span class="line"><span class="comment">//运行结果：null</span></span><br></pre></td></tr></table></figure>

<h2 id="ClassLoader-源码解析"><a href="#ClassLoader-源码解析" class="headerlink" title="ClassLoader 源码解析"></a>ClassLoader 源码解析</h2><p>ClassLoader 与现有类加载的关系：</p>
<p>![ClassLoader 与现有类加载的关系.png](/images/java/jvm/ClassLoader 与现有类加载的关系.png)</p>
<p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java 提供了抽象类 java.lang.ClassLoader，所有用户自定义的类加载器都应该继承 ClassLoader 类。</p>
<h3 id="ClassLoader-的主要方法"><a href="#ClassLoader-的主要方法" class="headerlink" title="ClassLoader 的主要方法"></a>ClassLoader 的主要方法</h3><p>抽象类 ClassLoader 的主要方法：（内部没有抽象方法）</p>
<ul>
<li>public final ClassLoader getParent()</li>
</ul>
<p>返回该类加载器的超类加载器。</p>
<ul>
<li>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</li>
</ul>
<p>加载名称为 name 的类，返回结果为 java.lang.Class 类的实例。如果找不到类，则返回 ClassNotFountException 异常。该方法中的逻辑就是双亲委派模式的实现。</p>
<ul>
<li>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException</li>
</ul>
<p>查找二进制名称为 name 的类，返回结果为 java.lang.Class 类的实例。这是一个受保护的方法，JVM 鼓励我们重写此方法，需要自定义加载器遵循双亲委派机制，该方法会在检查完父类加载器之后被 loadClass() 方法调用。</p>
<p>在 JDK 1.2 之前，在自定义类加载时，总会去继承 ClassLoader 类并重写 loadClass 方法，从而实现自定义的类加载类。但是在 JDK 1.2 之后已不再建议用户去覆盖 loadClass() 方法，而是建议把自定义的类加载逻辑写在 find Class() 方法中，从前面的分析可知，findClass() 方法是在 loadClass() 方法中被调用的，当 loadClass() 方法中父加载器加载失败后，则会调用自己的 findClass() 方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委派机制。</p>
<p>需要注意的是 ClassLoader 类中并没有实现 findClass() 方法的具体代码逻辑，取而代之的是抛出 ClassNotFoundException 异常，同时应该知道的是 findClass() 方法通常是和 defineClass() 方法一起使用的。<strong>一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader 的 findClass() 方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用 defineClass() 方法生成类的 Class 对象。</strong></p>
<ul>
<li>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</li>
</ul>
<p>根据给定的字节数组 b 转换为 Class 的实例，off 和 len 参数表示实际 Class 信息在 byte 数组中的位置和长度，其中 byte 数组 b 是 ClassLoader 从外部获取的。这是受保护的方法，只有在自定义 ClassLoader 子类中可以使用。</p>
<p>defineClass() 方法是用来将 byte 字节流解析成 JVM 能够识别的 Class 对象（ClassLoader 中已实现该方法逻辑），通过这个方法不仅能够通过 Class 文件实例化 Class 对象，也可以通过其它方式实例化 Class 对象，如通过网络中接收一个类的字节码，然后转换为 byte 字节流创建对应的 Class 对象。</p>
<p><strong>defineClass() 方法通常与 findClass() 方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader 的 findClass() 方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用 defineClass() 方法生成类的 Class 对象。</strong></p>
<p>简单举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  <span class="comment">//获取类的字节数组</span></span><br><span class="line">  <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">  <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//使用 defineClass 生成 Class 对象</span></span><br><span class="line">    <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>protected final void resolveClass(Class&lt;?&gt; c)</li>
</ul>
<p>链接指定的一个 Java 类。使用该方法可以使用类的 Class 对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p>
<ul>
<li>protected final Class&lt;?&gt; findLoadedClass(String name)</li>
</ul>
<p>查找名称为 name 的已经被加载过的类，返回结果为 java.lang.Class 类的实例。这个方法是 final 方法，无法被修改。</p>
<ul>
<li>private final ClassLoader parent;</li>
</ul>
<p>它也是一个 ClassLoader 的实例，这个字段所表示的 ClassLoader 也称为这个 ClassLoader 的双亲。在类加载的过程中，ClassLoader 可能会将某些请求交予自己的双亲处理。</p>
<h4 id="loadClass-的剖析"><a href="#loadClass-的剖析" class="headerlink" title="loadClass() 的剖析"></a>loadClass() 的剖析</h4><p>测试代码：</p>
<p>ClassLoader.getSystemClassLoader().loadClass(“com.atguigu.java.User”)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads the class with the specified &lt;a href="#binary-name"&gt;binary name&lt;/a&gt;.  The</span></span><br><span class="line"><span class="comment"> * default implementation of this method searches for classes in the</span></span><br><span class="line"><span class="comment"> * following order:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; Invoke &#123;<span class="doctag">@link</span> #findLoadedClass(String)&#125; to check if the class</span></span><br><span class="line"><span class="comment"> *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #loadClass(String) loadClass&#125; method</span></span><br><span class="line"><span class="comment"> *   on the parent class loader.  If the parent is &#123;<span class="doctag">@code</span> null&#125; the class</span></span><br><span class="line"><span class="comment"> *   loader built into the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #findClass(String)&#125; method to find the</span></span><br><span class="line"><span class="comment"> *   class.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If the class was found using the above steps, and the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> resolve&#125; flag is true, this method will then invoke the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #resolveClass(Class)&#125; method on the resulting &#123;<span class="doctag">@code</span> Class&#125; object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Subclasses of &#123;<span class="doctag">@code</span> ClassLoader&#125; are encouraged to override &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #findClass(String)&#125;, rather than this method.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Unless overridden, this method synchronizes on the result of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getClassLoadingLock getClassLoadingLock&#125; method</span></span><br><span class="line"><span class="comment"> * during the entire class loading process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  name</span></span><br><span class="line"><span class="comment"> *         The &lt;a href="#binary-name"&gt;binary name&lt;/a&gt; of the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  resolve</span></span><br><span class="line"><span class="comment"> *         If &#123;<span class="doctag">@code</span> true&#125; then resolve the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The resulting &#123;<span class="doctag">@code</span> Class&#125; object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ClassNotFoundException</span></span><br><span class="line"><span class="comment"> *          If the class could not be found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="comment">//resolve:true 加载Class的同时进行解析操作</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123; <span class="comment">//同步操作，保证只能加载一次</span></span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否进行解析操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SecureClassLoader-与-URLClassLoader"><a href="#SecureClassLoader-与-URLClassLoader" class="headerlink" title="SecureClassLoader 与 URLClassLoader"></a>SecureClassLoader 与 URLClassLoader</h3><p>接着 SecureClassLoader 扩展了 ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要针对 Class 源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多的是与它的子类 URLClassLoader 有所关联。</p>
<p>前面说过，ClassLoader 是一个抽象类，很多方法是空的没有实现，比如 findClass()、findResource() 等。而 URLClassLoader 这个实现类为这些方法提供了具体的实现。并新增了 URLClassPath 类协助取得 Class 字节码流等功能。<strong>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类</strong>，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
<h3 id="ExtClassLoader-与-AppClassLoader"><a href="#ExtClassLoader-与-AppClassLoader" class="headerlink" title="ExtClassLoader 与 AppClassLoader"></a>ExtClassLoader 与 AppClassLoader</h3><p>ExtClassLoader 并没有重写 loadClass() 方法，这足以说明其遵循双亲委派模式，而 AppClassLoader 重载了 loadClass() 方法，但最终调用的还是父类 loadClass() 方法，因此依然遵循双亲委派模式。</p>
<h3 id="Class-forName-与-ClassLoader-loadClass"><a href="#Class-forName-与-ClassLoader-loadClass" class="headerlink" title="Class.forName() 与 ClassLoader.loadClass()"></a>Class.forName() 与 ClassLoader.loadClass()</h3><ul>
<li>Class.forName()：是一个静态方法，最常用的是 Class.forName(String className)；根据传入的类的权限定名返回一个 Class 对象。<strong>该方法在将 Class 文件加载到内存的同时，会执行类的初始化。</strong>如：</li>
</ul>
<p>Class.forName(“com.atguigu.java.HelloWorld”);</p>
<ul>
<li>ClassLoader.loadClass() 这是一个实例方法，需要一个 ClassLoader 对象来调用该方法。该方法将 Class 文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。该方法因为需要得到一个 ClassLoader 对象，所以可以根据需要指定使用哪个类加载器，如：ClassLoader c1 = …..; c1.loadClass(“com.atguigu.java.HelloWorld”);</li>
</ul>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="定义与本质"><a href="#定义与本质" class="headerlink" title="定义与本质"></a>定义与本质</h3><p>类加载器用来把类加载到 Java 虚拟机中。从 JDK 1.2 版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证 Java 平台的安全。</p>
<ol>
<li>定义</li>
</ol>
<p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<ol start="2">
<li>本质</li>
</ol>
<p>规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</p>
<p><img src="/images/java/jvm/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt="双亲委派模型.png"></p>
<p><img src="/images/java/jvm/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.png" alt="双亲委派模型详细过程.png"></p>
<h3 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h3><ol>
<li>双亲委派机制优势</li>
</ol>
<ul>
<li>避免类的重复加载，确保一个类的全局唯一性</li>
</ul>
<p>Java 类随着它的类加载器一起具备了一种带有优先级的层级关系，通过这种层级关系可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子 ClassLoader 再加载一次。</p>
<ul>
<li>保护程序安全，防止核心 API 被随意篡改</li>
</ul>
<ol start="2">
<li>代码支持</li>
</ol>
<p>双亲委派机制在 java.lang.ClassLoader.loadClass(String, boolean) 接口中体现。该接口的逻辑如下：</p>
<ol>
<li>先在当前加载器的缓存中查找有无目标类，如果有，直接返回；</li>
<li>判断当前加载器的父加载器是否为空，如果不为空，则调用 parent.loadClass(name, false) 接口进行加载；</li>
<li>反之，如果当前加载器的父类加载器为空，则调用 findBootstrapClassOrNull(name) 接口，让引导类加载器进行加载；</li>
<li>如果通过以上 3 条路径都没能成功加载，则调用 findClass(name) 接口进行加载。该接口最终会调用 java.lang.ClassLoader 接口的 defineClass 系列的 native 接口加载目标 Java 类。</li>
</ol>
<p>双亲委派的模型就隐藏在第 2 和第 3 步中。</p>
<ol start="3">
<li>举例</li>
</ol>
<p>假设当前加载的是 java.lang.Object 这个类，很显然，该类属于 JDK 中核心的不能再核心的一个类，因此一定只能由引导类加载器进行加载。当 JVM 准备加载 java.lang.Object 时，JVM 默认会使用系统类加载器去加载，按照上面 5 步加载的逻辑，在第 1 步从系统类的缓存中肯定查找不到该类，于是进入第 2 步。由于从系统类加载器的父类加载器是扩展类加载器，于是扩展类加载器继续从第 1 步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第 2 步。扩展类的父加载器是 null，因此系统调用 findClass(String)，最终通过引导类加载器进行加载。</p>
<ol start="4">
<li>思考</li>
</ol>
<p>如果在自定义的类加载器中重写 java.lang.ClassLoader.loadClass(String) 或 java.lang.ClassLoader.loadClass(String, boolean) 方法，抹去其中的双亲委派机制，仅保留上面这 4 步中的第 1 步和第 4 步，那么是不是就能够加载核心类库了呢？</p>
<p>这也不行！因为 JDK 还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用 java.lang.ClassLoader.defineClass(String, byte[], int, int, ProtectionDomain) 方法，而该方法会执行 <strong>preDefineClass() 接口</strong>，该接口中提供了对 JDK 核心类库的保护。</p>
<ol start="5">
<li>双亲委派模式的弊端</li>
</ol>
<p>检查类是否加载的委派过程是单向的，这个方式虽然从结构上说比较清晰，使各个 ClassLoader 的职责非常明确，但是同时会带来一个问题，即顶层的 ClassLoader 无法访问底层的 ClassLoader 所加载的类。</p>
<p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，<strong>应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。</strong>比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<ol start="6">
<li>结论</li>
</ol>
<p><strong>由于 Java 虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</strong>比如 Tomcat 中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是 Servlet 规范推荐的一种做法。</p>
<h3 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h3><h4 id="破坏双亲委派机制1"><a href="#破坏双亲委派机制1" class="headerlink" title="破坏双亲委派机制1"></a>破坏双亲委派机制1</h4><p>双亲委派模型并不是一个具有强制性约束的模型，而是 Java 设计者推荐给开发者们的类加载器实现方式。</p>
<p>在 Java 的世界中大部分的类加载器都遵循这个模型，但也有例外情况，直到 Java 模块化出现为止，双亲委派模型主要出现过 3 次较大规模”被破坏”的情况。</p>
<p>第一次破坏双亲委派机制：</p>
<p>双亲委派模型的第一次”被破坏”其实发生在双亲委派模型出现之前——即 JDK 1.2 面世以前的”远古”时代</p>
<p>由于双亲委派模型在 JDK 1.2 之后才被引入，但是类加载器的概念和抽象类 java.lang.ClassLoader 则在 Java 的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java 设计者们引入双亲委派模型时不得不做出一些妥协，<strong>为了兼容这些已有的代码，无法再以技术手段避免 loadClass() 被子类覆盖的可能性</strong>，只能在 JDK 1.2 之后的 java.lang.ClassLoader 中添加一个新的 protected 方法 findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass() 中编写代码。上节我们已经分析过 loadClass() 方法，双亲委派的具体逻辑就实现在这里面，按照 loadClass() 方法的逻辑，如果父类加载失败，会自动调用自己的 findClass() 方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<h4 id="破坏双亲委派机制2"><a href="#破坏双亲委派机制2" class="headerlink" title="破坏双亲委派机制2"></a>破坏双亲委派机制2</h4><p>第二次破坏双亲委派机制：线程上下文类加载器</p>
<p>双亲委派模型的第二次”被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题<strong>（越基础的类由越上层的加载器进行加载）</strong>，基础类型之所以被称为”基础”，是因为它们总是作为被用户代码继承、调用的 API 存在，但程序设计往往没有绝对不变的完美规则，<strong>如果有基础类型又要调用回用户代码，那该怎么办？</strong></p>
<p>这并非是不可能出现的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器来完成加载（在 JDK 1.3 时加入到 rt.jar），肯定属于 Java 中很基础的类型了。但 JNDI 存在的目的就是对资源进行查找和集中管理，它需要调用由其它厂商实现并部署在应用程序的 ClassPath 下的 JNDI 服务提供者接口（Service Provider Interface. SPI)）的代码，现在问题来了，<strong>启动类加载器时绝对不可能认识、加载这些代码的，那该怎么办？</strong>（SPI：在 Java 平台中，通常把核心类 rt.jar 中提供外部服务、可由应用层自行实现的接口称为 SPI）。</p>
<p>为了解决这个困境，Java 的设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context ClassLoader）。</strong>这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader() 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文类加载器，程序就可以做一些”舞弊”的事情了。JNDI 服务使用这个线程上下文类加载器去加载所需的 SPI 服务代码。这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java 中涉及 SPI 的加载基本上都采用这种方式来完成，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。不过，当 SPI 的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的方式，在  JDK 6 时，JDK 提供了 java.util.ServiceLoader 类，以 META-INF/Services 中的配置信息，辅以责任链模式，这才算是给 SPI 的加载提供了一种相对合理的解决方案。</p>
<p>![破坏双亲委派机制示例- SPI 的加载.png](/images/java/jvm/破坏双亲委派机制示例- SPI 的加载.png)</p>
<p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p>
<h4 id="破坏双亲委派机制3"><a href="#破坏双亲委派机制3" class="headerlink" title="破坏双亲委派机制3"></a>破坏双亲委派机制3</h4><p>第三次破坏双亲委派机制：</p>
<p>双亲委派模型的第三次”被破坏”是由于用户对程序动态性的追求而导致的。如：<strong>代码热替换（Hot Swap）</strong>、<strong>模块热部署（Hot Deployment）</strong>等。</p>
<p>IBM 公司主导的 JSR-291（即 OSGI R4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每个程序模块（OSGI 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGI 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<strong>网状结构。</strong></p>
<p>当收到类加载请求时，OSGI 将按照下面的顺序进行类搜索：</p>
<ol>
<li><strong>将以 java.* 开头的类，委派给父类加载器加载</strong></li>
<li><strong>否则，将委派列表名单内的类，委派给父类加载器加载</strong></li>
<li>否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载</li>
<li>否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载</li>
<li>否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载</li>
<li>否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载</li>
<li>否则，类查找失败</li>
</ol>
<p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的。</p>
<p>小结：</p>
<p>这里，我们使用了”被破坏”这个词来形容上述不符合双亲委派模型原则的行为，<strong>但这里”被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</strong></p>
<p>正如：OSGI 中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，<strong>认为 OSGI 中对类加载器的运用是值得学习的，完全弄懂了 OSGI 的实现，就算是掌握了类加载器的精髓。</strong></p>
<h3 id="热替换的实现"><a href="#热替换的实现" class="headerlink" title="热替换的实现"></a>热替换的实现</h3><p>热替换是指在程序运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了 PHP 源文件，这种改动就会立即生效，而无需重启 Web 服务器。</p>
<p>但对 Java 来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在 Java 中实现这一功能的一个可行的方法就是灵活运用 ClassLoader。</p>
<p>注意：由不同 ClassLoader 加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的 ClassLoader 加载同一个类，在虚拟机内部，会认为这 2 个类是完全不同的。</p>
<p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示：</p>
<p>![破坏双亲委派机制示例- 热替换.png](/images/java/jvm/破坏双亲委派机制示例- 热替换.png)</p>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><ul>
<li>保护程序安全</li>
<li>保护 Java 原生的 JDK 代码</li>
</ul>
<p><strong>Java 安全模型的核心就是 Java 沙箱（Sandbox）</strong>，什么是沙箱？沙箱就是一个限制程序运行的环境。</p>
<p>沙箱机制就是将 Java 代码<strong>限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。</strong>通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。所有的 Java 程序运行都可以指定沙箱，可以定制安全策略。</p>
<h3 id="JDK-1-0-时期"><a href="#JDK-1-0-时期" class="headerlink" title="JDK 1.0 时期"></a>JDK 1.0 时期</h3><p>在 Java 中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的 Java 实现中，安全依赖于沙箱（Sandbox）机制。如下图所示 JDK 1.0 安全模型：</p>
<p><img src="/images/java/jvm/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6-JDK1.0.png" alt="沙箱安全机制-JDK1.0.png"></p>
<h3 id="JDK-1-1-时期"><a href="#JDK-1-1-时期" class="headerlink" title="JDK 1.1 时期"></a>JDK 1.1 时期</h3><p>JDK 1.0 中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的 JDK 1.1 版本中，针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限。如下图所示 JDK 1.1 安全模型：</p>
<p><img src="../../images/java/jvm/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6-JDK1.1.png" alt="沙箱安全机制-JDK1.1.png"></p>
<h3 id="JDK-1-2-时期"><a href="#JDK-1-2-时期" class="headerlink" title="JDK 1.2 时期"></a>JDK 1.2 时期</h3><p>在 JDK 1.2 版本中，再次改进了安全机制，增加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示 JDK 1.2 安全模型：</p>
<p><img src="/images/java/jvm/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6-JDK1.2.png" alt="沙箱安全机制-JDK1.2.png"></p>
<h3 id="JDK-1-6-时期"><a href="#JDK-1-6-时期" class="headerlink" title="JDK 1.6 时期"></a>JDK 1.6 时期</h3><p>当前最新的安全机制实现，则引入了<strong>域（Domain）</strong>的概念。</p>
<p>虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（JDK 1.6）：</p>
<p><img src="/images/java/jvm/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6-JDK1.6.png" alt="沙箱安全机制-JDK1.6.png"></p>
<h2 id="自定义类的加载器"><a href="#自定义类的加载器" class="headerlink" title="自定义类的加载器"></a>自定义类的加载器</h2><ol>
<li>为什么要自定义类加载器？</li>
</ol>
<ul>
<li>隔离加载类</li>
</ul>
<p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。再比如：Tomcat 这类 Web 应用服务器，内部自定义了好几种类加载器，用于隔离同一个 Web 应用服务器上的不同应用程序。（类的仲裁 –&gt; 类冲突）。</p>
<ul>
<li>修改类加载的方式</li>
</ul>
<p>类的加载模型并非强制，除 Bootstrap 外，其他的加载并非一定要引入，或者根据实际情况在某个时间点按需进行动态加载。</p>
<ul>
<li>扩展加载源</li>
</ul>
<p>比如从数据库、网络、甚至是电视机机顶盒进行加载。</p>
<ul>
<li>防止源码泄露</li>
</ul>
<p>Java 代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p>
<ol start="2">
<li>常见的场景</li>
</ol>
<ul>
<li>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是 Java EE 和 OSGI、JPMS 等框架。</li>
<li>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</li>
</ul>
<ol start="3">
<li>注意</li>
</ol>
<p>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及 Java 类型转换，则加载器反而容易产生不美好的事情。在做 Java 类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>用户通过定制自己的类加载器，这样可以重新定义类的加载规则，以便实现一些自定义的处理逻辑。</p>
<ol>
<li>实现方式</li>
</ol>
<ul>
<li>Java 提供了抽象类 java.lang.ClassLoader，所有用户自定义的类加载器都应该继承 ClassLoader 类</li>
<li>在自定义 ClassLoader 的子类时候，我们常见的会有两种做法：<ul>
<li>方式一：重写 loadClass() 方法</li>
<li>方式二：重写 findClass() 方法</li>
</ul>
</li>
</ul>
<ol start="2">
<li>对比</li>
</ol>
<p>这两种方法本质上差不多，毕竟 loadClass() 也会调用 findClass()，但是从逻辑上讲我们最好不要直接修改 loadClass() 的内部逻辑。建议的做法是只在 findClass() 里重写自定义类的加载方法，根据参数指定类的名字，返回对应的 Class 对象的引用。</p>
<ul>
<li>loadClass() 这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写 loadClass() 方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</li>
<li>当编写好自定义类加载器后，便可以在程序中调用 loadClass() 方法来实现类加载操作。</li>
</ul>
<ol start="3">
<li>说明</li>
</ol>
<ul>
<li>其父类加载器是系统类加载器</li>
<li>JVM 中的所有类加载都会使用 java.lang.ClassLoader.loadClass(String) 接口(自定义类加载器并重写 java.lang.ClassLoader.loadClass(String) 接口的除外)，连 JDK 的核心类库也不能例外</li>
</ul>
<h2 id="Java-9-新特性"><a href="#Java-9-新特性" class="headerlink" title="Java 9 新特性"></a>Java 9 新特性</h2><p>为了保证兼容性，JDK 9 没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动：</p>
<ol>
<li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（Platform Class Loader）。可以通过 ClassLoader 的新方法 getPlatformClassLoader() 来获取。</li>
</ol>
<blockquote>
<p>JDK 9 时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件），其中的 Java 类库就已天然地满足了可扩展的需求，那自然无需再保留 <JAVA_HOME>\lib\ext 目录，此前使用这个目录或者 java.ext.dirs 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了。</p>
</blockquote>
<ol start="2">
<li>平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader</li>
</ol>
<p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader。</p>
<p><img src="/images/java/jvm/JDK9%E4%B8%AD%E7%9A%84ClassLoader.png" alt="JDK9中的ClassLoader.png"></p>
<p>如果有程序直接依赖了这种继承关系，或者依赖了 URLClassLoader 类的特定方法，那代码很可能会在 JDK 9 及更高版本的 JDK 中崩溃。</p>
<ol start="3">
<li><p>在 Java 9 中，类加载器有了名称。该名称在构造方法中指定，可以通过 getName() 方法来获取。平台类加载器的名称是 Platform，应用类加载器的名称是 App。<strong>类加载器的名称在调试与类加载器相关的问题时会非常有用。</strong></p>
</li>
<li><p>启动类加载器现在是在 JVM 内部和 Java 类库共同协作实现的类加载器（以前是 C++ 实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回 null，而不会得到 BootClassLoader 实例。</p>
</li>
<li><p>类加载的委派关系也发生了变动</p>
</li>
</ol>
<blockquote>
<p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责哪个模块的加载器完成加载。</p>
</blockquote>
<p><strong>双亲委派模式示意图</strong></p>
<p>![JDK 9 前后的双亲委派模式对比.png](/images/java/jvm/JDK 9 前后的双亲委派模式对比.png)</p>
<p>附加：</p>
<p>在 Java 模块化系统明确规定了三个类加载器负责各自加载的模块：</p>
<ul>
<li>启动类加载器负责加载的模块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.base									java.security.sasl</span><br><span class="line">java.datatransfer					java.xml</span><br><span class="line">java.desktop							jdk.httpserver</span><br><span class="line">java.instrument						jdk.internal.vm.ci</span><br><span class="line">java.logging							jdk.management</span><br><span class="line">java.management						jdk.management.agent</span><br><span class="line">java.management.rmi				jdk.naming.rmi</span><br><span class="line">java.naming								jdk.net</span><br><span class="line">java.prefs								jdk.sctp</span><br><span class="line">java.rmi									jdk.unsupported</span><br></pre></td></tr></table></figure>

<ul>
<li>平台类加载器负责加载的模块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.activation*					jdk.accessibility</span><br><span class="line">java.compiler*						jdk.charsets</span><br><span class="line">java.corba*								jdk.crypto.cryptoki</span><br><span class="line">java.scripting						jdk.crypto.ec</span><br><span class="line">java.se										jdk.dynalink</span><br><span class="line">java.se.se								jdk.incubator.httpclient</span><br><span class="line">java.security.jgss				jdk.internal.vm.compiler*</span><br><span class="line">java.smartcardio					jdk.jsobject</span><br><span class="line">java.sql									jdk.localedata</span><br><span class="line">java.sql.rowset						jdk.naming.dns</span><br><span class="line">java.transaction*					jdk.scripting.nashorn</span><br><span class="line">java.xml.bind*						jdk.security.auth</span><br><span class="line">java.xml.crypto						jdk.security.jgss</span><br><span class="line">java.xml.ws*							jdk.xml.dom</span><br><span class="line">java.xml.ws.annotation*		jdk.zipfs</span><br></pre></td></tr></table></figure>

<ul>
<li>应用程序类加载器负责加载的模块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdk.aot										jdk.jdeps</span><br><span class="line">jdk.attach								jdk.jdi</span><br><span class="line">jdk.compiler							jdk.jdwp.agent</span><br><span class="line">jdk.editpad								jdk.jlink</span><br><span class="line">jdk.hotspot.agent					jdk.jshell</span><br><span class="line">jdk.internal.ed						jdk.jstatd</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2021/04/21/system-design/design-pattern/factory/</url>
    <content><![CDATA[<p>工厂模式包括：<strong>简单工厂（不在23种设计模式中）、工厂方法和抽象工厂。</strong></p>
<h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类。</p>
<p><img src="F:%5Cworkspace%5Cblog%5Csource%5Cimages%5Csystem-design%5Cdesign-pattern%5CsimpleFactoryUML.png" alt="img">)<img src="/images/system-design/design-pattern/simpleFactoryUML.png" alt="simpleFactoryUML"></p>
<ul>
<li>抽象类或接口：定义了要创建的产品对象的接口。</li>
<li>具体实现：具有统一父类的具体类型的产品。</li>
<li>产品工厂：负责创建产品对象。工厂模式同样体现了开闭原则，将“创建具体的产品实现类”这部分变化的代码从不变化的代码“使用产品”中分离出来，之后想要新增产品时，只需要扩展工厂的实现即可。</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Keyboard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HPKeyboard</span> <span class="keyword">implements</span> <span class="title">Keyboard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...输出逻辑;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...输入逻辑;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DellKeyboard</span> <span class="keyword">implements</span> <span class="title">Keyboard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...输出逻辑;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...输入逻辑;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LenovoKeyboard</span> <span class="keyword">implements</span> <span class="title">Keyboard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...输出逻辑;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...输入逻辑;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyboardFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Keyboard <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(BrandEnum.HP.getCode() == brand)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HPKeyboard();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(BrandEnum.LENOVO.getCode() == brand)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LenovoKeyboard();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(BrandEnum.DELL.getCode() == brand)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DellKeyboard();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        KeyboardFactory keyboardFactory = <span class="keyword">new</span> KeyboardFactory();</span><br><span class="line">        Keyboard lenovoKeyboard = KeyboardFactory.getInstance(BrandEnum.LENOVO.getCode());</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>上面的工厂实现是一个具体的类KeyboardFactory，而非接口或者抽象类，getInstance()方法利用if-else创建并返回具体的键盘实例，如果增加新的键盘子类，键盘工厂的创建方法中就要增加新的if-else。这种做法扩展性差，违背了开闭原则，也影响了可读性。所以，这种方式使用在业务较简单，工厂类不会经常更改的情况。</p>
<h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><p>为了解决上面提到的”增加if-else”的问题，可以为每一个键盘子类建立一个对应的工厂子类，这些工厂子类实现同一个抽象工厂接口。这样，创建不同品牌的键盘，只需要实现不同的工厂子类。当有新品牌加入时，新建具体工厂继承抽象工厂，而不用修改任何一个类。</p>
<h2 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h2><p><img src="/images/system-design/design-pattern/factorymethod.jpg" alt="factorymethod"></p>
<ul>
<li>抽象工厂：声明了工厂方法的接口。</li>
<li>具体产品工厂：实现工厂方法的接口，负责创建产品对象。</li>
<li>产品抽象类或接口：定义工厂方法所创建的产品对象的接口。</li>
<li>具体产品实现：具有统一父类的具体类型的产品。</li>
</ul>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IKeyboardFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Keyboard <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HPKeyboardFactory</span> <span class="keyword">implements</span> <span class="title">IKeyboardFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Keyboard <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HPKeyboard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoFactory</span> <span class="keyword">implements</span> <span class="title">IKeyboardFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Keyboard <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LenovoKeyboard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DellKeyboardFactory</span> <span class="keyword">implements</span> <span class="title">IKeyboardFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Keyboard <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DellKeyboard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>每一种品牌对应一个工厂子类，在创建具体键盘对象时，实例化不同的工厂子类。但是，如果业务涉及的子类越来越多，难道每一个子类都要对应一个工厂类吗？这样会使得系统中类的个数成倍增加，增加了代码的复杂度。</p>
<h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h1><p>为了缩减工厂实现子类的数量，不必给每一个产品分配一个工厂类，可以将产品进行分组，每组中的不同产品由同一个工厂类的不同方法来创建。</p>
<p>例如，键盘、主机这2种产品可以分到同一个分组——电脑，而不同品牌的电脑由不同的制造商工厂来创建。</p>
<p><img src="/images/system-design/design-pattern/v2-26c774778cddec1ae164116df8c1a86e_hd.jpg" alt="img"></p>
<p>类似这种把产品类分组，组内不同产品由同一工厂类的不同方法实现的设计模式，就是抽象工厂模式。</p>
<p>抽象工厂适用于以下情况：</p>
<ol>
<li><p>一个系统要独立于它的产品的创建、组合和表示时；</p>
</li>
<li><p>一个系统要由多个产品系列中的一个来配置时；</p>
</li>
<li><p>要强调一系列相关的产品对象的设计以便进行联合使用时；</p>
</li>
<li><p>当你提供一个产品类库，而只想显示它们的接口而不是实现时；</p>
</li>
</ol>
<h2 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h2><p><img src="/images/system-design/design-pattern/abstractFactory.jpg" alt="abstractFactory"></p>
<ul>
<li>抽象工厂：声明了创建抽象产品对象的操作接口。</li>
<li>具体产品工厂：实现了抽象工厂的接口，负责创建产品对象。</li>
<li>产品抽象类或接口：定义一类产品对象的接口。</li>
<li>具体产品实现：定义一个将被相应具体工厂创建的产品对象。</li>
</ul>
<h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Keyboard</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DellKeyboard</span> <span class="keyword">implements</span> <span class="title">Keyboard</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...dell...dell;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HPKeyboard</span> <span class="keyword">implements</span> <span class="title">Keyboard</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...HP...HP;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DellMonitor</span> <span class="keyword">implements</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...dell...dell;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HPMonitor</span> <span class="keyword">implements</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...HP...HP;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainFrame</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DellMainFrame</span> <span class="keyword">implements</span> <span class="title">MainFrame</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...dell...dell;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HPMainFrame</span> <span class="keyword">implements</span> <span class="title">MainFrame</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...HP...HP;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂类。工厂分为Dell工厂和HP工厂，各自负责品牌内产品的创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">MainFrame <span class="title">createMainFrame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Monitor <span class="title">createMainFrame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Keyboard <span class="title">createKeyboard</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DellFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> MainFrame <span class="title">createMainFrame</span><span class="params">()</span></span>&#123;</span><br><span class="line">                MainFrame mainFrame = <span class="keyword">new</span> DellMainFrame();</span><br><span class="line">             <span class="comment">//...造一个Dell主机;</span></span><br><span class="line">             <span class="keyword">return</span> mainFrame;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Monitor <span class="title">createMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Monitor monitor = <span class="keyword">new</span> DellMonitor();</span><br><span class="line">             <span class="comment">//...造一个Dell显示器;</span></span><br><span class="line">             <span class="keyword">return</span> monitor;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Keyboard <span class="title">createKeyboard</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Keyboard keyboard = <span class="keyword">new</span> DellKeyboard();</span><br><span class="line">             <span class="comment">//...造一个Dell键盘;</span></span><br><span class="line">             <span class="keyword">return</span> Keyboard;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HPFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> MainFrame <span class="title">createMainFrame</span><span class="params">()</span></span>&#123;</span><br><span class="line">                MainFrame mainFrame = <span class="keyword">new</span> HPMainFrame();</span><br><span class="line">             <span class="comment">//...造一个HP主机;</span></span><br><span class="line">             <span class="keyword">return</span> mainFrame;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Monitor <span class="title">createMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Monitor monitor = <span class="keyword">new</span> HPMonitor();</span><br><span class="line">             <span class="comment">//...造一个HP显示器;</span></span><br><span class="line">             <span class="keyword">return</span> monitor;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Keyboard <span class="title">createKeyboard</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Keyboard keyboard = <span class="keyword">new</span> HPKeyboard();</span><br><span class="line">             <span class="comment">//...造一个HP键盘;</span></span><br><span class="line">             <span class="keyword">return</span> Keyboard;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码。实例化不同的工厂子类，可以通过不同的创建方法创建不同的产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IFactory dellFactory = <span class="keyword">new</span> DellFactory();</span><br><span class="line">        IFactory HPFactory = <span class="keyword">new</span> HPFactory();</span><br><span class="line">        <span class="comment">//创建戴尔键盘</span></span><br><span class="line">        Keyboard dellKeyboard = dellFactory.createKeyboard();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>增加分组非常简单，例如要增加Lenovo分组，只需创建Lenovo工厂和具体的产品实现类。分组中的产品扩展非常困难，要增加一个鼠标Mouse，既要创建抽象的Mouse接口, 又要增加具体的实现：DellMouse、HPMouse， 还要再每个Factory中定义创建鼠标的方法实现。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>简单工厂：唯一工厂类，一个产品抽象类，工厂类的创建方法依据入参判断并创建具体产品对象。</li>
<li>工厂方法：多个工厂类，一个产品抽象类，利用多态创建不同的产品对象，避免了大量的if-else判断。</li>
<li>抽象工厂：多个工厂类，多个产品抽象类，产品子类分组，同一个工厂实现类创建同组中的不同产品，减少了工厂子类的数量。</li>
</ul>
<p>在下述情况下可以考虑使用工厂模式：</p>
<ol>
<li>在编码时不能预见需要创建哪种类的实例。</li>
<li>系统不应依赖于产品类实例如何被创建、组合和表达的细节。</li>
</ol>
<p>总之，工厂模式就是为了方便创建同一接口定义的具有复杂参数和初始化步骤的不同对象。工厂模式一般用来创建复杂对象。只需用new就可以创建成功的简单对象，无需使用工厂模式，否则会增加系统的复杂度。</p>
<p>此外，如果对象的参数是不固定的，推荐使用Builder模式。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>在实际项目中，结合Spring中的InitializingBean接口，可以利用@Autowired注解优雅的实现工厂。</p>
<p>作者：阿里巴巴淘系技术<br>链接：<a href="https://www.zhihu.com/question/27125796/answer/1615074467" target="_blank" rel="noopener">https://www.zhihu.com/question/27125796/answer/1615074467</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>system-design</category>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>factory</tag>
        <tag>design-pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2021/04/21/system-design/design-pattern/singleton/</url>
    <content><![CDATA[<h1 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> * 缺点：不管使用与否，类装载时就完成实例化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mgr01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Mgr01 INSTANCE = <span class="keyword">new</span> Mgr01();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Mgr01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mgr01 <span class="title">getINSTANCE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式(线程不安全)</span></span><br><span class="line"><span class="comment"> * 缺点：线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mgr02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Mgr02 INSTANCE = <span class="keyword">new</span> Mgr02();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Mgr02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mgr02 <span class="title">getINSTANCE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Mgr02();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式-锁机制(线程安全)</span></span><br><span class="line"><span class="comment"> * 缺点：效率下降</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mgr03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Mgr03 INSTANCE = <span class="keyword">new</span> Mgr03();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Mgr03</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Mgr03 <span class="title">getINSTANCE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Mgr03();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式-检查锁机制(线程不安全)</span></span><br><span class="line"><span class="comment"> * 缺点：线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mgr04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Mgr04 INSTANCE = <span class="keyword">new</span> Mgr04();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Mgr04</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mgr04 <span class="title">getINSTANCE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Mgr04<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                INSTANCE = <span class="keyword">new</span> Mgr04();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式-双重检查锁机制(线程安全)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 添加volatile的原因：</span></span><br><span class="line"><span class="comment"> * 在java中创建一个对象并非是一个原子操作</span></span><br><span class="line"><span class="comment"> * 1：分配对象的内存空间</span></span><br><span class="line"><span class="comment"> * memory = allocate();</span></span><br><span class="line"><span class="comment"> * 2：初始化对象</span></span><br><span class="line"><span class="comment"> * ctorInstance(memory);</span></span><br><span class="line"><span class="comment"> * 3：设置instance指向刚分配的内存地址</span></span><br><span class="line"><span class="comment"> * instance = memory;</span></span><br><span class="line"><span class="comment"> * 上述操作可能会被重排序（在一些JIT编译器中）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在单线程程序下，重排序不会对最终结果产生影响，但是并发的情况下，可能会导致某些线程访问到未初始化的变量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 模拟一个2个线程创建单例的场景，如下表：</span></span><br><span class="line"><span class="comment"> * 时间	线程A	                    线程B</span></span><br><span class="line"><span class="comment"> * t1	A1:分配对象内存空间</span></span><br><span class="line"><span class="comment"> * t2	A3：设置instance指向内存空间</span></span><br><span class="line"><span class="comment"> * t3		                        B1：判断instance是否为空</span></span><br><span class="line"><span class="comment"> * t4		                        B2：由于instance不为null，线程B将访问instance引用的对象</span></span><br><span class="line"><span class="comment"> * t5	A2：初始化对象</span></span><br><span class="line"><span class="comment"> * t6	A4：访问instance引用的对象</span></span><br><span class="line"><span class="comment"> * 按照这样的顺序执行，线程B将会获得一个未初始化的对象，并且自始至终，线程B无需获取锁！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mgr05</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Mgr05 INSTANCE = <span class="keyword">new</span> Mgr05();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Mgr05</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mgr05 <span class="title">getINSTANCE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Mgr05<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Mgr05();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内部静态类"><a href="#内部静态类" class="headerlink" title="内部静态类"></a>内部静态类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类(线程安全)</span></span><br><span class="line"><span class="comment"> * JVM保证单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mgr06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Mgr06</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Mgr06Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Mgr06 INSTANCE = <span class="keyword">new</span> Mgr06();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mgr06 <span class="title">getINSTANCE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Mgr06Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举模式(线程安全)</span></span><br><span class="line"><span class="comment"> * 不仅可以解决线程同步，还可以防止反序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Mgr07 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mgr07 <span class="title">getINSTANCE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>system-design</category>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>design-pattern</tag>
        <tag>singleton</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2021/04/21/system-design/design-pattern/strategy/</url>
    <content><![CDATA[<p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改</p>
<blockquote>
<p>策略模式实现的冒泡排序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用策略模式实现的冒泡排序，将排序实现方式通过参数的形式传入，而不是固定一个方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] o, Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = o.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (comparator.compare(o[j], o[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    swap(o, j, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(T[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        T temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat&#123;"</span> +</span><br><span class="line">                <span class="string">"a="</span> + a +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// comparator comparable</span></span><br><span class="line">    <span class="comment">// 对修改关闭 对扩展开放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cat[] catArr = &#123;<span class="keyword">new</span> Cat(<span class="number">1</span>), <span class="keyword">new</span> Cat(<span class="number">3</span>), <span class="keyword">new</span> Cat(<span class="number">2</span>)&#125;;</span><br><span class="line">        Sorter&lt;Cat&gt; sorter = <span class="keyword">new</span> Sorter&lt;&gt;();</span><br><span class="line">        sorter.sort(catArr, (a, b) -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (a.getA() &gt; b.getA()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (a.getA() &lt; b.getA()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(catArr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>system-design</category>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>design-pattern</tag>
        <tag>strategy</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 学习笔记 - 内存与垃圾回收</title>
    <url>/2021/05/30/java/JVM-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1PJ411n7xZ" target="_blank" rel="noopener">尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）</a>学习记录</p>
<a id="more"></a>

<blockquote>
<p>笔记来源：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ" target="_blank" rel="noopener">尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）</a></p>
<p>参考笔记：<a href="https://github.com/sxlong0205/JavaBasicKnowledge/tree/main/JVM" target="_blank" rel="noopener">JavaBasicKnowledge/JVM at main · sxlong0205/JavaBasicKnowledge (github.com)</a></p>
</blockquote>
<h1 id="JVM和Java体系架构"><a href="#JVM和Java体系架构" class="headerlink" title="JVM和Java体系架构"></a>JVM和Java体系架构</h1><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="系统虚拟机"><a href="#系统虚拟机" class="headerlink" title="系统虚拟机"></a>系统虚拟机</h3><p>完全对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台</p>
<ul>
<li>Virtual Box</li>
<li>VMware</li>
</ul>
<h3 id="程序虚拟机"><a href="#程序虚拟机" class="headerlink" title="程序虚拟机"></a>程序虚拟机</h3><p>专门为执行单个计算机程序而设计</p>
<ul>
<li>JVM</li>
</ul>
<h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><p>就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ol>
<h2 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h2><p><img src="/images/java/jvm/JVM%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt="JVM的位置.png"></p>
<h2 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h2><p><img src="/images/java/jvm/JVM%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png" alt="JVM的整体结构.png"></p>
<h2 id="Java代码运行流程"><a href="#Java代码运行流程" class="headerlink" title="Java代码运行流程"></a>Java代码运行流程</h2><p><img src="/images/java/jvm/Java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="Java代码运行流程.png"></p>
<h2 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h2><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：</p>
<h3 id="基于栈式架构的特点"><a href="#基于栈式架构的特点" class="headerlink" title="基于栈式架构的特点"></a>基于栈式架构的特点</h3><p>设计和实现更简单，适用于资源受限的系统<br>避开了寄存器的分配难题：使用零地址指令方式分配<br>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现<br>不需要硬件支持，可移植性更好，更好实现跨平台</p>
<h3 id="基于寄存器架构的特点"><a href="#基于寄存器架构的特点" class="headerlink" title="基于寄存器架构的特点"></a>基于寄存器架构的特点</h3><p>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。<br>指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差<br>性能优秀和执行更高效<br>花费更少的指令去完成一项操作<br>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</p>
</li>
<li><p>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p>
</li>
<li><p>因为基于栈的架构跨平台性好、指令集小，虽然相对于基于寄存器的架构来说，基于栈的架构编译得到的指令更多，执行性能也不如基于寄存器的架构好，但考虑到其跨平台性与移植性，我们还是选用栈的架构</p>
</li>
</ul>
<p>栈：跨平台性、指令集小、指令多；执行性能比寄存器差</p>
<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><p><img src="/images/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类加载过程.png"></p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载-Loading-阶段"><a href="#加载-Loading-阶段" class="headerlink" title="加载(Loading)阶段"></a>加载(Loading)阶段</h3><ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li><code>在内存中生成一个代表这个类的java.lang.Class对象</code>，作为方法区这个类的各种数据的访问入口</li>
</ol>
<h3 id="链接-Linking-阶段"><a href="#链接-Linking-阶段" class="headerlink" title="链接(Linking)阶段"></a>链接(Linking)阶段</h3><blockquote>
<p>链接分为三个子阶段：<code>验证 --&gt; 准备 --&gt; 解析</code></p>
</blockquote>
<p><img src="/images/java/jvm/%E7%B1%BB%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B.png" alt="类链接过程.png"></p>
<h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证(Verify)"></a>验证(Verify)</h4><ul>
<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li>
<li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li>
<li>使用 BinaryViewer 查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过<br><img src="/images/java/jvm/BinaryViewer.png" alt="BinaryViewer.png"></li>
</ul>
<h4 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备(Prepare)"></a>准备(Prepare)</h4><ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值</li>
<li><strong>这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化</strong></li>
<li>注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li>
</ul>
<h4 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析(Resolve)"></a>解析(Resolve)</h4><ul>
<li>将常量池内的符号引用转换为直接引用的过程</li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</li>
</ul>
<h3 id="初始化-Initialization-阶段"><a href="#初始化-Initialization-阶段" class="headerlink" title="初始化(Initialization)阶段"></a>初始化(Initialization)阶段</h3><ul>
<li>初始化阶段就是执行类构造器方法<clinit>()的过程</li>
<li>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有<clinit>( )方法；如果当前类不存在static变量，那么它的字节码文件是不会存在- <clinit>( )</li>
<li><clinit>()方法中的指令按语句在源文件中出现的顺序执行</li>
<li><clinit>()不同于类的构造器。（关联：构造器是虚拟机视角下的<init>()）</li>
<li>若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕</li>
<li>虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img src="/images/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="类加载器.png"></p>
<ul>
<li>JVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</li>
<li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</li>
<li>规范定义：所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</li>
</ul>
<p>AppClassLoader 继承树</p>
<p><img src="/images/java/jvm/AppClassLoader%E7%BB%A7%E6%89%BF%E6%A0%91.png" alt="AppClassLoader继承树.png"></p>
<p>ExtClassLoader继承树</p>
<p><img src="/images/java/jvm/ExtClassLoader%E7%BB%A7%E6%89%BF%E6%A0%91.png" alt="ExtClassLoader继承树.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：getParent() 只是获取上层的加载器，并不是继承关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader); <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader); <span class="comment">//sun.misc.Launcher$ExtClassLoader@61bbe9ba</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：获取不到引导类加载器</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(classLoader); <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。--&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        ClassLoader classLoader1 = String<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(classLoader1); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>引导类加载器是由 C/C++ 语言构成的，所以我们是获取不到</li>
</ul>
<h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器-引导类加载器"><a href="#启动类加载器-引导类加载器" class="headerlink" title="启动类加载器(引导类加载器)"></a>启动类加载器(引导类加载器)</h4><blockquote>
<p>启动类加载器（ 引导类加载器，Bootstrap ClassLoader ）</p>
</blockquote>
<ul>
<li>这个类加载使用 <code>C/C++</code> 语言实现的，嵌套在JVM内部<ul>
<li>它用来加载<strong>Java的核心库</strong>（JAVA_HOME / jre / lib / rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供JVM自身需要的类</li>
<li>并不继承自<code>java.lang.ClassLoader</code>，<strong>没有父加载器</strong></li>
<li>加载扩展类和应用程序类加载器，并作为他们的父类加载器（当他俩的爹）</li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为<strong>java、javax、sun</strong>等开头的类</li>
</ul>
</li>
</ul>
<h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><blockquote>
<p>扩展类加载器（Extension ClassLoader）</p>
</blockquote>
<ul>
<li>Java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现<ul>
<li>派生于<code>ClassLoader</code>类</li>
<li>父类加载器为启动类加载器</li>
<li>从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或从JDK的安装目录的 jre / lib / ext子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
</li>
</ul>
<h4 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h4><blockquote>
<p>应用程序类加载器（系统类加载器，AppClassLoader）</p>
</blockquote>
<ul>
<li>Java语言编写，由<code>sun.misc.LaunchersAppClassLoader</code>实现</li>
<li>派生于<code>ClassLoader</code>类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量 <code>classpath</code> 或 系统属性<code>java.class.path</code>指定路径下的类库</li>
<li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载的</li>
<li>通过<code>classLoader.getSystemclassLoader( )</code>方法可以获取到该类加载器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"**********启动类加载器**************"</span>);</span><br><span class="line">        <span class="comment">//获取BootstrapClassLoader能够加载的api的路径</span></span><br><span class="line">        URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL element : urLs) &#123;</span><br><span class="line">            System.out.println(element.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span></span><br><span class="line">        ClassLoader classLoader = Provider<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(classLoader); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"***********扩展类加载器*************"</span>);</span><br><span class="line">        String extDirs = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String path : extDirs.split(<span class="string">";"</span>)) &#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span></span><br><span class="line">        ClassLoader classLoader1 = CurveDB<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">**********启动类加载器**************</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/resources.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/rt.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/sunrsasign.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/jsse.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/jce.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/charsets.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/jfr.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/classes</span><br><span class="line">null</span><br><span class="line">***********扩展类加载器*************</span><br><span class="line">/Users/xiexu/Library/Java/Extensions:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@d716361</span><br></pre></td></tr></table></figure>

<h3 id="加载器的执行流程图"><a href="#加载器的执行流程图" class="headerlink" title="加载器的执行流程图"></a>加载器的执行流程图</h3><p><img src="/images/java/jvm/%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="加载器执行流程.png"></p>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><blockquote>
<p>为什么需要自定义类加载器？</p>
</blockquote>
<p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p>
<ul>
<li>那为什么还需要自定义类加载器？<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ul>
</li>
</ul>
<blockquote>
<p>如何自定义类加载器？</p>
</blockquote>
<ul>
<li>开发人员可以通过继承抽象类<code>java.lang.ClassLoader</code>类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在JDK1.2之前，在自定义类加载器时，总会去继承<code>ClassLoader</code>类并重写<code>loadClass( )</code>方法，从而实现自定义的类加载类，但是在JDK1.2之后已<strong>不再建议</strong>用户去覆盖<code>loadClass( )</code>方法，而是<strong>建议</strong>把自定义的类加载逻辑写在<code>findclass( )</code>方法中</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以<strong>直接继承<code>URIClassLoader</code></strong>类，这样就可以避免自己去编写<code>findclass( )</code>方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li>
</ul>
<h3 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h3><p>ClassLoader类，它是一个<code>抽象类</code>，其后所有的类加载器都继承自ClassLoader（<code>不包括启动类加载器</code>）</p>
<table>
<thead>
<tr>
<th><strong>方法名称</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>getParent( )</td>
<td>返回该类加载器的超类加载器</td>
</tr>
<tr>
<td>loadClass(String name)</td>
<td>加载名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>findClass(String name)</td>
<td>查找名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>findLoadedClass(String name)</td>
<td>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>defineClass(String name,byte[ ] b,int len)</td>
<td>把字节数组b中的内容转换为一个Java类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>resolveClass(Class&lt;?&gt; c)</td>
<td>连接指定的一个Java类</td>
</tr>
</tbody></table>
<ul>
<li>sun.misc.Launcher 它是一个java虚拟机的入口应用</li>
</ul>
<h4 id="获取-ClassLoader-的途径"><a href="#获取-ClassLoader-的途径" class="headerlink" title="获取 ClassLoader 的途径"></a>获取 ClassLoader 的途径</h4><p><img src="/images/java/jvm/%E8%8E%B7%E5%8F%96ClassLoader.png" alt="获取ClassLoader.png"></p>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h3 id="双亲委派机制原理"><a href="#双亲委派机制原理" class="headerlink" title="双亲委派机制原理"></a>双亲委派机制原理</h3><ul>
<li>Java虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存中生成 class 对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式<ul>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
<li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li>
</ul>
</li>
</ul>
<p><img src="/images/java/jvm/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png" alt="双亲委派机制.png"></p>
<p>举例一：</p>
<blockquote>
<p>我们自己定义一个java.lang包，在其下面定义一个String类，里面声明了静态代码块</p>
<p>在一个测试类中加载String类</p>
<p>结果：程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 String 类</p>
</blockquote>
<p>举例二：</p>
<blockquote>
<p>在我们自己定义的 String 类中整个 main( ) 方法</p>
<p>结果：报错，找不到 main 方法</p>
</blockquote>
<p><strong>原因：由于双亲委派机制，我们的String类是由引导类加载器加载的，而引导类加载器并没有main方法，所以会报错</strong></p>
<p>举例三：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShkStart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/java/jvm/java.lang.ShkStart.png" alt="java.lang.ShkStart.png"></p>
<p><strong>出于保护机制，java.lang 包下不允许我们自定义类</strong></p>
<h3 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h3><ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改<ul>
<li>自定义类：java.lang.String 没有调用</li>
<li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li>
</ul>
</li>
</ul>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><ul>
<li>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。</li>
<li>这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote>
<p>如何判断两个class对象是否相同？</p>
</blockquote>
<ul>
<li>在JVM中表示两个class对象是否为同一个类存在两个必要条件：<ul>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的 ClassLoader（指ClassLoader实例对象）必须相同</li>
</ul>
</li>
<li>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的</li>
</ul>
<blockquote>
<p>对类加载器的引用</p>
</blockquote>
<ul>
<li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li>
<li>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</li>
<li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</li>
</ul>
<blockquote>
<p>类的主动使用和被动使用</p>
</blockquote>
<p>Java程序对类的使用方式分为：<strong>主动使用</strong> 和 <strong>被动使用</strong>。</p>
<ul>
<li>主动使用，又分为七种情况：<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（ 比如：Class.forName(“cn.sxt.Test”) )</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li>
</ul>
</li>
<li>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit( ) 方法和 init( ) 方法）</li>
</ul>
<h1 id="运行时数据区及线程"><a href="#运行时数据区及线程" class="headerlink" title="运行时数据区及线程"></a>运行时数据区及线程</h1><blockquote>
<p>当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们的运行时数据区</p>
</blockquote>
<p><img src="/images/java/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="运行时数据区.png"></p>
<p><img src="/images/java/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA2.png" alt="运行时数据区2.png"></p>
<h2 id="运行时数据区与内存"><a href="#运行时数据区与内存" class="headerlink" title="运行时数据区与内存"></a>运行时数据区与内存</h2><ul>
<li>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中<strong>内存申请、分配、管理</strong>的策略，保证了JVM的高效稳定运行。</li>
<li><strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</li>
<li>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</li>
</ul>
<h2 id="线程的内存空间"><a href="#线程的内存空间" class="headerlink" title="线程的内存空间"></a>线程的内存空间</h2><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机的退出而销毁。<code>另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</code></p>
<p>灰色的为<code>单独线程私有的</code>，红色的为<code>多个线程共享的</code>。即：</p>
<ul>
<li><p>线程独有：独立包括<code>程序计数器</code>、<code>栈</code>、<code>本地方法栈</code></p>
</li>
<li><p>线程间共享：<code>堆</code>、<code>堆外内存（永久代或元空间、代码缓存）</code></p>
</li>
</ul>
<p><img src="/images/java/jvm/%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B7%A5%E4%BD%9C%E5%8C%BA.png" alt="线程运行时工作区.png"></p>
<blockquote>
<p><code>每个JVM只有一个Runtime实例</code>。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p>
</blockquote>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="JVM线程"><a href="#JVM线程" class="headerlink" title="JVM线程"></a>JVM线程</h3><ul>
<li><p>线程是一个程序里的运行单元。<code>JVM允许一个应用有多个线程并行的执行</code></p>
</li>
<li><p><code>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射</code></p>
<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li>
</ul>
</li>
<li><p>操作系统负责将线程安排调度到任何一个可用的CPU上。<code>一旦本地线程初始化成功，它就会调用Java线程中的run( )方法</code></p>
</li>
<li><p>如果一个线程抛异常，并且该线程是进程中最后一个非守护线程，那么进程将停止</p>
</li>
</ul>
<h3 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h3><ul>
<li><p>主要的后台系统线程在Hotspot JVM里主要是以下几个：</p>
</li>
<li><p><strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</p>
</li>
<li><p><strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</p>
</li>
<li><p><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持（重点）</p>
</li>
<li><p><strong>编译线程</strong>：这种线程在运行时会将字节码编译成 本地代码</p>
</li>
<li><p><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</p>
</li>
</ul>
<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="PC-寄存器介绍"><a href="#PC-寄存器介绍" class="headerlink" title="PC 寄存器介绍"></a>PC 寄存器介绍</h2><ul>
<li><p>JVM中的程序计数寄存器（Program Counter Register），Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。</p>
</li>
<li><p>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p>
</li>
<li><p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p>
</li>
<li><p><code>在JVM规范中，每个线程都有它自己的程序计数器</code>，是线程私有的，<code>生命周期与线程的生命周期保持一致</code>。</p>
</li>
<li><p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，<code>如果是在执行native方法，则是未指定值（undefined）</code>。</p>
</li>
<li><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p>
</li>
<li><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
</li>
<li><p>它是唯一一个在Java虚拟机规范中没有规定任何<code>OutofMemoryError</code>情况的区域。</p>
</li>
</ul>
<h2 id="PC-寄存器的作用"><a href="#PC-寄存器的作用" class="headerlink" title="PC 寄存器的作用"></a>PC 寄存器的作用</h2><blockquote>
<p>PC寄存器用来存储指向下一条指令的地址，也就是即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。</p>
</blockquote>
<p><img src="/images/java/jvm/pc%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="pc寄存器的作用.png"></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line"></span><br><span class="line">        String s = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左边的数字代表指令地址 (偏移地址)，即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令</p>
<p><img src="/images/java/jvm/pc%E5%AF%84%E5%AD%98%E5%99%A8%E4%BE%8B%E5%AD%90.png" alt="pc寄存器例子.png"></p>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><blockquote>
<p> 使用 PC寄存器 存储字节码指令地址有什么用呢？/ 为什么使用 PC寄存器 来记录当前线程的执行地址呢？</p>
</blockquote>
<ul>
<li><p>因为线程是一个个的顺序执行流，CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</p>
</li>
<li><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</p>
</li>
</ul>
<blockquote>
<p> PC寄存器为什么被设定为私有的？</p>
</blockquote>
<ul>
<li><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令，这样会导致经常中断或恢复。</p>
</li>
<li><p><strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</strong></p>
</li>
</ul>
<h2 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h2><ul>
<li><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>
</li>
<li><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p>
</li>
<li><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行</p>
</li>
</ul>
<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h2><p>由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。 <strong>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</strong></p>
<p>有不少 Java 开发人员一提到 Java 内存结构，就会非常粗粒度地将 JVM 中的内存区理解为仅有 Java 堆（heap）和 Java 栈（stack）？为什么？</p>
<p>首先<strong>栈是运行时的单位，而堆是存储的单位</strong></p>
<ul>
<li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li>
<li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li>
</ul>
<h3 id="Java-虚拟机栈是什么"><a href="#Java-虚拟机栈是什么" class="headerlink" title="Java 虚拟机栈是什么"></a>Java 虚拟机栈是什么</h3><p>Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用。</p>
<ul>
<li>是线程私有的</li>
</ul>
<p><img src="/images/java/jvm/java%E6%A0%88%E7%BB%93%E6%9E%84.png" alt="java栈结构.png"></p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
<blockquote>
<p>局部变量，它是相比于成员变量来说的（或属性）</p>
<p>基本数据类型变量 VS 引用类型变量（类、数组、接口）</p>
</blockquote>
<h3 id="栈的特点（优点）"><a href="#栈的特点（优点）" class="headerlink" title="栈的特点（优点）"></a>栈的特点（优点）</h3><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。JVM 直接对 Java 栈的操作只有两个：</p>
<ul>
<li><p>每个方法执行，伴随着进栈（入栈、压栈）</p>
</li>
<li><p>执行结束后的出栈工作</p>
</li>
<li><p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p>
</li>
</ul>
<h3 id="栈中可能出现的异常"><a href="#栈中可能出现的异常" class="headerlink" title="栈中可能出现的异常"></a>栈中可能出现的异常</h3><p>Java 虚拟机规范允许 <strong>Java 栈的大小是动态的或者是固定不变的。</strong></p>
<ol>
<li><p>如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常。</p>
</li>
<li><p>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 <strong>OutOfMemoryError</strong> 异常。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抛出异常：Exception in thread "main" java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">//程序不断地进行递归调用，而且没有退出条件，就会导致不断地进行压栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    show(a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.StackOverflowError</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(count++);</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="images/java/jvm/java.lang.StackOverflowError.png" alt="java.lang.StackOverflowError.png"></p>
<h3 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h3><p>我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1k</span><br></pre></td></tr></table></figure>

<h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><ul>
<li>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</li>
<li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li>
</ul>
<blockquote>
<p>OOP 的基本概念：类和对象</p>
<p>类中基本结构：field（属性、字段、域）、method</p>
</blockquote>
<h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><ul>
<li>JVM 直接对 Java 栈的操作只有两个，就是对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，<strong>遵循“先进后出”/“后进先出”原则</strong>。</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong>。</li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li>
</ul>
<p><img src="/images/java/jvm/%E6%A0%88%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.png" alt="栈运行原理.png"></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackFrameTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法1的开始"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = method02();</span><br><span class="line">        System.out.println(<span class="string">"方法1的结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法2的开始"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = method03();</span><br><span class="line">        System.out.println(<span class="string">"方法2的结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法3的开始"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">30</span>;</span><br><span class="line">        System.out.println(<span class="string">"方法3的结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">方法1的开始</span><br><span class="line">方法2的开始</span><br><span class="line">方法3的开始</span><br><span class="line">方法3的结束</span><br><span class="line">方法2的结束</span><br><span class="line">方法1的结束</span><br></pre></td></tr></table></figure>

<p>满足栈先进后出的概念，通过 Idea 的 DEBUG ，能够看到栈信息</p>
<p><img src="images/java/jvm/idea%E4%B8%ADdebug%E7%9A%84%E6%A0%88%E4%BF%A1%E6%81%AF.png" alt="idea中debug的栈信息.png"></p>
<p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
<p>Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</strong></p>
<h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p>
<ul>
<li><strong>局部变量表（Local Variables）</strong></li>
<li><strong>操作数栈（Operand Stack）（或表达式栈）</strong></li>
<li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<blockquote>
<p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p>
</blockquote>
<p><img src="/images/java/jvm/%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="栈帧的内部结构.png"></p>
<p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，<strong>栈帧的大小主要由局部变量表和操作数栈决定的</strong>。 </p>
<p><img src="/images/java/jvm/%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E4%BE%8B%E5%AD%90.png" alt="栈帧的内部结构例子.png"></p>
<h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>局部变量表：Local Variables，被称之为局部变量数组或本地变量表</p>
<p>定义为一个数字数组，<strong>主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及 returnAddress 类型。</p>
<p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></p>
<p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的 Code 属性的 Maximum Local Variables 数据项中。在方法运行期间是不会改变局部变量表的大小的。</p>
<p><strong>方法嵌套调用的次数由栈的大小决定</strong>。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p>
<p><strong>局部变量表中的变量只在当前方法调用中有效。</strong>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</strong>。</p>
<h3 id="关于-Slot-的理解"><a href="#关于-Slot-的理解" class="headerlink" title="关于 Slot 的理解"></a>关于 Slot 的理解</h3><p>参数值的存放总是在局部变量数组的 index0 开始，到数组长度-1的索引结束。</p>
<p>局部变量表，最基本的存储单元是 Slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference）、returnAddress 类型的变量。</p>
<p>在局部变量表里，<strong>32 位以内的类型只占用一个 Slot</strong>（包括 returnAddress 类型），64 位的类型（long 和 double）占用两个 Slot。</p>
<ul>
<li><strong>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true。</strong></li>
<li><strong>long 和 double 则占据两个 Slot。</strong></li>
</ul>
<p>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</p>
<p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序</strong>被复制到局部变量表中的每一个 Slot 上。</p>
<p>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可。（比如：访问 long 或double 类型变量）</p>
<p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，其余的参数按照参数表顺序继续排列。</p>
<p><img src="/images/java/jvm/slot%E7%A4%BA%E4%BE%8B.png" alt="slot示例.png"></p>
<h3 id="Slot-的重复利用"><a href="#Slot-的重复利用" class="headerlink" title="Slot 的重复利用"></a>Slot 的重复利用</h3><p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。</p>
<p><img src="/images/java/jvm/slot%E5%A4%8D%E7%94%A8.png" alt="slot复用.png"></p>
<h3 id="举例：静态变量与局部变量的对比"><a href="#举例：静态变量与局部变量的对比" class="headerlink" title="举例：静态变量与局部变量的对比"></a>举例：静态变量与局部变量的对比</h3><p>变量的分类：</p>
<ul>
<li>按数据类型分：基本数据类型、引用数据类型</li>
<li>按类中声明的位置分：成员变量（类变量，实例变量）、局部变量<ul>
<li>类变量：linking 的 prepare 阶段，给类变量默认赋值，init 阶段给类变量显示赋值即静态代码块</li>
<li>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值</li>
<li>局部变量：在使用前必须进行显式赋值，不然编译不通过。</li>
</ul>
</li>
</ul>
<p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p>
<p>类变量表有两次初始化的机会，第一次是在“<strong>准备阶段</strong>”，执行系统初始化，对类变量设置零值，另一次则是在“<strong>初始化</strong>”阶段，赋予程序员在代码中定义的初始值。</p>
<p><strong>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</strong></p>
<p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p>
<p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</strong></p>
<h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>操作数栈：Operand Stack</p>
<p>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）<em>的操作数栈，也可以称之为</em> <strong>表达式栈</strong>。（Expression Stack）</p>
<p><strong>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</strong></p>
<ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。</li>
<li>比如：执行复制、交换、求和等操作。</li>
</ul>
<p><img src="/images/java/jvm/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BE%8B%E5%AD%90.png" alt="操作数栈例子.png"></p>
<p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong></p>
<p>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这个方法的操作数栈是空的</strong>。</p>
<p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在<strong>编译期</strong>就定义好了，保存在方法的Code 属性中，为 <code>max_stack</code> 的值。</p>
<p>栈中的任何一个元素都是可以任意的 Java 数据类型</p>
<ul>
<li>32bit 的类型占用一个栈单位深度</li>
<li>64bit 的类型占用两个栈单位深度</li>
</ul>
<p><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，</strong>并更新 PC 寄存器中下一条需要执行的字节码指令。</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p>
<p>另外，我们说 Java 虚拟机的<strong>解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</p>
<h3 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h3><p>我们给定代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> i = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> k = i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 javap 命令反编译 class 文件： <strong>javap -v 类名.class</strong></p>
<p><img src="/images/java/jvm/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90.png" alt="操作数栈代码例子.png"></p>
<blockquote>
<p>byte、short、char、boolean 内部都是使用 int 型来进行保存的</p>
<p>同时使用的是 iadd 方法进行相加操作，i -&gt; 代表的就是 int，也就是 int 类型的加法操作</p>
</blockquote>
<p>执行流程如下所示：</p>
<p>首先执行第一条语句，PC 寄存器指向的是 0，也就是指令地址为 0，然后使用 bipush 让操作数 15 入栈。</p>
<p><img src="/images/java/jvm/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA1.png" alt="操作数栈代码追踪1.png"></p>
<p>执行完后，让 PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表 1 的位置，我们可以看到局部变量表的已经增加了一个元素。</p>
<p><img src="/images/java/jvm/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA2.png" alt="操作数栈代码追踪2.png"></p>
<blockquote>
<p>为什么局部变量表不是从 0 开始的呢？</p>
<p>其实局部变量表也是从 0 开始的，但是因为 0 号位置存储的是 this 指针，所以说就直接省略了。</p>
</blockquote>
<p>然后 PC + 1，指向的是下一行。让操作数 8 也入栈，同时执行 istore 操作，存入局部变量表中。</p>
<p><img src="/images/java/jvm/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA3.png" alt="操作数栈代码追踪3.png"></p>
<p><img src="/images/java/jvm/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA4.png" alt="操作数栈代码追踪4.png"></p>
<p>然后从局部变量表中，依次将数据放在操作数栈中。</p>
<p><img src="/images/java/jvm/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA5.png" alt="操作数栈代码追踪5.png"></p>
<p><img src="/images/java/jvm/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA6.png" alt="操作数栈代码追踪6.png"></p>
<p>然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表 3 的位置。</p>
<p><img src="/images/java/jvm/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA7.png" alt="操作数栈代码追踪7.png"></p>
<p><img src="/images/java/jvm/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA8.png" alt="操作数栈代码追踪8.png"></p>
<p>最后 PC 寄存器的位置指向 10，也就是 return 方法，则直接退出方法。</p>
<h2 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h2><p>栈顶缓存技术：Top Of Stack Cashing</p>
<p>前面提过，<strong>基于栈式架构的虚拟机所使用的零地址指令更加紧凑</strong>，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（Instruction Dispatch）次数和内存读/写次数。</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></p>
<blockquote>
<p>寄存器：指令更少，执行速度快</p>
</blockquote>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>动态链接：Dynamic Linking</p>
<p><strong>每个栈桢包含了指向该方法所在类的运行时常量池的指针</strong>，包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态链接（Dynamic Linking）</strong>。比如：invokedynamic 指令</p>
<p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的常量池里。</p>
<p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</strong></p>
<p><img src="/images/java/jvm/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.png" alt="动态链接.png"></p>
<blockquote>
<p>为什么需要运行时常量池？</p>
<p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间</p>
<p>常量池的作用，就是为了提供一些符号和常量，便于指令的识别</p>
</blockquote>
<h2 id="方法调用：解析与分配"><a href="#方法调用：解析与分配" class="headerlink" title="方法调用：解析与分配"></a>方法调用：解析与分配</h2><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>当一个字节码文件被装载进 JVM 内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p>
<h4 id="动态链接-1"><a href="#动态链接-1" class="headerlink" title="动态链接"></a>动态链接</h4><p>如果<strong>被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p>
<h3 id="绑定机制"><a href="#绑定机制" class="headerlink" title="绑定机制"></a>绑定机制</h3><p>对应方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</strong></p>
<h4 id="早期绑定"><a href="#早期绑定" class="headerlink" title="早期绑定"></a>早期绑定</h4><p>早期绑定就是指被调用的<strong>目标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
<h4 id="晚期绑定"><a href="#晚期绑定" class="headerlink" title="晚期绑定"></a>晚期绑定</h4><p>如果<strong>被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p>
<h3 id="早晚期绑定的发展历史"><a href="#早晚期绑定的发展历史" class="headerlink" title="早晚期绑定的发展历史"></a>早晚期绑定的发展历史</h3><p>随着高级语言的横空出世，类似于 Java 一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然<strong>这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式</strong>。</p>
<p>Java 中任何一个普通的方法其实都具备虚函数的特征，它们相当于 C++ 语言中的虚函数（C++ 中则需要使用关键字 virtual 来显式定义）。如果在 Java 程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字 final 来标记这个方法。</p>
<h3 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h3><ul>
<li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li>
<li>静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法。</li>
<li>其他方法称为虚方法。</li>
</ul>
<p>虚拟机中提供了以下几条方法调用指令：</p>
<h4 id="普通调用指令"><a href="#普通调用指令" class="headerlink" title="普通调用指令"></a>普通调用指令</h4><ul>
<li><strong>invokestatic：调用静态方法，解析阶段确定唯一方法版本</strong></li>
<li><strong>invokespecial：调用 方法、私有及父类方法，解析阶段确定唯一方法版本</strong></li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ul>
<h4 id="动态调用指令"><a href="#动态调用指令" class="headerlink" title="动态调用指令"></a>动态调用指令</h4><ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定方法版本。其中 <strong>invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的（final 修饰的除外）称为虚方法。</strong></p>
<h3 id="invokednamic-指令"><a href="#invokednamic-指令" class="headerlink" title="invokednamic 指令"></a>invokednamic 指令</h3><p>JVM 字节码指令集一直比较稳定，一直到 Java 7 中才增加了一个 invokedynamic 指令，这是 <strong>Java 为了实现动态类型语言支持而做的一种改进。</strong></p>
<p>但是在 Java 7 中并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生invokedynamic 指令。<strong>直到 Java 8 的 Lambda 表达式的出现，invokedynamic 指令的生成，在 Java 中才有了直接的生成方式。</strong></p>
<p>Java 7 中增加的动态语言类型支持的本质是对 Java 虚拟机规范的修改，而不是对 Java 语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 Java 平台的动态语言的编译器。</p>
<h3 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h3><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>说的再直白一点就是，<strong>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</strong>，这是动态语言的一个重要特征。</p>
<h3 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h3><h4 id="Java-语言中方法重写的本质："><a href="#Java-语言中方法重写的本质：" class="headerlink" title="Java 语言中方法重写的本质："></a>Java 语言中方法重写的本质：</h4><ul>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。</li>
<li>如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.illegalAccessError 异常。</li>
<li>否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodserror 异常。</li>
</ul>
<h4 id="IllegalAccessError-介绍"><a href="#IllegalAccessError-介绍" class="headerlink" title="IllegalAccessError 介绍"></a>IllegalAccessError 介绍</h4><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
<h3 id="方法的调用：虚方法表"><a href="#方法的调用：虚方法表" class="headerlink" title="方法的调用：虚方法表"></a>方法的调用：虚方法表</h3><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，<strong>为了提高性能</strong>，JVM 采用在类的方法区建立一个虚方法表 <strong>（Virtual Method Table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</strong></p>
<p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p>
<p>虚方法表是什么时候被创建的呢？</p>
<p><strong>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</strong></p>
<p><img src="/images/java/jvm/%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8%E7%A4%BA%E4%BE%8B.png" alt="虚方法表示例.png"></p>
<p>如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到 Object的方法中。</p>
<h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>存放调用该方法的 PC 寄存器的值。一个方法的结束，有两种方式：</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
<p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。</p>
<blockquote>
<p><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p>
</blockquote>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令（return），会将返回值传递给上层的方法调用者，简称<strong>正常完成出口；</strong><ul>
<li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含 ireturn（当返回值是 boolean，byte，char，short 和 int 类型时使用），lreturn（Long 类型），freturn（Float 类型），dreturn（Double 类型），areturn（引用类型）。另外还有一个 return 指令声明为 void 的方法，实例初始化方法，类和接口的初始化方法使用。</li>
</ul>
</li>
<li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的<strong>异常表(字节码中的Exception Table)</strong>中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口。</strong></li>
</ol>
<p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p>
<p><img src="/images/java/jvm/%E5%BC%82%E5%B8%B8%E8%A1%A8.png" alt="异常表.png"></p>
<h2 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h2><p><img src="/images/java/jvm/%E6%A0%88%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF.png" alt="栈附加信息.png"></p>
<p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>
<h2 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h2><ul>
<li>举例栈溢出的情况？（StackOverflowError）<ul>
<li>通过 -Xss 设置栈的大小</li>
</ul>
</li>
<li>调整栈大小，就能保证不出现溢出么？<ul>
<li>不能保证不溢出</li>
</ul>
</li>
<li>分配的栈内存越大越好么？<ul>
<li>不是，一定时间内降低了 OOM 概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li>
</ul>
</li>
<li>垃圾回收是否涉及到虚拟机栈？<ul>
<li>不会</li>
</ul>
</li>
<li>方法中定义的局部变量是否线程安全？<ul>
<li>具体问题具体分析<ul>
<li>局部变量与其他线程可以共享时线程不安全：如传入的对象</li>
</ul>
</li>
<li>总结一句话就是：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li>
</ul>
</li>
</ul>
<ul>
<li>运行时数据区，是否存在 Error 和 GC ？</li>
</ul>
<table>
<thead>
<tr>
<th>运行时数据区</th>
<th>是否存在 Error</th>
<th>是否存在 GC</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>方法区</td>
<td>是（OOM）</td>
<td>是</td>
</tr>
<tr>
<td>堆</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><h2 id="什么是本地方法？"><a href="#什么是本地方法？" class="headerlink" title="什么是本地方法？"></a>什么是本地方法？</h2><p>简单地讲，<strong>一个 Native Method 是一个 Java 调用非 Java 代码的接囗</strong>。一个 Native Method 是这样一个 Java 方法：该方法的实现由非 Java 语言实现，比如 C。这个特征并非 Java 所特有，很多其它的编程语言都有这一机制，比如在 C++ 中，你可以用 extern “c” 告知 C++ 编译器去调用一个 C 的函数。</p>
<p>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非 Java 的方法，它的具体实现是非 Java 代码的实现）</p>
<p>在定义一个 Native Method 时，并不提供实现体（有些像定义一个 Java interface），因为其实现体是由非 Java 语言在外面实现的。</p>
<p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++ 程序。</p>
<p><img src="/images/java/jvm/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3.png" alt="本地方法接口.png"></p>
<p>代码举例说明 Native 方法是如何编写的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IhaveNatives</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">private</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Natives</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是：标识符 native 可以与其它 Java 标识符连用，但是 abstract 除外</p>
</blockquote>
<h2 id="为什么使用-Native-Method-？"><a href="#为什么使用-Native-Method-？" class="headerlink" title="为什么使用 Native Method ？"></a>为什么使用 Native Method ？</h2><p>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<h3 id="与-Java-环境的交互"><a href="#与-Java-环境的交互" class="headerlink" title="与 Java 环境的交互"></a>与 Java 环境的交互</h3><p><strong>有时 Java 应用需要与 Java 外面的环境交互，这是本地方法存在的主要原因。</strong>你可以想想 Java 需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。<strong>本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解 Java 应用之外的繁琐的细节。</strong></p>
<h3 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h3><p>JVM 支持着 Java 语言本身和运行时库，它是 Java 程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。<strong>通过使用本地方法，我们得以用 Java 实现了 jre 的与底层系统的交互，甚至 JVM 的一些部分就是用 C 写的。</strong>还有，如果我们要使用一些 Java 语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p>
<h3 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s Java"></a>Sun’s Java</h3><p><strong>Sun 的解释器是用 C 实现的，这使得它能像一些普通的 C 一样与外部交互。</strong>jre 大部分是用 Java 实现的，它也通过一些本地方法与外界交互。例如：类 java.lang.Thread 的 setPriority() 方法是用 Java 实现的，但是它实现调用的是该类里的本地方法 setPriority0()。这个本地方法是用 C 实现的，并被植入 JVM 内部，在 Windows 95 的平台上，这个本地方法最终将调用 Win32 setPriority() API。这是一个本地方法的具体实现由 JVM 直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被 JVM 调用。</p>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p><strong>目前该方法使用的越来越少了，除非是与硬件有关的应用</strong>，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等等，不多做介绍。</p>
<h1 id="本地方法栈-Native-Method-Stack"><a href="#本地方法栈-Native-Method-Stack" class="headerlink" title="本地方法栈(Native Method Stack)"></a>本地方法栈(Native Method Stack)</h1><p>Java 虚拟机栈用于管理 Java 方法的调用，而<strong>本地方法栈用于管理本地方法的调用</strong>。</p>
<p>本地方法栈，也是线程私有的。</p>
<p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</li>
</ul>
<p>本地方法是使用 C 语言实现的。</p>
<p>它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</p>
<p><img src="/images/java//%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88.png" alt="本地方法栈.png"></p>
<p><strong>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</strong></p>
<ul>
<li>本地方法可以通过本地方法接口来<strong>访问虚拟机内部的运行时数据区。</strong></li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存。</li>
</ul>
<p>并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。</p>
<p>在 HotSpot JVM 中，直接将本地方法栈和虚拟机栈合二为一。</p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的核心概念"><a href="#堆的核心概念" class="headerlink" title="堆的核心概念"></a>堆的核心概念</h2><p>堆和方法区针对一个 JVM 进程来说是唯一的，也就是一个进程只有一个 JVM ，但是进程包含多个线程，他们是共享同一堆和方法区空间的，每个线程各自包含一套程序计数器、本地方法栈和虚拟机栈。</p>
<p><img src="/images/java/jvm/%E5%A0%86%E7%A9%BA%E9%97%B4.png" alt="堆空间.png"></p>
<p>一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。</p>
<p>Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间。</p>
<ul>
<li>堆内存的大小是可以调节的。</li>
</ul>
<p>《Java虚拟机规范》规定，<strong>堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</strong></p>
<p>所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p>
<blockquote>
<p>-Xms10m：最小堆内存</p>
<p>-Xmx10m：最大堆内存</p>
</blockquote>
<p>下图就是使用：Java VisualVM 查看堆空间的内容，通过 jdk/bin 提供的插件</p>
<p>![Java VisualVM查看堆空间.png](/images/java/jvm/Java VisualVM查看堆空间.png)</p>
<p>《Java 虚拟机规范》中对 Java 堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p>
<p>我要说的是：<strong>“几乎”</strong>所有的对象实例都在这里分配内存。——从实际使用角度看的。</p>
<ul>
<li>因为还有一些对象是在<strong>栈上分配</strong>的(逃逸分析-栈上分配)</li>
</ul>
<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
<p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>
<ul>
<li>也就是触发了 GC 的时候，才会进行回收</li>
<li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有 Stop The World</li>
</ul>
<p><strong>堆，是 GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</strong></p>
<p><img src="/images/java/jvm/%E6%A0%88-%E5%A0%86-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%85%B3%E7%B3%BB.png" alt="栈-堆-方法区关系.png"></p>
<h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p>Java 7 及之前堆内存逻辑上分为三部分：新生区+养老区+<strong>永久区</strong></p>
<ul>
<li>Young Generation Space 新生区  Young/New 又被划分为 Eden 区和 Survivor 区</li>
<li>Tenure Generation Space 养老区 Old/Tenure</li>
<li><strong>Permanent Space 永久区 Perm</strong></li>
</ul>
<p>Java 8 及之后堆内存逻辑上分为三部分：新生区+养老区+<strong>元空间</strong></p>
<ul>
<li>Young Generation Space 新生区 Young/New 又被划分为 Eden 区和 Survivor 区</li>
<li>Tenure Generation Space 养老区 Old/Tenure</li>
<li><strong>Meta Space  元空间  Meta</strong></li>
</ul>
<p>约定：新生区  = 新生代 = 年轻代、养老区 = 老年区 = 老年代、永久区 = 永久代</p>
<p><img src="/images/java/jvm/java8%E5%A0%86%E7%A9%BA%E9%97%B4%E5%9B%BE%E7%A4%BA.png" alt="java8堆空间图示.png"></p>
<p>堆空间内部结构，JDK 1.8 时从<strong>永久代</strong>替换成<strong>元空间</strong></p>
<p><img src="/images/java/jvm/java7%E5%88%B0java8%E5%A0%86%E7%A9%BA%E9%97%B4%E6%BC%94%E5%8F%98.png" alt="java7到java8堆空间演变.png"></p>
<h2 id="设置堆内存大小与-OOM"><a href="#设置堆内存大小与-OOM" class="headerlink" title="设置堆内存大小与 OOM"></a>设置堆内存大小与 OOM</h2><p>Java 堆区用于存储 Java 对象实例，那么堆的大小在 JVM 启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p>
<ul>
<li>“-Xms” 用于表示堆区的起始内存，等价于 -XX:InitialHeapSize</li>
<li>“-Xmx” 则用于表示堆区的最大内存，等价于 -XX:MaxHeapSize</li>
</ul>
<p>一旦堆区中的内存大小超过 “-Xmx” 所指定的最大内存时，将会抛出 OutOfMemoryError 异常。</p>
<p>通常会将 -Xms 和 -Xmx 两个参数配置相同的值，其<strong>目的是为了能够在 Java 垃圾回收机制清理完堆区后不需要重新计算堆区的大小，从而提高性能</strong>。</p>
<p>默认情况下：</p>
<ul>
<li><p><strong>初始内存大小：物理电脑内存大小 / 64</strong></p>
</li>
<li><p><strong>最大内存大小：物理电脑内存大小 / 4</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机试图使用的最大堆内存</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        System.out.println(<span class="string">"-Xms:"</span> + initialMemory + <span class="string">"M"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-Xmx:"</span> + maxMemory + <span class="string">"M"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms:245M</span><br><span class="line">-Xmx:3623M</span><br></pre></td></tr></table></figure>

<blockquote>
<p>开发中建议将初始堆内存和最大堆内存设置成相同的值    </p>
</blockquote>
<p>如何查看堆内存的内存分配情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jps  -&gt;  jstat -gc 进程id</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么设置初始堆内存为 600M，实际只有 575M？</p>
<p>答：因为在新生代中，数据存放在 Eden 区和 Survivor 区，其中 Survivor0 和 Survivor1 区只能二选一存放，少了一个25600 / 1024 = 25M。</p>
</blockquote>
<h3 id="OutOfMemory-举例"><a href="#OutOfMemory-举例" class="headerlink" title="OutOfMemory 举例"></a>OutOfMemory 举例</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Picture(<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="number">999999999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">## Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>

<p>然后设置启动参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms10m -Xmx:10m</span><br></pre></td></tr></table></figure>

<p>运行后，就出现 OOM 了，那可以通过 VisualVM 这个工具查看具体是什么参数造成的 OOM。</p>
<h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>存储在 JVM 中的 Java 对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul>
<li>生命周期短的，及时回收即可</li>
</ul>
</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与 JVM 的生命周期保持一致</li>
</ul>
<p>Java 堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）</p>
<p>其中年轻代又可以划分为 Eden 空间、Survivor0 空间和 Survivor1 空间（有时也叫做 From 区、To 区）</p>
<p><img src="/images/java/jvm/%E5%A0%86%E7%A9%BA%E9%97%B4%E7%BB%86%E5%88%86.png" alt="堆空间细分.png"></p>
<p>下面这参数开发中一般不会调：</p>
<p><img src="/images/java/jvm/%E5%A0%86%E7%A9%BA%E9%97%B4%E9%BB%98%E8%AE%A4%E6%AF%94%E4%BE%8B.png" alt="堆空间默认比例.png"></p>
<ul>
<li>Eden : From : To -&gt;  8 : 1 : 1</li>
<li>新生代 : 老年代  -&gt;  1 : 2</li>
</ul>
<p>配置新生代与老年代在堆结构的占比。</p>
<ul>
<li><p>默认-XX:NewRatio=2，表示新生代占 1，老年代占 2，新生代占整个堆的 1/3</p>
</li>
<li><p>可以修改-XX:NewRatio=4，表示新生代占 1，老年代占 4，新生代占整个堆的 1/5</p>
</li>
</ul>
<blockquote>
<p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整老年代的大小，来进行调优</p>
</blockquote>
<p>在 HotSpot 中，Eden 空间和另外两个 Survivor 空间缺省所占的比例是8 : 1 : 1，当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如 -XX:SurvivorRatio=8</p>
<blockquote>
<p>为什么默认是 8:1:1，而实际当中是 6:1:1？</p>
<p>答：因为存在自适应机制，即-XX:-UseAdaptiveSizePolicy(+启用，-禁用)，但这种方法一般不能生效，所以一般采用-XX:SurvivorRatio=8</p>
</blockquote>
<p><strong>几乎所有的</strong> Java 对象都是在 Eden 区被 new 出来的。绝大部分的 Java 对象的销毁都在新生代进行了。（有些大的对象在 Eden 区无法存储时候，将直接进入老年代）</p>
<blockquote>
<p>IBM 公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p>
</blockquote>
<p>可以使用选项”-Xmn”设置新生代最大内存大小(优先级高于-XX:NewRatio)</p>
<blockquote>
<p>这个参数一般使用默认值就可以了。</p>
</blockquote>
<p><img src="/images/java/jvm/%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%A0%86%E4%B8%AD%E7%9A%84%E8%BF%81%E7%A7%BB.png" alt="对象在堆中的迁移.png"></p>
<h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ul>
<li>new 的对象先放伊甸园区。此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到伊甸园区。</li>
<li>然后将伊甸园中的剩余对象移动到幸存者 0 区。</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区的，如果没有回收，就会放到幸存者 1 区。</li>
<li>如果再次经历垃圾回收，此时会重新放回 Survivor0 区，接着再去 Survivor1 区。</li>
<li>啥时候能去养老区呢？可以设置次数。默认是 15 次。<ul>
<li><strong>可以设置参数：-Xx:MaxTenuringThreshold=N 进行设置</strong></li>
</ul>
</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发 GC : Major GC，进行养老区的内存清理</li>
<li>若养老区执行了 Major GC 之后，发现依然无法进行对象的保存，就会产生 OOM 异常。<ul>
<li><code>java.lang.OutOfMemoryError: Java heap space</code></li>
</ul>
</li>
</ul>
<h3 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h3><p>我们创建的对象，一般都是存放在 Eden 区的，当我们 Eden 区满了后，就会触发 GC 操作，一般被称为 YGC / Minor GC 操作</p>
<p><img src="/images/java/jvm/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%9B%BE%E8%A7%A31.png" alt="对象分配图解1.png"></p>
<p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在 S0(Survivor From) 区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是 1。</p>
<p>同时 Eden 区继续存放对象，当 Eden 区再次存满的时候，又会触发一个 MinorGC 操作，此时 GC 将会把 Eden 和 Survivor From 中的对象进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1。</p>
<p><img src="/images/java/jvm/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%9B%BE%E8%A7%A32.png" alt="对象分配图解2.png"></p>
<p>我们继续不断的进行对象生成和垃圾回收，当 Survivor 中的对象的年龄达到 15 的时候，将会触发一次 Promotion 晋升的操作，也就是将年轻代中的对象晋升到老年代中。</p>
<p><img src="/images/java/jvm/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%9B%BE%E8%A7%A33.png" alt="对象分配图解3.png"></p>
<h3 id="思考：幸存区区满了后？"><a href="#思考：幸存区区满了后？" class="headerlink" title="思考：幸存区区满了后？"></a>思考：幸存区区满了后？</h3><p><strong>特别注意，在 Eden 区满了的时候，才会触发 Minor GC，而 Survivor 区满了后，不会触发 Minor GC 操作</strong></p>
<p>如果 Survivor 区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代。</p>
<h3 id="对象分配的特殊情况"><a href="#对象分配的特殊情况" class="headerlink" title="对象分配的特殊情况"></a>对象分配的特殊情况</h3><p><img src="/images/java/jvm/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E5%9B%BE%E7%A4%BA.png" alt="对象分配特殊情况图示.png"></p>
<h3 id="代码演示对象分配过程"><a href="#代码演示对象分配过程" class="headerlink" title="代码演示对象分配过程"></a>代码演示对象分配过程</h3><p>我们不断的创建大对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Test&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Test());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后设置 JVM 参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xms600m -Xmx600m</span><br></pre></td></tr></table></figure>

<p>然后 cmd 输入下面命令，打开 VisualVM 图形化界面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jvisualvm</span><br></pre></td></tr></table></figure>

<p>然后通过执行上面代码，通过 VisualGC 进行动态化查看。</p>
<p><img src="/images/java/jvm/%E5%A4%A7%E5%AF%B9%E8%B1%A1%E6%99%8B%E5%8D%87%E8%BF%87%E7%A8%8B.gif" alt="大对象晋升过程.gif"></p>
<p>最终，在老年代和新生代都满了，就出现 OOM。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.atguigu.java.chapter08.HeapInstanceTest.&lt;init&gt;(HeapInstanceTest.java:13)</span><br><span class="line">	at com.atguigu.java.chapter08.HeapInstanceTest.main(HeapInstanceTest.java:17)</span><br></pre></td></tr></table></figure>

<h3 id="常用的调优工具"><a href="#常用的调优工具" class="headerlink" title="常用的调优工具"></a>常用的调优工具</h3><ul>
<li>JDK命令行</li>
<li>Eclipse：Memory Analyzer Tool</li>
<li>Jconsole</li>
<li>Visual VM（实时监控  推荐~）</li>
<li>Jprofiler（推荐~）</li>
<li>Java Flight Recorder（实时监控）</li>
<li>GCViewer</li>
<li>GCEasy</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>针对幸存者 S0，S1 区的总结：复制之后有交换，谁空谁是 To。</li>
<li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集。</li>
<li>新生代采用复制算法的目的：是为了减少内碎片。</li>
</ul>
<h2 id="Minor-GC，MajorGC、Full-GC"><a href="#Minor-GC，MajorGC、Full-GC" class="headerlink" title="Minor GC，MajorGC、Full GC"></a>Minor GC，MajorGC、Full GC</h2><ul>
<li>Minor GC：新生代的 GC</li>
<li>Major GC：老年代的 GC</li>
<li>Full GC：整堆收集，收集整个 Java 堆和方法区的垃圾收集</li>
</ul>
<blockquote>
<p>我们都知道，JVM 的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现 STW 的问题</p>
<p>而 Major GC 和 Full GC 出现 STW 的时间，是 Minor GC 的10倍以上</p>
</blockquote>
<p>JVM 在进行 GC 时，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。</p>
<p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）。</p>
<p>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：</p>
<ul>
<li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC/Old GC）：只是老年代的圾收集。<ul>
<li>目前，只有 CMS GC 会有单独收集老年代的行为。</li>
<li><strong>注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</strong></li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。<ul>
<li>目前，只有 G1 GC 会有这种行为。</li>
</ul>
</li>
</ul>
<p>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</p>
<h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p><strong>年轻代GC（Minor GC）触发机制：</strong></p>
<ul>
<li><p>当年轻代空间不足时，就会触发 Minor GC，这里的年轻代满指的是 Eden 代满，Survivor 满不会引发 GC。（每次 Minor GC 会清理年轻代的内存。）</p>
</li>
<li><p>因为 Java 对象<strong>大多都具备朝生夕灭</strong>的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p>
</li>
<li><p>Minor GC 会引发 STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</p>
</li>
</ul>
<blockquote>
<p>STW：Stop The World</p>
</blockquote>
<p>![Minor Gc 过程.png](/images/java/jvm/Minor Gc 过程.png)</p>
<h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p><strong>老年代 GC（Major GC/Full GC）触发机制：</strong></p>
<ul>
<li><p>指发生在老年代的 GC ，对象从老年代消失时，我们说 “Major GC” 或 “Full GC” 发生了。</p>
</li>
<li><p>出现了 Major GC ，经常会伴随至少一次的 Minor GC （但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。</p>
<ul>
<li>也就是在老年代空间不足时，会先尝试触发 Minor GC 。如果之后空间还不足，则触发 Major GC。</li>
</ul>
</li>
<li><p>Major GC 的速度一般会比 Minor GC 慢 10 倍以上， STW 的时间更长。</p>
</li>
<li><p>如果 Major GC 后，内存还不足，就报 OOM 了。</p>
</li>
</ul>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>触发 Full GC 执行的情况有如下五种：</p>
<ul>
<li>调用 System.gc() 时，系统建议执行 Full GC ，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存</li>
<li>由 Eden 区、Survivor space0（From Space）区向 Survivor space1（To Space）区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ul>
<p>说明：<strong>Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</strong></p>
<h3 id="GC-举例"><a href="#GC-举例" class="headerlink" title="GC 举例"></a>GC 举例</h3><p>我们编写一个 OOM 的异常，因为我们在不断的创建字符串，是存放在元空间的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String a = <span class="string">"mogu blog"</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.getStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置 JVM 启动参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<p>打印出的日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2038K-&gt;500K(2560K)] 2038K-&gt;797K(9728K), 0.3532002 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.36 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2108K-&gt;480K(2560K)] 2405K-&gt;1565K(9728K), 0.0014069 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2288K-&gt;0K(2560K)] [ParOldGen: 6845K-&gt;5281K(7168K)] 9133K-&gt;5281K(9728K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0058675 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 5281K-&gt;5281K(9728K), 0.0002857 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 5281K-&gt;5263K(7168K)] 5281K-&gt;5263K(9728K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0058564 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 60K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0f138,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 7168K, used 5263K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 73% used [0x00000000ff600000,0x00000000ffb23cf0,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 3514K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 388K, capacity 390K, committed 512K, reserved 1048576K</span><br><span class="line">  </span><br><span class="line">  Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOfRange(Arrays.java:3664)</span><br><span class="line">	at java.lang.String.&lt;init&gt;(String.java:207)</span><br><span class="line">	at java.lang.StringBuilder.toString(StringBuilder.java:407)</span><br><span class="line">	at com.atguigu.java.chapter08.GCTest.main(GCTest.java:20)</span><br></pre></td></tr></table></figure>

<p><strong>触发 OOM 的时候，一定是进行了一次 Full GC ，因为只有在老年代空间不足时候，才会爆出 OOM 异常。</strong></p>
<h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p>为什么要把 Java 堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%~99% 的对象是临时对象。</p>
<ul>
<li>新生代：有 Eden 、两块大小相同的 Survivor（又称为 From/To，S0/S1）构成，To 总为空。</li>
<li>老年代：存放新生代中经历多次 GC 仍然存活的对象。</li>
</ul>
<p>其实不分代完全可以，分代的唯一理由就是<strong>优化 GC 性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。 GC 的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当 GC 的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。对象在 Survivor 区中每熬过一次 Minor GC ，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁，其实每个 JVM 、每个 GC 都有所不同）时，就会被晋升到老年代。</p>
<p>对象晋升老年代的年龄阀值，可以通过选项 <strong>-XX:MaxTenuringThreshold</strong> 来设置。</p>
<p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li><p>优先分配到 Eden</p>
<ul>
<li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发 Major GC 的次数比 Minor GC 要更少，因此可能回收起来就会比较慢</li>
</ul>
</li>
<li><p>大对象直接分配到老年代</p>
<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li><p>长期存活的对象分配到老年代</p>
</li>
<li><p>动态对象年龄判断</p>
<ul>
<li>如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</li>
</ul>
</li>
<li><p>空间分配担保： <strong>-XX:HandlePromotionFailure</strong></p>
<ul>
<li>也就是经过 Minor GC 后，所有的对象都存活，因为 Survivor 比较小，所以就需要将 Survivor 无法容纳的对象，存放到老年代中。</li>
</ul>
</li>
</ul>
<h2 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h2><h3 id="问题：堆空间都是共享的么？"><a href="#问题：堆空间都是共享的么？" class="headerlink" title="问题：堆空间都是共享的么？"></a>问题：堆空间都是共享的么？</h3><p>不一定，因为还有 TLAB 这个概念，在堆中划分出一块区域，为每个<strong>线程</strong>所独占。</p>
<h3 id="为什么有-TLAB？"><a href="#为什么有-TLAB？" class="headerlink" title="为什么有 TLAB？"></a>为什么有 TLAB？</h3><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p>
<ul>
<li><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p>
</li>
<li><p>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p>
</li>
<li><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>
</li>
</ul>
<h3 id="什么是-TLAB"><a href="#什么是-TLAB" class="headerlink" title="什么是 TLAB"></a>什么是 TLAB</h3><ul>
<li><p>从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分， JVM 为<strong>每个线程分配了一个私有缓存区域</strong>，它包含在 Eden 空间内。</p>
</li>
<li><p>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</p>
</li>
<li><p>据我所知所有 OpenJDK 衍生出来的 JVM 都提供了 TLAB 的设计。</p>
</li>
</ul>
<p><img src="/images/java/jvm/TLAB.png" alt="TLAB.png"></p>
<p><strong>说明：</strong></p>
<ul>
<li><p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 <strong>JVM 确实是将 TLAB 作为内存分配的首选</strong>。</p>
</li>
<li><p>在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启 TLAB 空间。</p>
</li>
<li><p>默认情况下，TLAB 空间的内存非常小，<strong>仅占有整个 Eden 空间的 1%</strong>，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置 TLAB 空间所占用 Eden 空间的百分比大小。</p>
</li>
<li><p>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过<strong>使用加锁机制</strong>确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</p>
</li>
</ul>
<h3 id="TLAB分配过程"><a href="#TLAB分配过程" class="headerlink" title="TLAB分配过程"></a>TLAB分配过程</h3><p>对象首先是通过 TLAB 开辟空间，如果不能放入，那么需要通过 Eden 来进行分配。</p>
<p><img src="/images/java/jvm/TLAB%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png" alt="TLAB分配过程.png"></p>
<h2 id="小结堆空间的参数设置"><a href="#小结堆空间的参数设置" class="headerlink" title="小结堆空间的参数设置"></a>小结堆空间的参数设置</h2><ul>
<li><p>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</p>
</li>
<li><p>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p>
</li>
<li><p>-Xms：初始堆空间内存（默认为物理内存的1/64）</p>
</li>
<li><p>-Xmx：最大堆空间内存（默认为物理内存的1/4）</p>
</li>
<li><p>-Xmn：设置新生代的大小。（初始值及最大值）</p>
</li>
<li><p>-XX:NewRatio：配置新生代与老年代在堆结构的占比</p>
</li>
<li><p>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</p>
</li>
<li><p>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</p>
</li>
<li><p>-XX：+PrintGCDetails：输出详细的GC处理日志</p>
<ul>
<li>打印gc简要信息：①-Xx：+PrintGC  ② - verbose:gc</li>
</ul>
</li>
<li><p>-XX:HandlePromotionFalilure：是否设置空间分配担保</p>
</li>
</ul>
<p>在发生 Minor GC 之前，虚拟机会<strong>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong>。</p>
<ul>
<li>如果大于，则此次 Minor GC 是安全的</li>
<li>如果小于，则虚拟机会查看 -XX:HandlePromotionFailure 设置值是否允担保失败。<ul>
<li>如果 HandlePromotionFailure=true ，那么会<strong>继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong>。<ul>
<li>如果大于，则尝试进行一次 Minor GC ，但这次 Minor GC 依然是有风险的；</li>
<li>如果小于，则改为进行一次 Full GC 。</li>
</ul>
</li>
<li>如果 HandlePromotionFailure=false，则改为进行一次 Full GC 。</li>
</ul>
</li>
</ul>
<p>在 JDK 6 Update24 之后，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配担保策略，观察 OpenJDK 中的源码变化，虽然源码中还定义了 HandlePromotionFailure 参数，但是在代码中已经不会再使用它。 JDK6 Update24 之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小</strong>或者<strong>历次晋升的平均大小就会进行 Minor GC</strong> ，否则将进行 Full GC 。</p>
<h2 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h2><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>在《深入理解Java虚拟机》中关于 Java 堆内存有这样一段描述：</p>
<p>随着 JIT 编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换优化技术</strong>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>在 Java 虚拟机中，对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。</strong>这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于 OpenJDK 深度定制的 TaoBao VM ，其中创新的 GCIH（GC Invisible Heap）技术实现Off-Heap，将生命周期较长的 Java 对象从 Heap 中移至 Heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。</p>
<ul>
<li><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
</li>
<li><p>这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p>
</li>
<li><p>通过逃逸分析， Java HotSpot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
</li>
<li><p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
</li>
</ul>
<p>如何快速的判断是否发生了逃逸分析，就看 new 的对象是否在方法外被调用。</p>
<h4 id="逃逸分析举例"><a href="#逃逸分析举例" class="headerlink" title="逃逸分析举例"></a>逃逸分析举例</h4><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p>
<p>针对下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sb逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sb不逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的逃逸分析代码举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span> ? <span class="keyword">new</span> EscapeAnalysis():obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">        <span class="comment">// getInstance().XXX  发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>在 JDK 6u23 版本之后， HotSpot 中默认就已经开启了逃逸分析（HotSpot中逃逸分析是结合标量替换实现的）</p>
<p>如果使用的是较早的版本，开发人员则可以通过：</p>
<ul>
<li>选项 “-XX：+DoEscapeAnalysis” 显式开启逃逸分析</li>
<li>通过选项 “-XX：+PrintEscapeAnalysis” 查看逃逸分析的筛选结果</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><strong>开发中能使用局部变量的，就不要使用在方法外定义。</strong></p>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ul>
<li><strong>栈上分配：</strong>将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配。</li>
<li><strong>同步省略：</strong>如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li><strong>分离对象或标量替换：</strong>有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中。</li>
</ul>
<h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p> JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>
<p>常见的栈上分配的场景：</p>
<blockquote>
<p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p>
</blockquote>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>我们通过举例来说明 开启逃逸分析和未开启逃逸分析时候的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"花费的时间为："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置 JVM 参数，表示未开启逃逸分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<p>运行结果，同时还触发了 GC 操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">花费的时间为：664 ms</span><br></pre></td></tr></table></figure>

<p>然后查看内存的情况，发现有大量的 User 存储在堆中</p>
<p>我们再开启逃逸分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生 GC 操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">花费的时间为：5 ms</span><br></pre></td></tr></table></figure>

<p>然后再看内存情况，我们发现只有很少的 User 对象，说明 User 发生了逃逸，因为他们存储在栈中，随着栈的销毁而消失。</p>
<h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
<p>在动态编译同步块的时候， JIT 编译器可以借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<strong>锁消除</strong>。</p>
<p>例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hellis) &#123;</span><br><span class="line">        System.out.println(hellis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中对 hellis 这个对象加锁，但是 hellis 对象的生命周期只在 f() 方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">	System.out.println(hellis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码阶段仍然保留着同步代码块</p>
<p><img src="/images/java/jvm/%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="同步代码块字节码.png"></p>
<h3 id="分离对象和标量替换"><a href="#分离对象和标量替换" class="headerlink" title="分离对象和标量替换"></a>分离对象和标量替换</h3><p><strong>标量（Scalar）</strong>是指一个无法再分解成更小的数据的数据。 Java 中的原始数据类型就是标量。</p>
<p>相对的，那些还可以分解的数据叫做<strong>聚合量（Aggregate）</strong>， Java 中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JIT 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是<strong>标量替换</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">"point.x"</span> + point.x + <span class="string">";point.y"</span> + point.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，经过标量替换后，就会变成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"point.x = "</span> + x + <span class="string">"; point.y="</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Point 这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br>标量替换为栈上分配提供了很好的基础。</p>
<h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"花费的时间为： "</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码在主函数中进行了 1 亿次 alloc 。调用进行对象创建，由于 User 对象实例需要占据约 16 字节的空间，因此累计分配空间达到将近 1.5GB。如果堆空间小于这个值，就必然会发生 GC 。使用如下参数运行上述代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br></pre></td></tr></table></figure>

<p>这里设置参数如下：</p>
<ul>
<li>参数 -server：启动 Server 模式，因为在 Server 模式下，才可以启用逃逸分析。</li>
<li>参数 -XX:+DoEscapeAnalysis：启用逃逸分析。</li>
<li>参数 -Xmx10m：指定了堆空间最大为 10MB。</li>
<li>参数 -XX:+PrintGC：将打印 GC 日志。</li>
<li>参数 -XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有 id 和 name 两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配。</li>
</ul>
<h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><p>关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK 1.6 才有实现，而且这项技术到如今也并不是十分成熟的。</p>
<p>其根本原因就是<strong>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></p>
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的，那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是它也是<strong>即时编译器优化技术中一个十分重要的手段</strong>。</p>
<p>注意到有一些观点，认为通过逃逸分析， JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。据我所知， Oracle HotSpot JVM 中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p>
<p>目前很多书籍还是基于 JDK 7 以前的版本， JDK 已经发生了很大变化，intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：<strong>对象实例都是分配在堆上</strong>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
</li>
<li><p>老年代放置长生命周期的对象，通常都是从 Survivor 区域筛选拷贝过来的 Java 对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。</p>
</li>
<li><p>当 GC 只发生在年轻代中，回收年轻代对象的行为被称为 Minor GC 。当 GC 发生在老年代时则被称为 Major GC 或者 Full GC。一般的，Minor GC 的发生频率要比 Major GC 高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>
</li>
</ul>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><p><img src="/images/java/jvm/%E6%96%B9%E6%B3%95%E5%8C%BA.png" alt="方法区.png"></p>
<p>从线程共享与否的角度来看</p>
<p><img src="/images/java/jvm/%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB-%E6%96%B9%E6%B3%95%E5%8C%BA.png" alt="线程共享-方法区.png"></p>
<h2 id="栈、堆、方法区的交互关系-1"><a href="#栈、堆、方法区的交互关系-1" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><p>下面就涉及了对象的访问定位</p>
<p><img src="/images/java/jvm/%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png" alt="栈、堆、方法区的交互关系.png"></p>
<ul>
<li>Person：存放在元空间，也可以说方法区</li>
<li>person：存放在 Java 栈的局部变量表中</li>
<li>new Person()：存放在 Java 堆中</li>
</ul>
<h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><p>《Java 虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于 HotSpot JVM 而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。 </p>
<p>所以，<strong>方法区看作是一块独立于 Java 堆的内存空间。</strong></p>
<p><strong>方法区主要存放的是 Class ，而堆中主要存放的是实例化的对象。</strong></p>
<ul>
<li>方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域。</li>
<li>方法区在 JVM 启动的时候被创建，并且它的实际的物理内存空间中和 Java 堆区一样都可以是不连续的（逻辑上连续，物理上可以不连续）。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError：<strong>PermGen space</strong> 或者 java.lang.OutOfMemoryError：<strong>Metaspace</strong><ul>
<li>加载大量的第三方的 jar 包</li>
<li>Tomcat 部署的工程过多（30~50 个）</li>
<li>大量动态的生成反射类</li>
</ul>
</li>
<li>关闭 JVM 就会释放这个区域的内存</li>
</ul>
<h3 id="HotSpot-中方法区的演进"><a href="#HotSpot-中方法区的演进" class="headerlink" title="HotSpot 中方法区的演进"></a>HotSpot 中方法区的演进</h3><p>在 JDK 7 及以前，习惯上把方法区，称为永久代。 JDK 8 开始，使用<strong>元空间</strong>取代了永久代。</p>
<ul>
<li>JDK 1.8 后，元空间存放在堆外内存中（In JDK 8, classes metadata is now stored in the <strong>native heap</strong> and this space is called <strong>Metaspace</strong>.）</li>
</ul>
<p>本质上，方法区和永久代并不等价，仅是对 HotSpot 而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。            </p>
<blockquote>
<p>现在来看，当年使用永久代，不是好的 idea。导致 Java 程序更容易 OOM （超过 -XX:MaxPermsize 上限）</p>
</blockquote>
<p><img src="/images/java/jvm/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9C%A8jdk7%E3%80%81jdk8%E4%B8%AD%E7%9A%84%E6%BC%94%E5%8F%98.png" alt="方法区在jdk7、jdk8中的演变.png"></p>
<p>而到了 JDK 8 ，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在<strong>本地内存</strong>中实现的元空间（Metaspace）来代替。</p>
<p>元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存。</strong></p>
<p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p>
<p>根据《Java 虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OOM 异常。</p>
<h2 id="设置方法区大小与-OOM"><a href="#设置方法区大小与-OOM" class="headerlink" title="设置方法区大小与 OOM"></a>设置方法区大小与 OOM</h2><p>方法区的大小不必是固定的， JVM 可以根据应用的需要动态调整。 </p>
<h3 id="JDK-7-及以前"><a href="#JDK-7-及以前" class="headerlink" title="JDK 7 及以前"></a>JDK 7 及以前</h3><ul>
<li><strong>通过 -XX:PermSize 来设置永久代初始分配空间。默认值是 20.75M</strong></li>
<li><strong>-XX:MaxPermSize 来设定永久代最大可分配空间。32 位机器默认是 64M，64 位机器模式是 82M</strong></li>
<li>当 JVM 加载的类信息容量超过了这个值，会报异常 OutOfMemoryError:PermGen space。</li>
</ul>
<p><img src="/images/java/jvm/jdk7%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95%E5%8C%BA%E8%AE%BE%E7%BD%AE%E5%A4%A7%E5%B0%8F.png" alt="jdk7查看方法区设置大小.png"></p>
<h3 id="JDK-8-以后"><a href="#JDK-8-以后" class="headerlink" title="JDK 8 以后"></a>JDK 8 以后</h3><p>元数据区大小可以使用参数 <strong>-XX:MetaspaceSize</strong> 和 <strong>-XX:MaxMetaspaceSize</strong> 指定。</p>
<p>默认值依赖于平台。<strong>Windows 下，-XX:MetaspaceSize 是 21M，-XX:MaxMetaspaceSize 的值是 -1，即没有限制。</strong></p>
<p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常 OutOfMemoryError:Metaspace。</p>
<p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize 值为 21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 MaxMetaspaceSize 时，适当提高该值。如果释放空间过多，则适当降低该值。</p>
<p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到 Full GC 多次调用。为了避免频繁地 GC ，建议将 -XX:MetaspaceSize 设置为一个相对较高的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OOMTest test = <span class="keyword">new</span> OOMTest();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，public，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">"Class"</span> + i, <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">"Class"</span> + i, code, <span class="number">0</span>, code.length);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>![OutOfMemoryError-Compressed class space.png](/images/java/jvm/OutOfMemoryError-Compressed class space.png)</p>
<h3 id="如何解决这些-OOM"><a href="#如何解决这些-OOM" class="headerlink" title="如何解决这些 OOM"></a>如何解决这些 OOM</h3><ul>
<li><p>要解决 OOM 异常或 Heap Space 的异常，一般的手段是首先通过内存映像分析工具（如 Eclipse Memory Analyzer）对 dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</p>
<ul>
<li>内存泄漏就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和 GC ROOT 有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li>
<li>内存泄漏得不到解决，从而占据满整个内存空间就会造成内存溢出</li>
</ul>
</li>
<li><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及 GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p>
</li>
<li><p>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx 与 -Xms ），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
</li>
</ul>
<h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p><img src="/images/java/jvm/%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="方法区的内部结构.png"></p>
<p>《深入理解 Java 虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</strong></p>
<p><img src="/images/java/jvm/%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%842.png" alt="方法区的内部结构2.png"></p>
<h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：</p>
<ul>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于 interface 或是 java.lang.object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final 的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
<h3 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h3><p>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>
<p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient 的某个子集）</p>
<h3 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h3><p>JVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型（或 void ）</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li>
<li>异常表（abstract 和 native 方法除外）<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
<h3 id="Non-Final-的类变量"><a href="#Non-Final-的类变量" class="headerlink" title="Non-Final 的类变量"></a>Non-Final 的类变量</h3><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p>
<p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello!</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>如上代码所示，即使我们把 order 设置为 null ，也不会出现空指针异常。</p>
<h3 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h3><p>全局常量就是使用 static final 进行修饰</p>
<p>被声明为 final 的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。 </p>
<h3 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h3><p><img src="/images/java/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt="运行时常量池、常量池.png"></p>
<ul>
<li>方法区，内部包含了运行时常量池</li>
<li>字节码文件，内部包含了常量池</li>
<li>要弄清楚方法区，需要理解清楚 ClassFile ，因为加载类的信息都在方法区。</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚 ClassFile 中的常量池。</li>
</ul>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p><img src="/images/java/jvm/%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%9C%A8class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt="常量池在class文件中的位置.png"></p>
<p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。</p>
<h4 id="为什么需要常量池"><a href="#为什么需要常量池" class="headerlink" title="为什么需要常量池"></a>为什么需要常量池</h4><p>一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。</p>
<p>比如：如下的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然上述代码只有 194 字节，但是里面却使用了 String、System、PrintStream 及 Object 等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p>
<h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么"></a>常量池中有什么</h4><p><strong>几种在常量池内存存储的数据类型包括：</strong></p>
<ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<p>例如下面这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Object obj = new Object();</code>将会被翻译成如下字节码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">new <span class="comment">#2  //Class java/lang/Object</span></span><br><span class="line">dup</span><br><span class="line">invokespecial	//Method java/lang/Object <span class="string">"&lt;init&gt;"</span>()V</span><br></pre></td></tr></table></figure>

<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>常量池可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul>
<li><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
</li>
<li><p>常量池表（Constant Pool Table）是 Class 文件的一部分，<strong>用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</strong></p>
</li>
<li><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p>
</li>
<li><p>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过<strong>索引访问</strong>的。</p>
</li>
<li><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p>
<ul>
<li>运行时常量池，相对于 Class 文件常量池的另一重要特征是：<strong>具备动态性</strong>。<ul>
<li>String.intern()</li>
</ul>
</li>
</ul>
</li>
<li><p>运行时常量池类似于传统编程语言中的符号表（Symbol Table），但是它所包含的数据却比符号表要更加丰富一些。</p>
</li>
<li><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛 OutOfMemoryError 异常。</p>
</li>
</ul>
<h2 id="方法区使用举例"><a href="#方法区使用举例" class="headerlink" title="方法区使用举例"></a>方法区使用举例</h2><p>如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> a = x / y;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码执行过程展示</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%B1%95%E7%A4%BA1.png" alt="字节码执行过程展示1.png"></p>
<p>首先现将操作数 500 放入到操作数栈中</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%B1%95%E7%A4%BA2.png" alt="字节码执行过程展示2.png"></p>
<p>然后存储到局部变量表中</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%B1%95%E7%A4%BA3.png" alt="字节码执行过程展示3.png"></p>
<p>然后重复一次，把 100 放入局部变量表中，最后再将变量表中的 500 和 100 取出，进行操作</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%B1%95%E7%A4%BA4.png" alt="字节码执行过程展示4.png"></p>
<p>将 500 和 100 进行一个除法运算，在把结果入栈</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%B1%95%E7%A4%BA5.png" alt="字节码执行过程展示5.png"></p>
<p>在最后就是输出流，需要调用运行时常量池的常量</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%B1%95%E7%A4%BA6.png" alt="字节码执行过程展示6.png"></p>
<p>最后调用 invokevirtual（虚方法调用），然后返回</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%B1%95%E7%A4%BA7.png" alt="字节码执行过程展示7.png"></p>
<p>返回时</p>
<p><img src="/images/java/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%B1%95%E7%A4%BA8.png" alt="字节码执行过程展示8.png"></p>
<p>程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录方法调用后能够正常返回，或者是进行了 CPU 切换后，也能回来到原来的代码进行执行。</p>
<h2 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h2><p>首先明确：只有 HotSpot 才有永久代。BEA JRockit、IBMJ9 等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java 虚拟机规范》管束，并不要求统一。</p>
<p>HotSpot 中方法区的变化：</p>
<table>
<thead>
<tr>
<th align="center">JDK1.6及以前</th>
<th>有永久代，静态变量存储在永久代上</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>JDK1.7</strong></td>
<td><strong>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</strong></td>
</tr>
<tr>
<td align="center"><strong>JDK1.8</strong></td>
<td><strong>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</strong></td>
</tr>
</tbody></table>
<p>JDK 6 的时候</p>
<p><img src="/images/java/jvm/jdk6%E6%96%B9%E6%B3%95%E5%8C%BA.png" alt="jdk6方法区.png"></p>
<p>JDK 7 的时候</p>
<p><img src="/images/java/jvm/jdk7%E6%96%B9%E6%B3%95%E5%8C%BA.png" alt="jdk7方法区.png"></p>
<p>JDK 8 的时候，元空间大小只受物理内存影响</p>
<p><img src="/images/java/jvm/jdk8%E6%96%B9%E6%B3%95%E5%8C%BA.png" alt="jdk8方法区.png"></p>
<h3 id="为什么永久代要被元空间替代？"><a href="#为什么永久代要被元空间替代？" class="headerlink" title="为什么永久代要被元空间替代？"></a>为什么永久代要被元空间替代？</h3><p>JRockit 是和 HotSpot 融合后的结果，因为 JRockit 没有永久代，所以他们不需要配置永久代</p>
<p>随着 Java 8 的到来，HotSpot VM 中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与<strong>堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</strong></p>
<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p>
<ul>
<li>为永久代设置空间大小是很难确定的。</li>
</ul>
<p>在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM 。比如某个实际 Web 工<br>程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p>
<p>“Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space”</p>
<p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。<br>因此，默认情况下，元空间的大小仅受本地内存限制。</p>
<ul>
<li>对永久代进行调优是很困难的。<ul>
<li>主要是为了降低 Full GC</li>
</ul>
</li>
</ul>
<h3 id="StringTable-为什么要调整位置"><a href="#StringTable-为什么要调整位置" class="headerlink" title="StringTable 为什么要调整位置"></a>StringTable 为什么要调整位置</h3><p>JDK 7 中将 StringTable 放到了堆空间中。因为永久代的回收效率很低，在 Full GC 的时候才会触发。而 Full GC 是老年代的空间不足、永久代不足时才会触发。</p>
<p>这就导致 StringTable 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<h3 id="静态变量存放在那里？"><a href="#静态变量存放在那里？" class="headerlink" title="静态变量存放在那里？"></a>静态变量存放在那里？</h3><p>静态引用对应的对象实体始终都存在堆空间</p>
<p>可以使用 <strong>jhsdb.ext</strong>，需要在 JDK 9 的时候才引入的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ObjectHolder staticObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">        ObjectHolder instanceObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ObjectHolder localObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">            System.out.println(<span class="string">"done"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> StaticObjTest.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>staticObj 随着 Test 的类型信息存放在方法区，instanceObj 随着 Test 的对象实例存放在 Java 堆，localObject 则是存放在 foo() 方法栈帧的局部变量表中。 </p>
<p>测试发现：三个对象的数据在内存中的地址都落在 Eden 区范围内，所以结论：只要是对象实例必然会在 Java 堆中分配。</p>
<p>从《Java 虚拟机规范》所定义的概念模型来看，所有 Class 相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java 虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK 7 及其以后版本的 HotSpot 虚拟机选择把静态变量与类型在 Java 语言一端的映射 Class 对象存放在一起，存储于 Java 堆之中，从我们的实验中也明确验证了这一点。</p>
<h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><p>有些人认为方法区（如 HotSpot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK 11 时期的 ZGC 收集器就不支持类卸载）。</p>
<p>一般来说<strong>这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。</strong>但是这部分区域的回收<strong>有时又确实是必要</strong>的。以前 Sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。</p>
<p><strong>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</strong></p>
<p>先来说说方法区内常量池之中主要存放的两大类常量：<strong>字面量和符号引用</strong>。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>HotSpot 虚拟机对常量池的回收策略是很明确的，<strong>只要常量池中的常量没有被任何地方引用，就可以被回收</strong>。</p>
<p>回收废弃常量与回收 Java 堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot 虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbose:class 以及 -XX:+TraceClass-Loading、-XX:+TraceClassUnLoading 查看类加载和卸载信息。</p>
<p>在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/java/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%80%BB%E7%BB%93.png" alt="运行时数据区总结.png"></p>
<h1 id="常见面试题-1"><a href="#常见面试题-1" class="headerlink" title="常见面试题"></a>常见面试题</h1><p>百度<br>三面：说一下 JVM 内存模型吧，有哪些区？分别干什么的？</p>
<p>蚂蚁金服：<br>Java 8 的内存分代改进<br>JVM 内存分哪几个区，每个区的作用是什么？<br>一面：JVM 内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个 Survivor 区？<br>二面：Eden 和 Survior 的比例分配</p>
<p>小米：<br>JVM 内存分区，为什么要有新生代和老年代？</p>
<p>字节跳动：<br>二面：Java 的内存分区<br>二面：讲讲 JVM 运行时数据库区<br>什么时候对象会进入老年代？</p>
<p>京东：<br>JVM 的内存结构，Eden 和 Survivor 比例。<br>JVM 内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为 Eden 和 Survivor 。</p>
<p>天猫：<br>一面：JVM 内存模型以及分区，需要详细到每个区放什么。<br>一面：JVM 的内存模型，Java 8 做了什么改</p>
<p>拼多多：<br>JVM 内存分哪几个区，每个区的作用是什么？</p>
<p>美团：<br>Java 内存分配<br>JVM 的永久代中会发生垃圾回收吗？<br>一面：JVM 内存分区，为什么要有新生代和老年代？</p>
<h1 id="对象实例化内存布局与访问定位"><a href="#对象实例化内存布局与访问定位" class="headerlink" title="对象实例化内存布局与访问定位"></a>对象实例化内存布局与访问定位</h1><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ul>
<li>对象在 JVM 中是怎么存储的？</li>
<li>对象头信息里面有哪些东西？</li>
<li>Java 对象头有什么？</li>
</ul>
<p>从对象创建的方式和步骤开始说</p>
<p><img src="/images/java/jvm/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96.png" alt="对象实例化.png"></p>
<h3 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h3><ul>
<li>new：最常见的方式、单例类中调用 getInstance 的静态类方法，XXXFactory 的静态方法</li>
<li>Class 的 newInstance 方法：在 JDK 9 里面被标记为过时的方法，<strong>因为只能调用空参构造器</strong>，权限必须是 public</li>
<li>Constructor 的 newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器，权限没有要求</li>
<li>使用 clone()：不调用任何的构造器，要求当前的类需要实现 Cloneable 接口中的 clone() 方法</li>
<li>使用反序列化：序列化一般用于 Socket 的网络传输，从文件、网络中获取文件二进制流</li>
<li>第三方库 Objenesis</li>
</ul>
<h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h3><h4 id="判断对象对应的类是否加载、链接、初始化"><a href="#判断对象对应的类是否加载、链接、初始化" class="headerlink" title="判断对象对应的类是否加载、链接、初始化"></a>判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条 new 指令，首先去检查这个指令的参数能否在 Metaspace 的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以 ClassLoader + 包名 + 类名为 Key 进行查找对应的 .class 文件，如果没有找到文件，则抛出 ClassNotFoundException 异常，如果找到，则进行类加载，并生成对应的 Class 对象。</p>
<h4 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4 个字节大小（ long 和 double 是 8 个字节）</p>
<ul>
<li>如果内存规整：使用指针碰撞</li>
</ul>
<blockquote>
<p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p>
<p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是 Serial ，ParNew 这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带 Compact（整理）过程的收集器时，使用指针碰撞。</p>
</blockquote>
<ul>
<li>如果内存不规整：虚拟表需要维护一个列表：空闲列表分配</li>
</ul>
<blockquote>
<p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”。</p>
</blockquote>
<p>说明：选择哪种分配方式由 Java 堆是否规整所决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<h4 id="处理并发问题"><a href="#处理并发问题" class="headerlink" title="处理并发问题"></a>处理并发问题</h4><p>在分配内存空间时，另外一个问题是及时保证 new 对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用了两种方式解决并发问题：</p>
<ul>
<li>CAS（Compare And Swap）失败重试、区域加锁：保证指针更新操作的原子性</li>
<li>TLAB 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一个小块内存，称为本地线程分配缓冲区，（TLAB，Thread Local Allocation Buffer）虚拟机是否使用 TLAB，可以通过 -XX:+/-UseTLAB 参数来设定</li>
</ul>
<h4 id="初始化分配到的内存"><a href="#初始化分配到的内存" class="headerlink" title="初始化分配到的内存"></a>初始化分配到的内存</h4><p>内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头），这一步保证了对象的实例字段在 Java 代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值</p>
<ul>
<li>属性的默认初始化</li>
<li>显示初始化</li>
<li>代码块中的初始化</li>
<li>构造器初始化</li>
<li>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</li>
</ul>
<h4 id="设置对象的对象头"><a href="#设置对象的对象头" class="headerlink" title="设置对象的对象头"></a>设置对象的对象头</h4><p>将对象的所属类（即类的元数据信息）、对象的 HashCode 和对象的 GC 信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于 JVM 实现。</p>
<h4 id="执行-init-方法进行初始化"><a href="#执行-init-方法进行初始化" class="headerlink" title="执行 init 方法进行初始化"></a>执行 init 方法进行初始化</h4><p>在 Java 程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p>
<p>因此一般来说（由字节码中跟随 invokespecial 指令所决定），new 指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p>
<h3 id="对象实例化的过程"><a href="#对象实例化的过程" class="headerlink" title="对象实例化的过程"></a>对象实例化的过程</h3><ol>
<li>加载类元信息</li>
<li>为对象分配内存</li>
<li>处理并发问题</li>
<li>属性的默认初始化（零值初始化）</li>
<li>设置对象头信息</li>
<li>属性的显示初始化、代码块中初始化、构造器中初始化</li>
</ol>
<h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p><img src="/images/java/jvm/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="对象内存布局.png"></p>
<h3 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h3><p>对象头包含了两部分，分别是<strong>运行时元数据（Mark Word）</strong>和<strong>类型指针</strong></p>
<blockquote>
<p>如果是数组，还需要记录数组的长度</p>
</blockquote>
<h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><ul>
<li>哈希值（HashCode）</li>
<li>GC 分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程 ID</li>
<li>偏向时间戳</li>
</ul>
<h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据 InstanceKlass ，确定该对象所属的类型。指向的其实是方法区中存放的类元信息。</p>
<h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段。（包括从父类继承下来的和本身拥有的字段）</p>
<h4 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h4><ul>
<li>相同宽度的字段总是被分配在一起</li>
<li>父类中定义的变量会出现在子类之前</li>
<li>如果 CompactFields 参数为 true（默认为 true），子类的窄变量可能插入到父类变量的空隙</li>
</ul>
<h3 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h3><p>不是必须的，也没有特别含义，仅仅起到占位符的作用。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><img src="/images/java/jvm/%E5%AF%B9%E8%B1%A1%E8%AF%A6%E7%BB%86%E5%9B%BE%E7%A4%BA.png" alt="对象详细图示.png"></p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p>JVM 是如何通过栈帧中的对象引用访问到其内部的对象实例呢？——定位，通过栈上 reference 访问。</p>
<p><img src="/images/java/jvm/%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%BD%8D.png" alt="对象定位.png"></p>
<p>创建对象的目的就是为了使用它。</p>
<h3 id="对象访问的两种方式"><a href="#对象访问的两种方式" class="headerlink" title="对象访问的两种方式"></a>对象访问的两种方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p><img src="/images/java/jvm/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE-%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png" alt="对象访问-句柄访问.png"></p>
<p>句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是<strong>句柄池。</strong></p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>reference 中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference 本身不需要被修改。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>访问时需要经过多次寻址</p>
<h4 id="直接指针（HotSpot采用）"><a href="#直接指针（HotSpot采用）" class="headerlink" title="直接指针（HotSpot采用）"></a>直接指针（HotSpot采用）</h4><p><img src="/images/java/jvm/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE-%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE.png" alt="对象访问-直接访问.png"></p>
<p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据。</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>reference 可直接定位到堆中的实例。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>对象被移动（垃圾收集时移动对象很普遍）时需要改变reference。</p>
<h1 id="直接内存-Direct-Memory"><a href="#直接内存-Direct-Memory" class="headerlink" title="直接内存 Direct Memory"></a>直接内存 Direct Memory</h1><p>不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。</p>
<p><strong>直接内存是在 Java 堆外的、直接向系统申请的内存区间。</strong></p>
<p>来源于 NIO ，通过存在堆中的 DirectByteBuffer 操作 Native 内存。</p>
<p>通常，访问直接内存的速度会优于 Java 堆。即读写性能高。</p>
<ul>
<li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存</li>
<li>Java 的 NIO 库允许 Java 程序使用直接内存，用于数据缓冲区</li>
</ul>
<p>使用下列代码，直接分配本地内存空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> BUFFER = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 1GB</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);</span><br></pre></td></tr></table></figure>

<h2 id="非直接缓存区和直接缓存区"><a href="#非直接缓存区和直接缓存区" class="headerlink" title="非直接缓存区和直接缓存区"></a>非直接缓存区和直接缓存区</h2><p>原来采用 BIO 的架构，我们需要从用户态切换成内核态</p>
<p><img src="/images/java/jvm/%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%AD%98%E5%8C%BA.png" alt="非直接缓存区.png"></p>
<p>NIO 的方式使用了直接缓存区的概念</p>
<p><img src="/images/java/jvm/%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%AD%98%E5%8C%BA.png" alt="直接缓存区.png"></p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>也可能导致 OutOfMemoryError 异常</p>
<p>由于直接内存在 Java 堆外，因此它的大小不会直接受限于 -Xmx 指定的最大堆大小，但是系统内存是有限的，Java 堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
<p>缺点</p>
<ul>
<li>分配回收成本较高</li>
<li>不受 JVM 内存回收管理</li>
</ul>
<p>直接内存大小可以通过 MaxDirectMemorySize 设置</p>
<p>如果不指定，默认与堆的最大值 -Xmx 参数值一致</p>
<p><img src="/images/java/jvm/JVM7%E3%80%818%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="JVM7、8内存结构.png"></p>
<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h2 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h2><p>执行引擎属于 JVM 的下层，里面包括解释器、及时编译器、垃圾回收器。</p>
<p><img src="/images/java/jvm/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.png" alt="执行引擎.png"></p>
<p><strong>执行引擎是 Java 虚拟机核心的组成部分之一。</strong></p>
<p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<strong>虚拟机的执行引擎则是由软件自行实现的</strong>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<strong>能够执行那些不被硬件直接支持的指令集格式</strong>。</p>
<p>JVM 的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息。</p>
<p>那么，如果想要让一个 Java 程序运行起来，执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释/编译为对应平台上的本地机器指令才可以</strong>。简单来说，<strong>JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者</strong>。</p>
<h3 id="执行引擎的工作流程"><a href="#执行引擎的工作流程" class="headerlink" title="执行引擎的工作流程"></a>执行引擎的工作流程</h3><ol>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于 PC 寄存器。</li>
<li>每当执行完一项指令操作后，PC 寄存器就会更新下一条需要被执行的指令地址。</li>
<li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在 Java 堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li>
</ol>
<p><img src="/images/java/jvm/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="执行引擎的工作流程.png"></p>
<p>从外观上来看，所有的 Java 虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。</p>
<h2 id="Java-代码编译和执行过程"><a href="#Java-代码编译和执行过程" class="headerlink" title="Java 代码编译和执行过程"></a>Java 代码编译和执行过程</h2><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p>
<ul>
<li>前面橙色部分是生成字节码文件的过程，和 JVM 无关</li>
<li>后面蓝色和绿色才是 JVM 需要考虑的过程，（<strong>蓝色的为即时编译器流程、绿色的为解释器流程</strong>）</li>
</ul>
<p>![Java 代码编译和执行过程.png](/images/java/jvm/Java 代码编译和执行过程.png)</p>
<p>Java 代码编译是由 Java 源码编译器来完成，流程图如下所示：</p>
<p><img src="/images/java/jvm/Java%E6%BA%90%E7%A0%81%E7%BA%A7%E7%BC%96%E8%AF%91%E5%99%A8.png" alt="Java源码级编译器.png"></p>
<p>Java 字节码的执行是由 JVM 执行引擎来完成，流程图如下所示：</p>
<p><img src="/images/java/jvm/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.png" alt="Java虚拟机执行引擎.png"></p>
<p>我们用一个总的图，来说说解释器和编译器：</p>
<p><img src="/images/java/jvm/%E8%A7%A3%E9%87%8A%E5%99%A8%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E7%B1%BB%E5%88%AB.png" alt="解释器和编译器类别.png"></p>
<h3 id="什么是解释器（Interpreter）"><a href="#什么是解释器（Interpreter）" class="headerlink" title="什么是解释器（Interpreter）"></a>什么是解释器（Interpreter）</h3><p>当 Java 虚拟机启动时会根据预定义的规范<strong>对字节码采用逐行解释的方式执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
<h3 id="什么是-JIT-编译器"><a href="#什么是-JIT-编译器" class="headerlink" title="什么是 JIT 编译器"></a>什么是 JIT 编译器</h3><p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p>
<h3 id="为什么-Java-是半编译半解释型语言"><a href="#为什么-Java-是半编译半解释型语言" class="headerlink" title="为什么 Java 是半编译半解释型语言"></a>为什么 Java 是半编译半解释型语言</h3><p>JDK 1.0 时代，将 Java 语言定位为“解释执行”还是比较准确的。再后来，Java 也发展出可以直接生成本地代码的编译器。现在 JVM 在执行 Java 代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p>
<p>翻译成本地代码后，就可以做一个缓存操作，存储在方法区中。</p>
<h2 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a>机器码、指令、汇编语言</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它编写程序，这就是机器语言。</p>
<p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p>
<p>用它编写的程序一经输入计算机，CPU 直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p>
<p>机器指令与 CPU 紧密相关，所以不同种类的 CPU 所对应的机器指令也就不同。</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>由于机器码是有 0 和 1 组成的二进制序列，可读性实在太差，于是人们发明了指令。</p>
<p>指令就是把机器码中特定的 0 和 1 序列，简化成对应的指令（一般为英文简写，如 mov，inc 等），可读性稍好。</p>
<p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如 mov），对应的机器码也可能不同。</p>
<h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。<br>如常见的</p>
<ul>
<li>x86 指令集，对应的是 x86 架构的平台</li>
<li>ARM 指令集，对应的是 ARM 架构的平台</li>
</ul>
<h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p>
<p>在汇编语言中，用<strong>助记符（Mnemonics）</strong>代替<strong>机器指令的操作码</strong>，用<strong>地址符号（Symbol）或标号（Label）</strong>代替<strong>指令或操作数的地址</strong>。</p>
<p>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p>
<ul>
<li>由于计算机只认识指令码，所以用<strong>汇编语言编写的程序还必须翻译成机器指令码</strong>，计算机才能识别和执行。</li>
</ul>
<h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言<strong>更接近人的语言</strong>。</p>
<p>当计算机执行高级语言编写的程序时，<strong>仍然需要把程序解释和编译成机器的指令码</strong>。完成这个过程的程序就叫做解释程序或编译程序。</p>
<p><img src="/images/java/jvm/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="高级语言执行流程.png"></p>
<p>高级语言也不是直接翻译成机器指令，而是翻译成汇编语言，如下面说的 C 和 C++。</p>
<h3 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++ 源程序执行过程"></a>C、C++ 源程序执行过程</h3><p>编译过程又可以分成两个阶段：编译和汇编。</p>
<p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码。</p>
<p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p>
<p>![C、C++ 源程序执行过程.png](/images/java/jvm/C、C++ 源程序执行过程.png)</p>
<h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码。</p>
<p>字节码主要为了实现特定软件运行和软件环境、<strong>与硬件环境无关</strong>。</p>
<p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p>
<ul>
<li>字节码典型的应用为：Java bytecode</li>
</ul>
<h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>JVM 设计者们的初衷仅仅只是单纯地<strong>为了满足 Java 程序实现跨平台特性</strong>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p>
<p><img src="/images/java/jvm/Java%E6%BA%90%E7%A0%81%E5%85%88%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0.png" alt="Java源码先翻译成字节码的可能原因.png"></p>
<p>为什么 Java 源文件不直接翻译成不同平台对应的机器指令 ，而是先翻译成字节码文件再翻译成不同平台对应的机器指令？可能是因为直接翻译的机器指令代价较大，耗时较长</p>
<p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
<p>当一条字节码指令被解释执行完成后，接着再根据 PC 寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p>
<h3 id="解释器分类"><a href="#解释器分类" class="headerlink" title="解释器分类"></a>解释器分类</h3><p>在 Java 的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong>。</p>
<p>字节码解释器在执行时通过<strong>纯软件代码</strong>模拟字节码的执行，效率非常低下。</p>
<p>而模板解释器将<strong>每一条字节码和一个模板函数相关联</strong>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</p>
<ul>
<li>在 HotSpot VM 中，解释器主要由 Interpreter 模块和 Code 模块构成<ul>
<li>Interpreter 模块：实现了解释器的核心功能</li>
<li>Code 模块：用于管理 HotSpot VM 在运行时生成的本地机器指令</li>
</ul>
</li>
</ul>
<h3 id="现状-1"><a href="#现状-1" class="headerlink" title="现状"></a>现状</h3><p>由于解释器在设计和实现上非常简单，因此除了 Java 语言之外，还有许多高级语言同样也是基于解释器执行的，比如 Python、Perl、Ruby 等。但是在今天，<strong>基于解释器执行已经沦落为低效的代名词</strong>，并且时常被一些 C/C++ 程序员所调侃。</p>
<p>为了解决这个问题，JVM 平台支持一种叫作<strong>即时编译的技术</strong>。即时编译的目的是避免函数被解释执行，而是<strong>将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可</strong>，这种方式可以使执行效率大幅度提升。</p>
<p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p>
<h2 id="JIT-编译器"><a href="#JIT-编译器" class="headerlink" title="JIT 编译器"></a>JIT 编译器</h2><h3 id="Java-代码的执行分类"><a href="#Java-代码的执行分类" class="headerlink" title="Java 代码的执行分类"></a>Java 代码的执行分类</h3><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行。</p>
<p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行。</p>
<p>HotSpot VM 是目前市面上高性能虚拟机的代表作之一。它<strong>采用解释器与即时编译器并存的架构</strong>。在 Java 虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p>
<p>在今天，Java 程序的运行性能早已脱胎换骨，已经达到了可以和 C/C++ 程序一较高下的地步。</p>
<h3 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h3><p>有些开发人员会感觉到诧异，<strong>既然 HotSpot VM 中已经内置 JIT 编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？</strong>比如 JRockit VM 内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p>
<ul>
<li>JRockit 虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为 JRockit 只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能。</li>
</ul>
<p>首先明确：</p>
<p>当程序启动后，<strong>解释器可以马上发挥作用</strong>，省去编译的时间，立即执行。</p>
<p>编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
<p>所以：</p>
<p>尽管 JRockit VM 中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。<strong>在此模式下，当 Java 虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</strong></p>
<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p>
<h3 id="HotSpot-JVM-执行方式"><a href="#HotSpot-JVM-执行方式" class="headerlink" title="HotSpot JVM 执行方式"></a>HotSpot JVM 执行方式</h3><p>当虚拟机启动的时候，<strong>解释器可以首先发挥作用</strong>，而不必等待即时编译器全部编译完成再执行，这样可以<strong>省去许多不必要的编译时间</strong>。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，<strong>将有价值的字节码编译为本地机器指令</strong>，以换取更高的程序执行效率。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>注意解释执行与编译执行在线上环境微妙的辩证关系。<strong>机器在热机状态可以承受的负载要大于冷机状态</strong>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p>
<p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的 1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的 JVM 均是解释执行，还没有进行热点代码统计和 JIT 动态编译，导致机器启动之后，当前 1/2 发布成功的服务器马上全部宕机，此故障说明了 JIT 的存在。—阿里团队</p>
<h3 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h3><ul>
<li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个<strong>前端编译器</strong>（其实叫“编译器的前端”更准确一些）把 .java 文件转变成 .class 文件的过程；</li>
<li>也可能是指虚拟机的<strong>后端运行期编译器</strong>（JIT 编译器，Just In Time Compiler）把字节码转变成机器码的过程。</li>
<li>还可能是指使用<strong>静态提前编译器</strong>（AOT 编译器，Ahead of Time Compiler）直接把 .java 文件编译成本地机器代码的过程。</li>
</ul>
<p>前端编译器：Sun 的 Javac、Eclipse JDT 中的增量式编译器（ECJ）。</p>
<p>JIT 编译器：HotSpot VM 的 C1、C2 编译器。</p>
<p>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</p>
<h3 id="热点探测技术"><a href="#热点探测技术" class="headerlink" title="热点探测技术"></a>热点探测技术</h3><p>当然是否需要启动 JIT 编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<strong>执行的频率</strong>而定。关于那些需要被编译为本地代码的字节码，也被称之为<strong>“热点代码”</strong>，JIT 编译器在运行时会针对那些频繁被调用的“热点代码”做出<strong>深度优化</strong>，将其直接编译为对应平台的本地机器指令，以此提升 Java 程序的执行性能。</p>
<p><strong>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</strong>，因此都可以通过 JIT 编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为 <strong>OSR（On Stack Replacement）编译</strong>。</p>
<p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT 编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<strong>热点探测功能</strong>。</p>
<p><strong>目前 HotSpot VM 所采用的热点探测方式是基于计数器的热点探测。</strong></p>
<p>采用基于计数器的热点探测，HotSpot VM 将会为每一个方法都建立 2 个不同类型的计数器，分别为<strong>方法调用计数器（Invocation Counter）</strong>和<strong>回边计数器（Back Edge Counter）</strong>。</p>
<ul>
<li>方法调用计数器用于统计方法的调用次数</li>
<li>回边计数器则用于统计循环体执行的循环次数</li>
</ul>
<h3 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h3><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在 Client 模式下是 1500 次，在 Server 模式下是 10000 次。超过这个阈值，就会触发 JIT 编译。</p>
<p>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</p>
<p>当一个方法被调用时，会先检查该方法是否存在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加 1，然后判断<strong>方法调用计数器与回边计数器值之和</strong>是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p>
<p><img src="/images/java/jvm/%E7%83%AD%E7%82%B9%E6%8E%A2%E6%B5%8B%E6%8A%80%E6%9C%AF-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8.png" alt="热点探测技术-方法调用计数器.png"></p>
<h3 id="热点衰减"><a href="#热点衰减" class="headerlink" title="热点衰减"></a>热点衰减</h3><p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当超过<strong>一定的时间限度</strong>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被<strong>减少一半</strong>，这个过程称为方法调用计数器<strong>热度的衰减</strong>（Counter Decay），而这段时间就称为此方法统计的<strong>半衰周期</strong>（Counter Half Life Time）</p>
<ul>
<li>半衰周期是化学中的概念，比如出土的文物通过查看 C60 来获得文物的年龄</li>
</ul>
<p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<br>-XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p>
<p>另外，可以使用 -XX:CounterHalfLifeTime 参数设置半衰周期的时间，单位是秒。</p>
<h3 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h3><p>它的作用是统计一个方法中<strong>循环体代码执行的次数</strong>，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发 OSR 编译。</p>
<p><img src="/images/java/jvm/%E7%83%AD%E7%82%B9%E6%8E%A2%E6%B5%8B%E6%8A%80%E6%9C%AF-%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8.png" alt="热点探测技术-回边计数器.png"></p>
<h3 id="HotSpot-VM-可以设置程序执行方法"><a href="#HotSpot-VM-可以设置程序执行方法" class="headerlink" title="HotSpot VM 可以设置程序执行方法"></a>HotSpot VM 可以设置程序执行方法</h3><p>缺省情况下 HotSpot VM 是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为 Java 虚拟机指定在运行时到底是<strong>完全采用解释器</strong>执行，还是<strong>完全采用即时编译器</strong>执行。如下所示：</p>
<ul>
<li>-Xint：完全采用解释器模式执行程序</li>
<li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li>
<li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li>
</ul>
<p>![HotSpot VM设置程序执行方法.png](/images/java/jvm/HotSpot VM设置程序执行方法.png)</p>
<h3 id="HotSpot-VM-中-JIT-分类"><a href="#HotSpot-VM-中-JIT-分类" class="headerlink" title="HotSpot VM 中 JIT 分类"></a>HotSpot VM 中 JIT 分类</h3><p>在 HotSpot VM 中内嵌有两个 JIT 编译器，分别为 Client Compiler 和 Server Compiler，但大多数情况下我们简称为 C1 编译器和 C2 编译器。开发人员可以通过如下命令显式指定 Java 虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>
<ul>
<li><p>-client：指定 Java 虚拟机运行在 Client 模式下，并使用 C1 编译器；</p>
<ul>
<li>C1 编译器会对字节码进行<strong>简单和可靠的优化，耗时短</strong>。以达到更快的编译速度。</li>
</ul>
</li>
<li><p>-server：指定 Java 虚拟机运行在 Server 模式下，并使用 C2 编译器。</p>
<ul>
<li>C2 进行<strong>耗时较长的优化，以及激进优化</strong>。但优化的代码执行效率更高。（使用 C++ 实现）</li>
</ul>
</li>
</ul>
<h3 id="C1-和-C2-编译器不同的优化策略"><a href="#C1-和-C2-编译器不同的优化策略" class="headerlink" title="C1 和 C2 编译器不同的优化策略"></a>C1 和 C2 编译器不同的优化策略</h3><p>在不同的编译器上有不同的优化策略，C1 编译器上主要有方法内联，去虚拟化、元余消除。</p>
<ul>
<li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li>
<li>去虚拟化：对唯一的实现类进行内联</li>
<li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li>
</ul>
<p>C2 的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在 C2 上有如下几种优化：</p>
<ul>
<li>标量替换：用标量值代替聚合对象的属性值</li>
<li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li>
<li>同步消除：清除同步操作，通常指 synchronized</li>
</ul>
<h3 id="分层编译策略"><a href="#分层编译策略" class="headerlink" title="分层编译策略"></a>分层编译策略</h3><p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发 C1 编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2 编译会根据性能监控信息进行激进优化。</p>
<p>不过在 Java 7 版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由 C1 编译器和 C2 编译器相互协作共同来执行编译任务。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>一般来讲，JIT 编译出来的机器码性能比解释器高</li>
<li>C2 编译器启动时长比 C1 慢，系统稳定执行以后，C2 编译器执行速度远快于 C1 编译器</li>
</ul>
<h3 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h3><p>JDK 9 引入了 AOT 编译器（静态提前编译器，Ahead of Time Compiler）</p>
<p>Java 9 引入了实验性 AOT 编译工具 jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。</p>
<p>所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在<strong>程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在<strong>程序运行之前</strong>，便将字节码转换为机器码的过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.java -&gt; .class -&gt; (使用jaotc) -&gt; .so</span><br></pre></td></tr></table></figure>

<p>最大的好处：Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验</p>
<p>缺点：</p>
<ul>
<li>破坏了 Java  “ 一次编译，到处运行”，必须为每个不同的硬件，OS 编译对应的发行包</li>
<li>降低了 Java 链接过程的动态性，加载的代码在编译器就必须全部已知。</li>
<li>还需要继续优化中，最初只支持 Linux X64 java base</li>
</ul>
<h3 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h3><ul>
<li>自 JDK 10 起，HotSpot 又加入了一个全新的及时编译器：Graal 编译器</li>
<li>编译效果短短几年时间就追平了 C2 编译器，未来可期</li>
<li>目前，带着实验状态标签，需要使用开关参数 -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler 去激活才能使用</li>
</ul>
<h1 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h1><h2 id="String-的基本特性"><a href="#String-的基本特性" class="headerlink" title="String 的基本特性"></a>String 的基本特性</h2><ul>
<li>String：字符串，使用一对 “” 引起来表示<ul>
<li>String s1 = “mogublog” ;   // 字面量的定义方式</li>
<li>String s2 =  new String(“moxi”); </li>
</ul>
</li>
<li>String 声明为 final 的，不可被继承</li>
<li>String 实现了 Serializable 接口：表示字符串是支持序列化的。实现了 Comparable 接口：表示 String 可以比较大小</li>
<li>String 在 JDK 8 及以前内部定义了 final char[] value 用于存储字符串数据。JDK 9 时改为 byte[]</li>
</ul>
<h3 id="为什么-JDK-9-改变了结构"><a href="#为什么-JDK-9-改变了结构" class="headerlink" title="为什么 JDK 9 改变了结构"></a>为什么 JDK 9 改变了结构</h3><p>String 类的当前实现将字符存储在 char 数组中，每个字符使用两个字节(16 位)。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部 char 数组中有一半的空间将不会使用。</p>
<p>我们建议改变字符串的内部表示 Class 从 UTF-16 字符数组到字节数组+一个 encoding-flag 字段。新的 String 类将根据字符串的内容存储编码为 ISO-8859-1/Latin-1(每个字符一个字节)或  UTF-16 (每个字符两个字节)的字符。编码标志将指示使用哪种编码。</p>
<p>结论：String 再也不用 char[] 来存储了，改成了 byte [] 加上编码标记，节约了一些空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value</span><br></pre></td></tr></table></figure>

<p>同时基于 String 的数据结构，例如 StringBuffer 和 StringBuilder 也同样做了修改。</p>
<h3 id="String-的不可变性"><a href="#String-的不可变性" class="headerlink" title="String 的不可变性"></a>String 的不可变性</h3><p>String：代表不可变的字符序列。简称：不可变性。</p>
<ul>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的 value 进行赋值。</li>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</li>
<li>当调用 String 的 replace() 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</li>
</ul>
<p>通过字面量的方式（区别于 new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字面量定义的方式，“abc”存储在字符串常量池中</span></span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        s1 = <span class="string">"hello"</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="comment">// 只要进行了修改，就会重新创建一个对象，这就是不可变性</span></span><br><span class="line">        s2 += <span class="string">"def"</span>;</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = s1.replace(<span class="string">'a'</span>, <span class="string">'m'</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">hello</span><br><span class="line">abc</span><br><span class="line">----------------</span><br><span class="line">abc</span><br><span class="line">abcdef</span><br><span class="line">----------------</span><br><span class="line">abc</span><br><span class="line">mbc</span><br></pre></td></tr></table></figure>

<h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">"good"</span>);</span><br><span class="line">    <span class="keyword">char</span> [] ch = &#123;<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span> ch [])</span> </span>&#123;</span><br><span class="line">        str = <span class="string">"test ok"</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringExer ex = <span class="keyword">new</span> StringExer();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);</span><br><span class="line">        System.out.println(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">good</span><br><span class="line">best</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>字符串常量池是不会存储相同内容的字符串的。</strong></p>
<p>String 的 String Pool 是一个固定大小的 Hashtable ，默认值大小长度是 1009。如果放进 String Pool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用 String.intern 时性能会大幅下降。</p>
<p>使用 -XX:StringTablesize 可设置 StringTable 的长度。</p>
<p>在 JDK 6 中 StringTable 是固定的，就是 1009 的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize 设置没有要求。</p>
<p>在 JDK 7 中，StringTable 的长度默认值是 60013 ，StringTablesize 设置没有要求。</p>
<p>在 JDK 8 中，StringTable 可以设置的最小值为 1009。</p>
<h2 id="String-的内存分配"><a href="#String-的内存分配" class="headerlink" title="String 的内存分配"></a>String 的内存分配</h2><p>在 Java 语言中有 8 种基本数据类型和一种比较特殊的类型 String 。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p>
<p>常量池就类似一个 Java 系统级别提供的缓存。8 种基本数据类型的常量池都是系统协调的，<strong>String 类型的常量池比较特殊。它的主要使用方法有两种。</strong></p>
<ul>
<li><p>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</p>
<ul>
<li>比如：String info = “atguigu.com”；</li>
</ul>
</li>
<li><p>如果不是用双引号声明的 String 对象，<strong>可以使用 String 提供的 intern() 方法</strong>。</p>
</li>
</ul>
<p>Java 6 及以前，字符串常量池存放在永久代。</p>
<p>Java 7 中 Oracle 的工程师对字符串池的逻辑做了很大的改变，即将<strong>字符串常量池的位置调整到 Java 堆内</strong>。</p>
<ul>
<li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li>
<li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在 Java 7 中使用 String.intern()。</li>
</ul>
<p>Java 8 元空间，字符串常量在堆。</p>
<p><img src="/images/java/jvm/JDK6%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt="JDK6运行时常量池.png.png"></p>
<p><img src="/images/java/jvm/JDK7%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png.png" alt="JDK7运行时常量池.png.png"></p>
<h3 id="为什么-StringTable-从永久代调整到堆中"><a href="#为什么-StringTable-从永久代调整到堆中" class="headerlink" title="为什么 StringTable 从永久代调整到堆中"></a>为什么 StringTable 从永久代调整到堆中</h3><p>在 JDK 7 中，interned 字符串不再在 Java 堆的永久代中分配，而是在 Java 堆的主要部分(称为年轻代和年老代)中分配，与应用程序创建的其他对象一起分配。此更改将导致驻留在主 Java 堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。由于这一变化，大多数应用程序在堆使用方面只会看到相对较小的差异，但加载许多类或大量使用字符串的较大应用程序会出现这种差异。intern() 方法会看到更显著的差异。</p>
<ul>
<li>永久代的默认比较小</li>
<li>永久代垃圾回收频率低</li>
</ul>
<h2 id="String-的基本操作"><a href="#String-的基本操作" class="headerlink" title="String 的基本操作"></a>String 的基本操作</h2><p>Java 语言规范里要求完全相同的字符串字面量，应该包含同样的 Unicode 字符序列（包含同一份码点序列的常量），并且必须是指向同一个 String 类实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        Memory mem = <span class="keyword">new</span> Memory();</span><br><span class="line">        mem.foo(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span> </span>&#123;</span><br><span class="line">        String str = param.toString();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/java/jvm/String%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png" alt="String的基本操作.png"></p>
<h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><ul>
<li>常量与常量的拼接结果在常量池，原理是编译期优化</li>
<li>常量池中不会存在相同内容的变量</li>
<li>只要其中有一个是变量，结果就在堆中。变量拼接的原理是 StringBuilder</li>
<li>如果拼接的结果调用 intern() 方法，则<strong>主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;  <span class="comment">// 得到 abc的常量池</span></span><br><span class="line">    String s2 = <span class="string">"abc"</span>; <span class="comment">// abc存放在常量池，直接将常量池的地址返回</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终java编译成.class，再执行.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true，因为存放在字符串常量池</span></span><br><span class="line">    System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      String s1 = <span class="string">"javaEE"</span>;</span><br><span class="line">      String s2 = <span class="string">"hadoop"</span>;</span><br><span class="line">      String s3 = <span class="string">"javaEEhadoop"</span>;</span><br><span class="line">      String s4 = <span class="string">"javaEE"</span> + <span class="string">"hadoop"</span>;    </span><br><span class="line">      String s5 = s1 + <span class="string">"hadoop"</span>;</span><br><span class="line">      String s6 = <span class="string">"javaEE"</span> + s2;</span><br><span class="line">      String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">      System.out.println(s3 == s4); <span class="comment">// true</span></span><br><span class="line">      System.out.println(s3 == s5); <span class="comment">// false</span></span><br><span class="line">      System.out.println(s3 == s6); <span class="comment">// false</span></span><br><span class="line">      System.out.println(s3 == s7); <span class="comment">// false</span></span><br><span class="line">      System.out.println(s5 == s6); <span class="comment">// false</span></span><br><span class="line">      System.out.println(s5 == s7); <span class="comment">// false</span></span><br><span class="line">      System.out.println(s6 == s7); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">      String s8 = s6.intern();</span><br><span class="line">      System.out.println(s3 == s8); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述的结果我们可以知道：</p>
<p>如果拼接符号的前后出现了变量，则相当于在堆空间中 new String() ，具体的内容为拼接的结果</p>
<p>而调用 intern() 方法，则会判断字符串常量池中是否存在 “javaEEhadoop” 值，如果存在则返回常量池中的值，否者就在常量池中创建</p>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>拼接操作的底层其实使用了 StringBuilder</p>
<p><img src="/images/java/jvm/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%BA%95%E5%B1%82.png" alt="字符串拼接操作的底层.png"></p>
<p>s1 + s2 的执行细节</p>
<ul>
<li>StringBuilder s = new StringBuilder();</li>
<li>s.append(s1);</li>
<li>s.append(s2);</li>
<li>s.toString();  -&gt; 类似于new String(“ab”);</li>
</ul>
<p>在 JDK 5 之后，使用的是 StringBuilder，在 JDK 5 之前使用的是 StringBuffer</p>
<table>
<thead>
<tr>
<th>String</th>
<th>StringBuffer</th>
<th>StringBuilder</th>
</tr>
</thead>
<tbody><tr>
<td>String 的值是不可变的，这就导致每次对 String 的操作都会生成新的 String 对象，不仅效率低下，而且浪费大量优先的内存空间</td>
<td>StringBuffer 是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个 StringBuffer 对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量</td>
<td>可变类，速度更快</td>
</tr>
<tr>
<td>不可变</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td></td>
<td>线程安全</td>
<td>线程不安全</td>
</tr>
<tr>
<td></td>
<td>多线程操作字符串</td>
<td>单线程操作字符串</td>
</tr>
</tbody></table>
<p>注意，我们左右两边如果是变量的话，就是需要 new StringBuilder 进行拼接，但是如果使用的是 final 修饰，则是从常量池中获取。所以说拼接符号左右两边都是字符串常量或常量引用 则仍然使用编译器优化。也就是说被 final 修饰的变量，将会变成常量，类和方法将不能被继承。</p>
<ul>
<li>在开发中，能够使用 final 的时候，建议使用上</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String s1 = <span class="string">"a"</span>;</span><br><span class="line">    <span class="keyword">final</span> String s2 = <span class="string">"b"</span>;</span><br><span class="line">    String s3 = <span class="string">"ab"</span>;</span><br><span class="line">    String s4 = s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<h3 id="拼接操作和-append-性能对比"><a href="#拼接操作和-append-性能对比" class="headerlink" title="拼接操作和 append 性能对比"></a>拼接操作和 append 性能对比</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> highLevel)</span> </span>&#123;</span><br><span class="line">    String src = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">        src += <span class="string">"a"</span>; <span class="comment">// 每次循环都会创建一个StringBuilder对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> highLevel)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">        sb.append(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法 1 耗费的时间：4005ms，方法 2 消耗时间：7ms</p>
<p>结论：</p>
<ul>
<li>通过 StringBuilder 的 append() 方式添加字符串的效率，要远远高于 String 的字符串拼接方法</li>
</ul>
<p>好处：</p>
<ul>
<li>StringBuilder 的 append 的方式，自始至终只创建一个 StringBuilder 的对象</li>
<li>对于字符串拼接的方式，还需要创建很多 StringBuilder 对象和调用 toString 时候创建的 String 对象</li>
<li>内存中由于创建了较多的 StringBuilder 和 String 对象，内存占用过大，如果进行 GC 那么将会耗费更多的时间</li>
</ul>
<p>改进的空间：</p>
<ul>
<li>我们使用的是 StringBuilder 的空参构造器，默认的字符串容量是 16，然后将原来的字符串拷贝到新的字符串中， 我们也可以默认初始化更大的长度，减少扩容的次数</li>
<li>因此在实际开发中，我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度</li>
</ul>
<h2 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern() 的使用"></a>intern() 的使用</h2><p>intern() 是一个 native 方法，调用的是底层 C 的方法。</p>
<p>字符串池最初是空的，由 String 类私有地维护。在调用 intern() 方法时，如果池中已经包含了由 equals(object) 方法确定的与该字符串对象相等的字符串，则返回池中的字符串。否则，该字符串对象将被添加到池中，并返回对该字符串对象的引用。</p>
<p>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern() 方法：intern() 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String myInfo &#x3D; new string(&quot;I love atguigu&quot;).intern();</span><br></pre></td></tr></table></figure>

<p>也就是说，如果在任意字符串上调用 String.intern() 方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是 true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（<span class="string">"a"</span>+<span class="string">"b"</span>+<span class="string">"c"</span>）.intern（）==<span class="string">"abc"</span></span><br></pre></td></tr></table></figure>

<p>通俗点讲，Interned String 就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池。（String Intern Pool）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何保证变量s指向的是字符串常量池中的数据呢？</span></span><br><span class="line"><span class="comment"> * 有两种方式：</span></span><br><span class="line"><span class="comment"> * 方式一： String s = "shkstart";//字面量定义的方式</span></span><br><span class="line"><span class="comment"> * 方式二： 调用intern()</span></span><br><span class="line"><span class="comment"> *         String s = new String("shkstart").intern();</span></span><br><span class="line"><span class="comment"> *         String s = new StringBuilder("shkstart").toString().intern();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">        s.intern();<span class="comment">//调用此方法之前，字符串常量池中已经存在了"1"</span></span><br><span class="line">        String s2 = <span class="string">"1"</span>;</span><br><span class="line">        System.out.println(s == s2);<span class="comment">//jdk6：false   jdk7/8：false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);<span class="comment">//s3变量记录的地址为：new String("11")</span></span><br><span class="line">        <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在"11"呢？答案：不存在！！</span></span><br><span class="line">        s3.intern();<span class="comment">//在字符串常量池中生成"11"。如何理解：jdk6:创建了一个新的对象"11",也就有新的地址。</span></span><br><span class="line">                                            <span class="comment">//         jdk7:此时常量中并没有创建"11",而是创建一个指向堆空间中new String("11")的地址</span></span><br><span class="line">        String s4 = <span class="string">"11"</span>;<span class="comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的"11"的地址</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//jdk6：false  jdk7/8：true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="intern-的空间效率测试"><a href="#intern-的空间效率测试" class="headerlink" title="intern()  的空间效率测试"></a>intern()  的空间效率测试</h3><p>我们通过测试一下，使用了 intern 和不使用的时候，其实相差还挺多的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = <span class="number">1000</span> * <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> String[MAX_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer [] data = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i%data.length])).intern();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"花费的时间为："</span> + (end - start));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.getStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>：对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用 intern() 方法能够节省内存空间。</p>
<p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用 intern() 方法，就会很明显降低内存的大小。</p>
<h2 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h2><h3 id="new-String-“ab”-会创建几个对象"><a href="#new-String-“ab”-会创建几个对象" class="headerlink" title="new String(“ab”)会创建几个对象"></a>new String(“ab”)会创建几个对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new String("ab") 会创建几个对象？ 看字节码就知道是2个对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">"ab"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们转换成字节码来查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 0 new #2 &lt;java&#x2F;lang&#x2F;String&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 ldc #3 &lt;ab&gt;</span><br><span class="line"> 6 invokespecial #4 &lt;java&#x2F;lang&#x2F;String.&lt;init&gt;&gt;</span><br><span class="line"> 9 astore_1</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure>

<p>这里面就是两个对象</p>
<ul>
<li>一个对象是：new 关键字在堆空间中创建</li>
<li>另一个对象：字符串常量池中的对象</li>
</ul>
<h3 id="new-String-“a”-new-String-“b”-会创建几个对象"><a href="#new-String-“a”-new-String-“b”-会创建几个对象" class="headerlink" title="new String(“a”) + new String(“b”) 会创建几个对象"></a>new String(“a”) + new String(“b”) 会创建几个对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new String("ab") 会创建几个对象？ </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码文件为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 0 new #2 &lt;java&#x2F;lang&#x2F;StringBuilder&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 invokespecial #3 &lt;java&#x2F;lang&#x2F;StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"> 7 new #4 &lt;java&#x2F;lang&#x2F;String&gt;</span><br><span class="line">10 dup</span><br><span class="line">11 ldc #5 &lt;a&gt;</span><br><span class="line">13 invokespecial #6 &lt;java&#x2F;lang&#x2F;String.&lt;init&gt;&gt;</span><br><span class="line">16 invokevirtual #7 &lt;java&#x2F;lang&#x2F;StringBuilder.append&gt;</span><br><span class="line">19 new #4 &lt;java&#x2F;lang&#x2F;String&gt;</span><br><span class="line">22 dup</span><br><span class="line">23 ldc #8 &lt;b&gt;</span><br><span class="line">25 invokespecial #6 &lt;java&#x2F;lang&#x2F;String.&lt;init&gt;&gt;</span><br><span class="line">28 invokevirtual #7 &lt;java&#x2F;lang&#x2F;StringBuilder.append&gt;</span><br><span class="line">31 invokevirtual #9 &lt;java&#x2F;lang&#x2F;StringBuilder.toString&gt;</span><br><span class="line">34 astore_1</span><br><span class="line">35 return</span><br></pre></td></tr></table></figure>

<p>我们创建了6个对象</p>
<ul>
<li>对象1：new StringBuilder()</li>
<li>对象2：new String(“a”)</li>
<li>对象3：常量池的 a</li>
<li>对象4：new String(“b”)</li>
<li>对象5：常量池的 b</li>
<li>对象6：toString 中会创建一个 new String(“ab”)<ul>
<li>调用 toString 方法，不会在常量池中生成 ab</li>
</ul>
</li>
</ul>
<h3 id="intern-的使用：JDK-6-和-JDK-7"><a href="#intern-的使用：JDK-6-和-JDK-7" class="headerlink" title="intern() 的使用：JDK 6 和 JDK 7"></a>intern() 的使用：JDK 6 和 JDK 7</h3><h4 id="JDK-6-中"><a href="#JDK-6-中" class="headerlink" title="JDK 6 中"></a>JDK 6 中</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);  <span class="comment">// 在常量池中已经有了</span></span><br><span class="line">s.intern(); <span class="comment">// 将该对象放入到常量池。但是调用此方法没有太多的区别，因为已经存在了1</span></span><br><span class="line">String s2 = <span class="string">"1"</span>;</span><br><span class="line">System.out.println(s == s2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = <span class="string">"11"</span>;</span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/java/jvm/intern%E7%9A%84%E4%BD%BF%E7%94%A8-jdk6.png" alt="intern的使用-jdk6.png"></p>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>为什么对象会不一样呢？</p>
<ul>
<li>一个是 new 创建的对象，一个是常量池中的对象，显然不是同一个</li>
</ul>
<p>如果是下面这样的，那么就是 true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">s = s.intern();</span><br><span class="line">String s2 = <span class="string">"1"</span>;</span><br><span class="line">System.out.println(s == s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>而对于下面的来说，因为 s3 变量记录的地址是 new String(“11”)，然后这段代码执行完以后，常量池中不存在 “11”，这是 JDK 6 的关系，然后执行 s3.intern() 后，就会在常量池中生成 “11”，最后 s4 用的就是 s3 的地址。</p>
<blockquote>
<p>为什么最后输出的 s3 == s4 会为 false 呢？</p>
<p>这是因为在 JDK 6 中创建了一个新的对象 “11”，也就是有了新的地址， s2 = 新地址</p>
<p>而在 JDK 7 中，在 JDK 7 中，并没有创新一个新对象，而是指向常量池中的新对象</p>
</blockquote>
<h4 id="JDK-7-中"><a href="#JDK-7-中" class="headerlink" title="JDK 7 中"></a>JDK 7 中</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">s.intern();</span><br><span class="line">String s2 = <span class="string">"1"</span>;</span><br><span class="line">System.out.println(s == s2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>); <span class="comment">// 字符串常量池中不存在 “11”</span></span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = <span class="string">"11"</span>;</span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">String s4 = <span class="string">"11"</span>;  <span class="comment">// 在常量池中生成的字符串</span></span><br><span class="line">s3.intern();  <span class="comment">// 然后s3就会从常量池中找，发现有了，就什么事情都不做</span></span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure>

<p>我们将 s4 的位置向上移动一行，发现变化就会很大，最后得到的是 false。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>总结 String 的 intern() 的使用：</p>
<p>JDK 1.6 中，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，会把<strong>此对象复制一份</strong>，放入串池，并返回串池中的对象地址</li>
</ul>
<p>JDK 1.7 起，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，则会把<strong>对象的引用地址</strong>复制一份，放入串池，并返回串池中的引用地址</li>
</ul>
<p>练习：</p>
<p><img src="/images/java/jvm/intern%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%83%E4%B9%A01-jdk6.png" alt="intern的使用练习1-jdk6.png"></p>
<p><img src="/images/java/jvm/intern%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%83%E4%B9%A01-jdk7%E3%80%818.png" alt="intern的使用练习1-jdk7、8.png"></p>
<ul>
<li>在 JDK 6 中，在字符串常量池中创建一个字符串 “ab”</li>
<li>在 JDK 8 中，在字符串常量池中没有创建 “ab”，而是将堆中的地址复制到串池中。</li>
</ul>
<p>所以上述结果，在 JDK 6 中是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>在 JDK 8 中是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>针对下面这题，在 JDK 6 和 JDK 8 中表现的是一样的：</p>
<p><img src="/images/java/jvm/intern%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%83%E4%B9%A02.png" alt="intern的使用练习2.png"></p>
<h2 id="StringTable的垃圾回收"><a href="#StringTable的垃圾回收" class="headerlink" title="StringTable的垃圾回收"></a>StringTable的垃圾回收</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的垃圾回收</span></span><br><span class="line"><span class="comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringGCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            String.valueOf(i).intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/java/jvm/StringTable%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="StringTable的垃圾回收.png"></p>
<h2 id="G1-中的-String-去重操作"><a href="#G1-中的-String-去重操作" class="headerlink" title="G1 中的 String 去重操作"></a>G1 中的 String 去重操作</h2><p>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>背景：对许多 Java 应用（有大的也有小的）做的测试得出以下结果：</p>
<ul>
<li><p>堆存活数据集合里面 String 对象占了 25%</p>
</li>
<li><p>堆存活数据集合里面重复的 String 对象有13.5%</p>
</li>
<li><p>String 对象的平均长度是 45</p>
</li>
</ul>
<p>许多大规模的 Java 应用的瓶颈在于内存，测试表明，在这些类型的应用里面，<strong>Java 堆中存活的数据集合差不多 25% 是 String 对象</strong>。更进一步，这里面差不多一半 String 对象是重复的，重复的意思是说：</p>
<p>string1.equals(string2) = true。堆上存在重复的 String 对象必然是一种内存的浪费。这个项目将在 G1 垃圾收集器中实现自动持续对重复的 String 对象进行去重，这样就能避免浪费内存。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>当垃圾收集器工作的时候，会访问堆上存活的对象。<strong>对每一个访问的对象都会检查是否是候选的要去重的 String 对象。</strong></li>
<li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的 String 对象。</li>
<li>使用一个 Hashtable 来记录所有的被 String 对象使用的不重复的 char 数组。当去重的时候，会查这个 Hashtable，来看堆上是否已经存在一个一模一样的 char 数组。</li>
<li>如果存在，String 对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>
<li>如果查找失败，char 数组会被插入到 Hashtable，这样以后的时候就可以共享这个数组了。</li>
</ul>
<h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><ul>
<li>UsestringDeduplication（bool）：开启 String 去重，<strong>默认是不开启的，需要手动开启</strong></li>
<li>PrintStringDeduplicationStatistics（bool）：打印详细的去重统计信息</li>
<li>StringDeduplicationAgeThreshold（uintx）：达到这个年龄的 String 对象被认为是去重的候选对象</li>
</ul>
<h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><h2 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h2><p>Java 和 C++ 语言的区别，就在于垃圾收集技术和内存动态分配上，C 语言没有垃圾收集技术，需要我们手动的收集。</p>
<p>垃圾收集，不是 Java 语言的伴生产物。早在 1960 年，第一门开始使用内存动态分配和垃圾收集技术的 Lisp 语言诞生。</p>
<p>关于垃圾收集有三个经典问题：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<p>垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java 的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p>
<h3 id="什么是垃圾？-1"><a href="#什么是垃圾？-1" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h3><p>垃圾是指在<strong>运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</p>
<p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。</p>
<h3 id="磁盘碎片整理"><a href="#磁盘碎片整理" class="headerlink" title="磁盘碎片整理"></a>磁盘碎片整理</h3><p>机械硬盘需要进行磁盘整理，同时还有坏道。</p>
<p><img src="/images/java/jvm/%E7%A3%81%E7%9B%98%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86.png" alt="磁盘碎片整理.png"></p>
<h2 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h2><h3 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h3><ul>
<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下 CMS 和 G1？</li>
<li>JVM GC 算法有哪些，目前的 JDK 版本采用什么回收算法？</li>
<li>G1 回收器讲下回收过程 GC 是什么？为什么要有 GC？</li>
<li>GC 的两种判定方法？CMS 收集器与 G1 收集器的特点？</li>
</ul>
<h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><ul>
<li>说一下 GC 算法，分代回收说下？</li>
<li>垃圾收集策略和算法？</li>
</ul>
<h3 id="天猫"><a href="#天猫" class="headerlink" title="天猫"></a>天猫</h3><ul>
<li>JVM GC 原理，JVM 怎么回收内存？</li>
<li>CMS 特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li>
</ul>
<h3 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h3><p>Java 的垃圾回收器都有哪些，说下 G1 的应用场景，平时你是如何搭配使用垃圾回收器的？</p>
<h3 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h3><ul>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下 CMS 和 G1？</li>
<li>包括原理，流程，优缺点。垃圾回收算法的实现原理？</li>
</ul>
<h3 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h3><ul>
<li>讲一讲垃圾回收算法？</li>
<li>什么情况下触发垃圾回收？</li>
<li>如何选择合适的垃圾收集算法？</li>
<li>JVM 有哪三种垃圾回收器？</li>
</ul>
<h3 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h3><ul>
<li>常见的垃圾回收器算法有哪些，各有什么优劣？</li>
<li>System.gc() 和 Runtime.gc() 会做什么事情？</li>
<li>Java GC 机制？GC Roots 有哪些？</li>
<li>Java 对象的回收方式，回收算法？</li>
<li>CMS 和 G1 了解么，CMS 解决什么问题，说一下回收的过程？</li>
<li>CMS 回收停顿了几次，为什么要停顿两次?</li>
</ul>
<h2 id="为什么需要-GC？"><a href="#为什么需要-GC？" class="headerlink" title="为什么需要 GC？"></a>为什么需要 GC？</h2><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p>
<p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便 JVM 将整理出的内存分配给新的对象</strong>。</p>
<p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有 GC 就不能保证应用程序的正常进行</strong>。而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。</p>
<h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><p>在早期的 C/C++ 时代，垃圾回收基本上是手工进行的。开发人员可以使用 new 关键字进行内存申请，并使用 delete 关键字进行内存释放。比如以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MibBridge * pBridge = <span class="keyword">new</span> cmBaseGroupBridge（）；</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span>（pBridge -&gt; Register（kDestroy）！= NO ERROR）</span><br><span class="line">	<span class="keyword">delete</span> pBridge；</span><br></pre></td></tr></table></figure>

<p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。 </p>
<p>有了垃圾回收机制后，上述代码极有可能变成这样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MibBridge * pBridge = <span class="keyword">new</span> cmBaseGroupBridge(); </span><br><span class="line">pBridge -&gt; Register(kDestroy);</span><br></pre></td></tr></table></figure>

<p>现在，除了 Java 以外，C#、Python、Ruby 等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了线代开发语言必备的标准。</p>
<h2 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h2><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样<strong>降低内存泄漏和内存溢出的风险</strong></p>
<ul>
<li>没有垃圾回收器，Java 也会和 C++ 一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li>
</ul>
<p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以<strong>更专心地专注于业务开发</strong></p>
<p>Oracle 官网关于垃圾回收的介绍<br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p>
<h3 id="担忧"><a href="#担忧" class="headerlink" title="担忧"></a>担忧</h3><p>对于 Java 开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化 Java 开发人员在程序出现内存溢出时定位问题和解决问题的能力。</strong></p>
<p>此时，了解 JVM 的自动内存分配和内存回收原理就显得非常重要，只有在真正了解 JVM 是如何管理内存后，我们才能够在遇见 OutOfMemoryError 时，快速地根据错误异常日志定位问题和解决问题。</p>
<p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节。</strong></p>
<h3 id="GC-主要关注的区域"><a href="#GC-主要关注的区域" class="headerlink" title="GC 主要关注的区域"></a>GC 主要关注的区域</h3><p>GC 主要关注于<strong>方法区</strong>和<strong>堆</strong>中的垃圾收集。</p>
<p>![GC 主要关注的区域.png](/images/java/jvm/GC 主要关注的区域.png)</p>
<p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收。</p>
<ul>
<li>其中，<strong>Java 堆是垃圾收集器的工作重点</strong></li>
</ul>
<p>从次数上讲：</p>
<ul>
<li><strong>频繁收集 Young 区</strong></li>
<li><strong>较少收集 Old 区</strong></li>
<li><strong>基本不收集 Perm 区（元空间）</strong></li>
</ul>
<h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><h2 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h2><p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</strong>。只有被<strong>标记</strong>为己经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</p>
<p>那么在 JVM 中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p>
<p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法。</strong></p>
<p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<strong>引用计数器属性。用于记录对象被引用的情况。</strong></p>
<p>对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，即表示对象 A 不可能再被使用，可进行回收。</p>
<p>优点：<strong>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</strong></p>
<p>缺点：</p>
<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li>
<li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在 Java 的垃圾回收器中没有使用这类算法。</li>
</ul>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>当 p 的指针断开的时候，内部的引用形成一个循环，这就是循环引用，从而造成内存泄漏</p>
<p><img src="/images/java/jvm/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt="循环引用.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefCountGC</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个成员属性的唯一作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 引用</span></span><br><span class="line">    Object reference = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RefCountGC obj1 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        RefCountGC obj2 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line">        obj2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 显式的执行垃圾收集行为</span></span><br><span class="line">        <span class="comment">//这里发生GC，obj1和obj2能否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K), 0.0061980 secs] [Times: user=0.00 sys=0.00, real=0.36 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 808K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;672K(175104K)] 816K-&gt;672K(251392K), [Metaspace: 3479K-&gt;3479K(1056768K)], 0.0045983 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 655K [0x000000076b500000, 0x0000000770a00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65536K, 1% used [0x000000076b500000,0x000000076b5a3ee8,0x000000076f500000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076f500000,0x000000076f500000,0x000000076ff80000)</span><br><span class="line">  to   space 10752K, 0% used [0x000000076ff80000,0x000000076ff80000,0x0000000770a00000)</span><br><span class="line"> ParOldGen       total 175104K, used 672K [0x00000006c1e00000, 0x00000006cc900000, 0x000000076b500000)</span><br><span class="line">  object space 175104K, 0% used [0x00000006c1e00000,0x00000006c1ea8070,0x00000006cc900000)</span><br><span class="line"> Metaspace       used 3486K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 385K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>我们能够看到，上述进行了 GC 收集的行为，将上述的新生代中的两个对象都进行回收了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K)</span><br></pre></td></tr></table></figure>

<p>如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明 Java 使用的不是引用计数算法来进行标记的。</p>
<p><img src="/images/java/jvm/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B.png" alt="循环引用示例.png"></p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制。</p>
<p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p>
<p>Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p>
<p>Python 如何解决循环引用？</p>
<ul>
<li>手动解除：很好理解，就是在合适的时机，解除引用关系。</li>
<li>使用弱引用 weakref，weakref 是 Python 提供的标准库，旨在解决循环引用。</li>
</ul>
<h2 id="标记阶段：可达性分析算法-或根搜索算法、追踪性垃圾收集"><a href="#标记阶段：可达性分析算法-或根搜索算法、追踪性垃圾收集" class="headerlink" title="标记阶段：可达性分析算法(或根搜索算法、追踪性垃圾收集)"></a>标记阶段：可达性分析算法(或根搜索算法、追踪性垃圾收集)</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</strong></p>
<p>相较于引用计数算法，这里的可达性分析就是 <strong>Java、C# **选择的。这种类型的垃圾收集通常也叫作</strong>追踪性垃圾收集**。（Tracing Garbage Collection）</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>所谓 “GC Roots” 根集合就是一组必须活跃的引用。</p>
<p>基本思路：</p>
<ul>
<li>可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达。</strong></li>
<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链（Reference Chain）</strong></li>
<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>
</ul>
<p><img src="/images/java/jvm/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png" alt="可达性分析算法.png"></p>
<blockquote>
<p><strong>这里需要注意的是，可达性分析算法中，每次标记的是直接或间接与 GC Roots 连接的对象，标记完成后，遍历整个内存空间，将没有被标记的对象删除</strong>。</p>
</blockquote>
<h3 id="Java-中-GC-Roots-可以是哪些？"><a href="#Java-中-GC-Roots-可以是哪些？" class="headerlink" title="Java 中 GC Roots 可以是哪些？"></a>Java 中 GC Roots 可以是哪些？</h3><ul>
<li>虚拟机栈中引用的对象<ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li>本地方法栈内 JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象<ul>
<li>比如：Java 类的引用类型静态变量</li>
</ul>
</li>
<li>方法区中常量引用的对象<ul>
<li>比如：字符串常量池（String Table）里的引用</li>
</ul>
</li>
<li>所有被同步锁 synchronized 持有的对象</li>
<li>Java 虚拟机内部的引用。<ul>
<li>基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li>
</ul>
</li>
<li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li>
</ul>
<p><img src="https://gitee.com/xlshi/blog_img/raw/master/img/20201013093414.png" alt="image-20200712104622677"></p>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>总结一句话就是，<strong>堆空间外的一些结构</strong>，比如<strong>虚拟机栈、本地方法栈、方法区、字符串常量池</strong>等地方对堆空间进行引用的，都可以作为 GC Roots 进行可达性分析。</p>
<p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整 GC Roots 集合。比如：分代收集和局部回收（Partial GC）。</p>
<p>如果只针对 Java 堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，而不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入 GC Roots 集合中去考虑，才能保证可达性分析的准确性。</p>
<h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root。</p>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p>
<p>这点也是导致 GC 进行时必须“Stop The World”的一个重要原因。</p>
<p>即使是号称（几乎）不会发生停顿的 CMS 收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</p>
<h2 id="对象的-finalization-机制"><a href="#对象的-finalization-机制" class="headerlink" title="对象的 finalization 机制"></a>对象的 finalization 机制</h2><p>Java 语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑。</strong></p>
<p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize() 方法，但一个对象指挥调用一次，即针对 ‘复活’ 过来的对象进行第二次垃圾回收时不会再调用此方法。</p>
<p>finalize() 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
<h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><p>永远不要主动调用某个对象的 finalize() 方法，应该交给垃圾回收机制调用。理由包括下面三点：</p>
<ul>
<li>在 finalize() 时可能会导致对象复活。</li>
<li>finalize() 方法的执行时间是没有保障的，它完全由 GC 线程决定，极端情况下，若不发生 GC，则 finalize() 方法将没有执行机会。<ul>
<li>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li>
</ul>
</li>
<li>一个糟糕的 finalize() 会严重影响 GC 的性能。</li>
</ul>
<p>从功能上来说， finalize() 方法与 C++ 中的析构函数比较相似，但是 Java 采用的是基于垃圾回收器的自动内存管理机制，所以 finalize() 方法在本质上不同于 C++ 中的析构函数。</p>
<p>由于 finalize() 方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态</strong>。</p>
<h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p>
<ul>
<li><strong>可触及的</strong>：从根节点开始，可以到达这个对象。</li>
<li><strong>可复活的</strong>：对象的所有引用都被释放，但是对象有可能在 finalize() 中复活。</li>
<li><strong>不可触及的</strong>：对象的 finalize() 被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为 <strong>finalize() 只会被调用一次</strong>。</li>
</ul>
<p>以上3种状态中，是由于 finalize() 方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>判定一个对象 objA 是否可回收，至少要经历两次标记过程：</p>
<ul>
<li><p>如果对象 objA 到 GC Roots 没有引用链，则进行第一次标记。</p>
</li>
<li><p>进行筛选，判断此对象是否有必要执行 finalize() 方法</p>
<ul>
<li>如果对象 objA 没有重写 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA 被判定为不可触及的。</li>
<li>如果对象 objA 重写了 finalize() 方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize() 方法执行。</li>
<li>finalize() 方法是对象逃脱死亡的最后机会，稍后 GC 会对 F-Queue 队列中的对象进行第二次标记。如果 objA 在 finalize() 方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA 会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下， finalize() 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，<strong>一个对象的 finalize() 方法只会被调用一次。</strong></li>
</ul>
</li>
</ul>
<p><img src="/images/java/jvm/Finalizer%E7%BA%BF%E7%A8%8B.png" alt="Finalizer线程.png"></p>
<p>上图就是我们看到的 Finalizer 线程。</p>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>我们使用重写 finalize() 方法，然后在方法的内部，重写将其存放到 GC Roots 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanReliveObj</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类变量，属于GC Roots的一部分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj canReliveObj;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"调用当前类重写的finalize()方法"</span>);</span><br><span class="line">        canReliveObj = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        canReliveObj = <span class="keyword">new</span> CanReliveObj();</span><br><span class="line">        canReliveObj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"-----------------第一次gc操作------------"</span>);</span><br><span class="line">        <span class="comment">// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span> (canReliveObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------第二次gc操作------------"</span>);</span><br><span class="line">        canReliveObj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span> (canReliveObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后运行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------------第一次gc操作------------</span><br><span class="line">调用当前类重写的finalize()方法</span><br><span class="line">obj is still alive</span><br><span class="line">-----------------第二次gc操作------------</span><br><span class="line">obj is dead</span><br></pre></td></tr></table></figure>

<p>在进行第一次清除的时候，我们会执行 finalize() 方法，然后对象进行了一次自救操作，但是因为 finalize() 方法只会被调用一次，因此第二次该对象将会被垃圾清除。</p>
<h2 id="MAT-与-JProfiler-的-GC-Roots-溯源"><a href="#MAT-与-JProfiler-的-GC-Roots-溯源" class="headerlink" title="MAT 与 JProfiler 的 GC Roots 溯源"></a>MAT 与 JProfiler 的 GC Roots 溯源</h2><h3 id="MAT-是什么？"><a href="#MAT-是什么？" class="headerlink" title="MAT 是什么？"></a>MAT 是什么？</h3><p>MAT 是Memory Analyzer 的简称，它是一款功能强大的 Java 堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p>
<p>MAT 是基于 Eclipse 开发的，是一款免费的性能分析工具。</p>
<p>可以在<a href="http://www.eclipse.org/mat/下载并使用" target="_blank" rel="noopener">http://www.eclipse.org/mat/下载并使用</a> MAT</p>
<h3 id="方法一：命令行使用-jmap"><a href="#方法一：命令行使用-jmap" class="headerlink" title="方法一：命令行使用 jmap"></a>方法一：命令行使用 jmap</h3><p><img src="https://gitee.com/xlshi/blog_img/raw/master/img/20201013095218.png" alt="image-20200712112026317"></p>
<h3 id="方法二：使用-JVisualVM"><a href="#方法二：使用-JVisualVM" class="headerlink" title="方法二：使用 JVisualVM"></a>方法二：使用 JVisualVM</h3><p>捕获的 Heap Dump 文件是一个临时文件，关闭 JVisualVM 后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获 Heap Dump：</p>
<p>在左侧“Application”（应用程序）子窗口中右击相应的应用程序，选择 Heap Dump（堆Dump）。</p>
<p>在 Monitor（监视）子标签页中点击Heap Dump（堆Dump）按钮。本地应用程序的 Heap Dumps 作为应用程序标签页的一个子标签页打开。同时，Heap Dump 在左侧的 Application（应用程序）栏中对应一个含有时间戳的节点。</p>
<p>右击这个节点选择 Save As（另存为）即可将 Heap Dump 保存到本地。</p>
<h3 id="使用-MAT-打开-Dump-文件"><a href="#使用-MAT-打开-Dump-文件" class="headerlink" title="使用 MAT 打开 Dump 文件"></a>使用 MAT 打开 Dump 文件</h3><p>打开后，我们就可以看到有哪些可以作为 GC Roots 的对象。</p>
<p>![使用 MAT 打开 Dump 文件.png](/images/java/jvm/使用 MAT 打开 Dump 文件.png)</p>
<p>里面我们能够看到有一些常用的 Java 类，然后 Thread 线程。</p>
<h3 id="JProfiler-的-GC-Roots-溯源"><a href="#JProfiler-的-GC-Roots-溯源" class="headerlink" title="JProfiler 的 GC Roots 溯源"></a>JProfiler 的 GC Roots 溯源</h3><p>我们在实际的开发中，一般不会查找全部的 GC Roots，可能只是查找某个对象的整个链路，或者称为 GC Roots 溯源，这个时候，我们就可以使用 JProfiler。</p>
<p>![JProfiler 的 GC Roots 溯源](/images/java/jvm/JProfiler 的 GC Roots 溯源.png)</p>
<h3 id="如何判断什么原因造成-OOM？"><a href="#如何判断什么原因造成-OOM？" class="headerlink" title="如何判断什么原因造成 OOM？"></a>如何判断什么原因造成 OOM？</h3><p>当我们程序出现 OOM 的时候，我们就需要进行排查，我们首先使用下面的例子进行说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存溢出排查</span></span><br><span class="line"><span class="comment"> * -Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建1M的文件</span></span><br><span class="line">    <span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> HeapOOM());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.getStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"count:"</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码就是不断的创建一个 1M 小字节数组，然后让内存溢出，我们需要限制一下内存大小，同时使用 HeapDumpOnOutOfMemoryError 将出错时候的 dump 文件输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure>

<p>我们将生成的 dump 文件打开，然后点击 Biggest Objects 就能够看到超大对象。</p>
<p><img src="/images/java/jvm/JProfiler%E6%9F%A5%E7%9C%8B%E8%B6%85%E5%A4%A7%E5%AF%B9%E8%B1%A1.png" alt="JProfiler查看超大对象.png"></p>
<p>然后我们通过线程，还能够定位到哪里出现 OOM。</p>
<p>![JProfiler通过线程定位 OOM.png](/images/java/jvm/JProfiler通过线程定位 OOM.png)</p>
<h2 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h2><h3 id="什么是清除？"><a href="#什么是清除？" class="headerlink" title="什么是清除？"></a>什么是清除？</h3><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p>
<p>关于空闲列表是在为对象分配内存的时候：</p>
<ul>
<li>如果内存规整<ul>
<li>采用指针碰撞的方式进行内存分配</li>
</ul>
</li>
<li>如果内存不规整<ul>
<li>虚拟机需要维护一个列表</li>
<li>空闲列表分配</li>
</ul>
</li>
</ul>
<h3 id="JVM-中比较常见的三种垃圾收集算法"><a href="#JVM-中比较常见的三种垃圾收集算法" class="headerlink" title="JVM 中比较常见的三种垃圾收集算法"></a>JVM 中比较常见的三种垃圾收集算法</h3><ul>
<li>标记一清除算法（Mark-Sweep）</li>
<li>复制算法（Copying）</li>
<li>标记-压缩算法（Mark-Compact）</li>
</ul>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被 J.McCarthy 等人在 1960 年提出并并应用于 Lisp 语言。</p>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>当堆中的有效内存空间（Available Memory）被耗尽的时候，就会停止整个程序（也被称为 Stop The World），然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<ul>
<li><strong>标记</strong>：Collector 从引用根节点开始遍历，<strong>标记所有被引用的对象</strong>。一般是在对象的 Header 中记录为可达对象。<ul>
<li><strong>标记的是引用的对象，不是垃圾！！</strong></li>
</ul>
</li>
<li><strong>清除</strong>：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收。</li>
</ul>
<p><img src="/images/java/jvm/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记-清除算法.png"></p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>标记清除算法的效率不算高</li>
<li>在进行 GC 的时候，需要停止整个应用程序，导致用户体验较差</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内存碎片，需要维护一个空闲列表</li>
</ul>
<h2 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky 于 1963 年发表了著名的论文，“使用双存储区的 Lisp 语言垃圾收集器 CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky 在该论文中描述的算法被人们称为复制（Copying）算法，它也被 M.L.Minsky 本人成功地引入到了Lisp 语言的一个实现版本中。</p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p>
<p><img src="/images/java/jvm/%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="清除阶段-复制算法.png"></p>
<p>把可达的对象，直接复制到另外一个区域中复制完成后，A 区就没有用了，里面的对象可以直接清除掉，其实新生代里面就用到了复制算法。</p>
<h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ul>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”问题</li>
</ul>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>此算法的缺点也是很明显的，就是需要<strong>两倍</strong>的内存空间。</li>
<li>对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小</li>
</ul>
<h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><p>如果系统中的存活对象很多，那么复制的对象将会有很多，效率会很低，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低），特别适合垃圾对象很多，存活对象很少的场景；例如：Young 区的 Survivor0 和 Survivor1 区</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在新生代，对常规应用的垃圾回收，一次通常可以回收 70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
<p><img src="/images/java/jvm/%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png" alt="清除阶段-复制算法应用场景.png"></p>
<h2 id="清除阶段：标记-压缩-整理-算法"><a href="#清除阶段：标记-压缩-整理-算法" class="headerlink" title="清除阶段：标记-压缩(整理)算法"></a>清除阶段：标记-压缩(整理)算法</h2><h3 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h3><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他的算法。</strong></p>
<p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p>
<p>1970 年前后，G.L.Steele、C.J.Chene 和 D.s.Wise 等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p>
<h3 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h3><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象。</p>
<p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p>
<p><img src="/images/java/jvm/%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9(%E6%95%B4%E7%90%86)%E7%AE%97%E6%B3%95.png" alt="清除阶段：标记-压缩(整理)算法.png"></p>
<h3 id="标清和标整的区别"><a href="#标清和标整的区别" class="headerlink" title="标清和标整的区别"></a>标清和标整的区别</h3><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<strong>标记-清除-压缩（Mark-Sweep-Compact）算法。</strong></p>
<p>二者的本质差异在于标记-清除算法是一种<strong>非移动式的回收算法</strong>，标记-压缩是<strong>移动式的</strong>。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
<h3 id="指针碰撞-Bump-the-Pointer"><a href="#指针碰撞-Bump-the-Pointer" class="headerlink" title="指针碰撞(Bump the Pointer)"></a>指针碰撞(Bump the Pointer)</h3><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞(Bump the Pointer)</p>
<h3 id="标整的优缺点"><a href="#标整的优缺点" class="headerlink" title="标整的优缺点"></a>标整的优缺点</h3><h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><ul>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ul>
<h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li>
<li>移动过程中，需要全程暂停用户应用程序。即：STW</li>
</ul>
<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>
<p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p>
<table>
<thead>
<tr>
<th></th>
<th>标记清除</th>
<th>标记整理</th>
<th>复制</th>
</tr>
</thead>
<tbody><tr>
<td><strong>速率</strong></td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td><strong>空间开销</strong></td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的2倍空间（不堆积碎片）</td>
</tr>
<tr>
<td><strong>移动对象</strong></td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<p>综合我们可以找到，没有最好的算法，只有最合适的算法</p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
<p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<strong>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</strong>一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如 <strong>Http 请求中的 Session 对象、线程、Socket 连接</strong>，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：<strong>String 对象</strong>，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p><strong>目前几乎所有的 GC 都采用分代收集算法执行垃圾回收的。</strong></p>
<p>在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<ul>
<li>年轻代（Young Gen）</li>
</ul>
<p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过 HotSpot 中的两个 Survivor 的设计得到缓解。</p>
<ul>
<li>老年代（Tenured Gen）</li>
</ul>
<p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>
<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>
<ul>
<li>Mark 阶段的开销与存活对象的数量成正比。</li>
<li>Sweep 阶段的开销与所管理区域的大小成正相关。</li>
<li>Compact 阶段的开销与存活对象的数据成正比。</li>
</ul>
<p>以 HotSpot 中的 CMS 回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收效率很高。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的 Concurrent Mode Failure 时），将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理。</p>
<p>分代的思想被现有的虚拟机广泛使用，几乎所有的垃圾回收器都区分新生代和老年代。</p>
<h2 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop the World 的状态。在 <strong>Stop the World</strong> 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，<strong>将严重影响用户体验或者系统的稳定性。</strong>为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p>
<p>在对实时性要求很高的程序中，比起缩短GC的平均中断时间，往往更重视缩短GC的最大中断时间。例如，在机器人的姿势控制程序中，如果因为GC而让控制程序中断了0.1秒，机器人可能就摔倒了。或者，如果车辆制动控制程序因为GC而延迟响应的话，后果也是不堪设想的。在这些对实时性要求很高的程序中，必须能够对GC所产生的中断时间做出预测。例如，可以将“最多只能中断10毫秒”作为附加条件。在一般的GC算法中，作出这样的保证是不可能的，因为GC产生的中断时间与对象的数量和状态有关。</p>
<p>因此，为了维持程序的实时性，不等到GC全部完成，而是将GC操作细分成多个部分逐一执行。这种方式被称为增量回收（Incremental GC）。在增量回收中，由于GC过程是渐进的，在回收过程中程序本身会继续运行，对象之间的引用关系也可能会发生变化。如果已经完成扫描和标记的对象被修改，对新的对象产生了引用，这个新对象就不会被标记，明明是“存活”对象却被回收掉了。在增量回收中为了避免这样的问题，和分代回收一样也采用了写屏障。当已经被标记的对象的引用关系发生变化时，通过写屏障会将新被引用的对象作为扫描的起始点记录下来。由于增量回收的过程是分步渐进式的，可以将中断时间控制在一定长度之内。另一方面，由于中断操作需要消耗一定的时间，GC所消耗的总时间就会相应增加，正所谓有得必有失。</p>
<h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong>。</p>
<h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>一般来说，在相同条件下，堆空间越大，一次 GC 时所需要的时间就越长，有关 GC 产生的停顿也越长。为了更好地控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。<br>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<p><img src="/images/java/jvm/%E6%B8%85%E7%90%86%E9%98%B6%E6%AE%B5-%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95.png" alt="清理阶段-分区算法.png"></p>
<h2 id="写到最后-1"><a href="#写到最后-1" class="headerlink" title="写到最后"></a>写到最后</h2><p>注意，这些只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。</p>
<h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc() 的理解"></a>System.gc() 的理解</h2><!--more-->

<p>在默认情况下，通过 System.gc() 者 Runtime.getRuntime().gc() 的调用，<strong>会显式触发 Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
<p>然而 System.gc() 调用附带一个免责声明，<strong>无法保证对垃圾收集器的调用。</strong>(不能确保立即生效)</p>
<p>JVM 实现者可以通过 System.gc() 调用来决定 JVM 的 GC 行为。而一般情况下，垃圾回收应该是自动进行的，<strong>无须手动触发，否则就太过于麻烦了</strong>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用 System.gc()。</p>
<p>代码演示是否触发 GC 操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemGCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemGCTest();</span><br><span class="line">        <span class="comment">// 提醒 JVM 进行垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//System.runFinalization();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"SystemGCTest 执行了 finalize 方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果，但是不一定会触发销毁的方法，调用 System.runFinalization() 会强制调用失去引用对象的 finalize()。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SystemGCTest 执行了 finalize 方法</span><br></pre></td></tr></table></figure>

<h3 id="手动-GC-来理解不可达对象的回收"><a href="#手动-GC-来理解不可达对象的回收" class="headerlink" title="手动 GC 来理解不可达对象的回收"></a>手动 GC 来理解不可达对象的回收</h3><p>代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVarGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发 Minor GC 没有回收对象，然后在触发 Full GC 将该对象存入 old 区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发 YoungGC 的时候，已经被回收了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不会被回收，因为它还存放在局部变量表索引为 1 的槽中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会被回收，因为它还存放在局部变量表索引为 1 的槽中，但是后面定义的 value 把这个槽给替换了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * localvarGC5中的数组已经被回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        localvarGC1();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVarGC localVarGC = <span class="keyword">new</span> LocalVarGC();</span><br><span class="line">        localVarGC.localvarGC3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p>
<p>由于 GC 一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现 OOM 的情况。</p>
<p>大多数情况下，GC 会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的 Full GC 操作，这时候会回收大量的内存，供应用程序继续使用。</p>
<p>javadoc 中对 OutOfMemoryError 的解释是，<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存</strong>。</p>
<p>首先说没有空闲内存的情况：说明 Java 虚拟机的堆内存不够。原因有二：</p>
<ul>
<li>Java 虚拟机的堆内存设置不够。</li>
</ul>
<p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 JVM 堆大小或者指定数值偏小。我们可以通过参数 -Xms 、-Xmx 来调整。</p>
<ul>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集。（存在被引用）</li>
</ul>
<p>对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</p>
<p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改观，出现 OOM，异常信息则变成了：“java.lang.OutOfMemoryError:Metaspace”。直接内存不足，也会导致 OOM。</p>
<p>这里面隐含着一层意思是，在抛出 OutOfMemoryError 之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<ul>
<li>例如：在引用机制分析中，涉及到 JVM 会去尝试回收<strong>软引用指向的对象等。</strong></li>
<li>在 java.nio.BIts.reserveMemory() 方法中，我们能清楚的看到，System.gc() 会被调用，以清理空间。</li>
</ul>
<p>当然，也不是在任何情况下垃圾收集器都会被触发的。</p>
<p>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 OutOfMemoryError。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>也称作“存储渗漏”。<strong>严格来说，只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏。</strong></p>
<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致 OOM，也可以叫做<strong>宽泛意义上的“内存泄漏”。</strong></p>
<p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 OutOfMemory 异常，导致程序崩溃。</p>
<p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>
<p>Java 使用可达性分析算法有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开，从而导致没有办法被回收。</p>
<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><ul>
<li>单例模式</li>
</ul>
<p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p>
<ul>
<li>一些提供 close 的资源未关闭导致内存泄漏</li>
</ul>
<p>数据库连接（dataSourse.getConnection() ），网络连接（Socket）和 IO 连接必须手动 close，否则是不能被回收的。</p>
<h2 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h2><p> Stop-The-World，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为 STW。</p>
<p>可达性分析算法中枚举根节点（GC Roots）会导致所有 Java 执行线程停顿。</p>
<ul>
<li><p>分析工作必须在一个能确保一致性的快照中进行</p>
</li>
<li><p>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</p>
</li>
<li><p><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></p>
</li>
</ul>
<p>被 STW 中断的应用程序线程会在完成 GC 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 STW 的发生。</p>
<p>STW 事件和采用哪款 GC 无关，所有的 GC 都有这个事件。</p>
<p>哪怕是 G1 也不能完全避免 Stop-The-World 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
<p>STW 是 JVM 在<strong>后台自动发起和自动完成</strong>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
<p>开发中不要用 System.gc()，会导致 Stop-The-World 的发生。</p>
<h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p>
<p>并发不是真正意义上的“同时进行”，只是 CPU 把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于 CPU 处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p>
<p><img src="/images/java/jvm/%E5%B9%B6%E5%8F%91%E6%A6%82%E5%BF%B5.png" alt="并发概念.png"></p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>当系统有一个以上 CPU 时，当一个 CPU 执行一个进程时，另一个 CPU 可以执行另一个进程，两个进程互不抢占CPU 资源，可以同时进行，我们称之为并行（Parallel）。</p>
<p>其实决定并行的因素不是 CPU 的数量，而是 CPU 的核心数量，比如一个 CPU 多个核也可以并行。</p>
<p>适合科学计算，后台处理等弱交互场景</p>
<p><img src="/images/java/jvm/%E5%B9%B6%E8%A1%8C%E6%A6%82%E5%BF%B5.png" alt="并行概念.png"></p>
<h3 id="并发和并行对比"><a href="#并发和并行对比" class="headerlink" title="并发和并行对比"></a>并发和并行对比</h3><p><strong>并发</strong>，指的是多个事情，在<strong>同一时间段内同时发生了。</strong></p>
<p><strong>并行</strong>，指的是多个事情，在<strong>同一时间点上同时发生了。</strong></p>
<p>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</p>
<p>只有在多 CPU 或者一个 CPU 多核的情况中，才会发生并行。</p>
<p>否则，看似同时发生的事情，其实都是并发执行的。</p>
<h3 id="垃圾回收的并行与并发-1"><a href="#垃圾回收的并行与并发-1" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<ul>
<li><p>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如 ParNew、Parallel Scavenge、Parallel Old；</p>
</li>
<li><p>串行（Serial）</p>
<ul>
<li>相较于并行的概念，单线程执行。</li>
<li>如果内存不够，则程序暂停，启动 JVM 垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li>
</ul>
</li>
</ul>
<p><img src="/images/java/jvm/%E5%9E%83%E5%9C%BE%E5%88%86%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C%E3%80%81%E4%B8%B2%E8%A1%8C.png" alt="垃圾分类中的并行、串行.png"></p>
<p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。</p>
<ul>
<li>用户程序在继续运行，而垃圾收集程序线程运行于另一个 CPU 上</li>
<li>如：CMS、G1</li>
</ul>
<p><img src="/images/java/jvm/%E5%9E%83%E5%9C%BE%E5%88%86%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91.png" alt="垃圾分类中的并发.png"></p>
<h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始 GC，这些位置称为“安全点（SafePoint）”。</p>
<p>SafePoint 的选择很重要，<strong>如果太少可能导致 GC 等待的时间太长，如果太频繁可能导致运行时的性能问题。</strong>大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为 Safe Point，如<strong>方法调用、循环跳转和异常跳转等</strong>。</p>
<p>如何在 GC 发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p>
<ul>
<li><strong>抢先式中断</strong>：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li>
<li><strong>主动式中断</strong>：设置一个中断标志，各个线程运行到 Safe Point 的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</li>
</ul>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>SafePoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 SafePoint。但是，程序“不执行”的时候呢？例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应 JVM 的中断请求，“走”到安全点去中断挂起，JVM 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
<p><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 GC 都是安全的。</strong>我们也可以把 Safe Region 看做是被扩展了的 SafePoint。</p>
<p><strong>执行流程：</strong></p>
<ul>
<li>当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Region，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程</li>
<li>当线程即将离开 Safe Region 时，会检查 JVM 是否已经完成 GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 Safe Region 的信号为止</li>
</ul>
<h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>
<p>【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？<br>在 JDK 1.2 版之后，Java 对引用的概念进行了扩充，将引用分为：</p>
<ul>
<li>强引用（Strong Reference）</li>
<li>软引用（Soft Reference）</li>
<li>弱引用（Weak Reference）</li>
<li>虚引用（Phantom Reference）</li>
</ul>
<p>这 4 种引用强度依次逐渐减弱。除强引用外，其他 3 种引用均可以在 java.lang.ref 包中找到它们的身影。</p>
<p>Reference 子类中只有终结器引用是包内可见的，其他 3 种引用类型均为 public，可以在应用程序中直接使用。</p>
<ul>
<li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似 “Object obj = new Object() “ 这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li>
<li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li>
<li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是<strong>能在这个对象被收集器回收时收到一个系统通知</strong>。</li>
</ul>
<h2 id="再谈引用：强引用"><a href="#再谈引用：强引用" class="headerlink" title="再谈引用：强引用"></a>再谈引用：强引用</h2><p>在 Java 程序中，最常见的引用类型是强引用（<strong>普通系统 99% 以上都是强引用</strong>），也就是我们最常见的普通对象引用，<strong>也是默认的引用类型</strong>。</p>
<p>当在 Java 语言中使用 new 操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
<p><strong>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong></p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，<strong>强引用是造成 Java 内存泄漏的主要原因之一</strong>。</p>
<h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><p>强引用的案例说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">"hello mogublog"</span>);</span><br></pre></td></tr></table></figure>

<p>局部变量 str 指向 StringBuffer 实例所在堆空间，通过 str 可以操作该实例，那么 str 就是 StringBuffer 实例的强引用对应内存结构</p>
<p>如果此时，在运行一个赋值语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">"hello mogublog"</span>);</span><br><span class="line">StringBuffer str1 = str;</span><br></pre></td></tr></table></figure>

<p>对应的内存结构为:</p>
<p><img src="/images/java/jvm/%E5%BC%BA%E5%BC%95%E7%94%A8%E4%B8%BE%E4%BE%8B.png" alt="强引用举例.png"></p>
<p>那么我们将 str = null; 则原来堆中的对象也不会被回收，因为还有其它对象指向该区域</p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p>
<ul>
<li>强引用可以直接访问目标对象。</li>
<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象。</li>
<li>强引用可能导致内存泄漏。</li>
</ul>
<h2 id="再谈引用：-软引用"><a href="#再谈引用：-软引用" class="headerlink" title="再谈引用： 软引用"></a>再谈引用： 软引用</h2><p>软引用是用来描述一些还有用，但非必需的对象。<strong>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</strong>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<blockquote>
<p>注意，这里的第一次回收是不可达的对象</p>
</blockquote>
<p>软引用通常用来实现内存敏感的缓存。比如：<strong>高速缓存</strong>就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p>
<p>类似弱引用，只不过 Java 虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
<blockquote>
<p>一句话概括：当内存足够时，不会回收软引用可达的对象；内存不够时，会回收软引用的可达对象。</p>
</blockquote>
<p>在 JDK 1.2 版之后提供了 SoftReference 类来实现软引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 创建一个软引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//销毁强引用，这是必须的，不然会存在强引用和软引用</span></span><br></pre></td></tr></table></figure>

<h2 id="再谈引用：弱引用"><a href="#再谈引用：弱引用" class="headerlink" title="再谈引用：弱引用"></a>再谈引用：弱引用</h2><blockquote>
<p>发现即回收</p>
</blockquote>
<p>弱引用也是用来描述那些非必需对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止</strong>。在系统 GC 时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，<strong>弱引用对象可以存在较长的时间。</strong></p>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
<p><strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。</strong>如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
<p>在 JDK 1.2 版之后提供了 WeakReference 类来实现弱引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 创建一个弱引用</span></span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> WeakReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//销毁强引用，这是必须的，不然会存在强引用和弱引用</span></span><br></pre></td></tr></table></figure>

<p><strong>弱引用对象与软引用对象的最大不同</strong>就在于，当 GC 在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC 总是进行回收。<strong>弱引用对象更容易、更快被 GC 回收</strong>。</p>
<p>面试题：你开发中使用过 WeakHashMap 吗？</p>
<p>WeakHashMap 用来存储图片信息，可以在内存不足的时候，及时回收，避免了 OOM。</p>
<h2 id="再谈引用：虚引用"><a href="#再谈引用：虚引用" class="headerlink" title="再谈引用：虚引用"></a>再谈引用：虚引用</h2><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收</p>
<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的 get() 方法取得对象时，总是 null。</p>
<p><strong>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</strong></p>
<p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
<p><strong>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</strong></p>
<blockquote>
<p>虚引用无法获取到我们的数据</p>
</blockquote>
<p>在 JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 声明引用队列</span></span><br><span class="line">ReferenceQueue phantomQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line"><span class="comment">// 声明虚引用（还需要传入引用队列）</span></span><br><span class="line">PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>我们使用一个案例，来结合虚引用，引用队列，finalize 进行讲解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前类对象的声明</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;</span><br><span class="line">    <span class="comment">// 引用队列</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"调用当前类的finalize方法"</span>);</span><br><span class="line">        obj = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.getStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"追踪垃圾回收过程：PhantomReferenceTest实例被GC了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> PhantomReferenceTest();</span><br><span class="line">        <span class="comment">// 构造了PhantomReferenceTest对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(phantomReference.get());</span><br><span class="line">            <span class="comment">// 去除强引用</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 第一次进行GC，由于对象可复活，GC无法回收该对象</span></span><br><span class="line">            System.out.println(<span class="string">"第一次GC操作"</span>);</span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj 是 null"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj 不是 null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第二次GC操作"</span>);</span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj 是 null"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj 不是 null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line">第一次GC操作</span><br><span class="line">调用当前类的finalize方法</span><br><span class="line">obj 不是 <span class="keyword">null</span></span><br><span class="line">第二次GC操作</span><br><span class="line">追踪垃圾回收过程：PhantomReferenceTest实例被GC了</span><br><span class="line">obj 是 <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>从上述运行结果我们知道，第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次 GC，因为会调用 finalize() 方法，将对象复活了，所以对象没有被回收，但是调用第二次 GC 操作的时候，因为 finalize() 方法只能执行一次，所以就触发了 GC 操作，将对象回收了，同时将会触发第二个操作就是将回收的值存入到引用队列中。</p>
<h2 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h2><p>它用于实现对象的 finalize() 方法，也可以称为终结器引用。无需手动编码，其内部配合引用队列使用。</p>
<p>在 GC 时，终结器引用入队。由 Finalizer 线程通过终结器引用找到被引用对象调用它的 finalize() 方法，第二次 GC 时才回收被引用的对象。</p>
<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC-分类与性能指标"><a href="#GC-分类与性能指标" class="headerlink" title="GC 分类与性能指标"></a>GC 分类与性能指标</h2><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的 JVM 来实现。</p>
<p>由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。</p>
<p>从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。</p>
<h3 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h3><h4 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a><strong>按线程数分</strong></h4><p>按<strong>线程数</strong>分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</p>
<p><img src="/images/java/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E7%B1%BB-%E6%8C%89%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%88%86.png" alt="垃圾回收器分类-按线程数分.png"></p>
<p>串行回收指的是在同一时间段内只允许有一个 CPU 用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p>
<ul>
<li>在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<strong>串行回收默认被应用在客户端的 Client 模式下的 JVM 中。</strong></li>
<li>在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。</li>
</ul>
<p>和串行回收相反，并行收集可以运用多个 CPU 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-The-World”机制。</p>
<h4 id="按工作模式分"><a href="#按工作模式分" class="headerlink" title="按工作模式分"></a>按工作模式分</h4><p>按照<strong>工作模式</strong>分，可以分为并发式垃圾回收器和独占式垃圾回收器。</p>
<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器（Stop The World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
<p><img src="/images/java/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E7%B1%BB-%E6%8C%89%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.png" alt="垃圾回收器分类-按工作模式.png"></p>
<h4 id="按碎片处理方式分"><a href="#按碎片处理方式分" class="headerlink" title="按碎片处理方式分"></a>按碎片处理方式分</h4><p>按<strong>碎片处理方式</strong>分，可分为<strong>压缩式垃圾回收器</strong>和<strong>非压缩式垃圾回收器</strong>。</p>
<ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li>
<li>非压缩式的垃圾回收器不进行这步操作。</li>
</ul>
<h4 id="按工作的内存区间分"><a href="#按工作的内存区间分" class="headerlink" title="按工作的内存区间分"></a>按工作的内存区间分</h4><p>按<strong>工作的内存区间</strong>分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p>
<h3 id="评估-GC-的性能指标"><a href="#评估-GC-的性能指标" class="headerlink" title="评估 GC 的性能指标"></a>评估 GC 的性能指标</h3><ul>
<li><strong>吞吐量*</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li>
<li><strong>垃圾收集开销</strong>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong>暂停时间*</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</li>
<li><strong>收集频率</strong>：相对于应用程序的执行，收集操作发生的频率。</li>
<li><strong>内存占用</strong>：Java 堆区所占的内存大小。</li>
<li><strong>快速</strong>：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<p>吞吐量、暂停时间、内存占用这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p>
<p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。<br>简单来说，主要抓住两点：</p>
<ul>
<li>吞吐量</li>
<li>暂停时间</li>
</ul>
<h3 id="评估-GC-的性能指标：吞吐量（Throughput）"><a href="#评估-GC-的性能指标：吞吐量（Throughput）" class="headerlink" title="评估 GC 的性能指标：吞吐量（Throughput）"></a>评估 GC 的性能指标：吞吐量（Throughput）</h3><p>吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）</p>
<blockquote>
<p>比如：虚拟机总共运行了100 分钟，其中垃圾收集花掉1分钟，那吞吐量就是 99%。</p>
</blockquote>
<p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p>
<p>吞吐量优先，意味着在单位时间内，STW 的时间最短：0.2 + 0.2 = 0.4</p>
<p><img src="/images/java/jvm/%E5%90%9E%E5%90%90%E9%87%8F.png" alt="吞吐量.png"></p>
<h3 id="评估-GC-的性能指标：暂停时间"><a href="#评估-GC-的性能指标：暂停时间" class="headerlink" title="评估 GC 的性能指标：暂停时间"></a>评估 GC 的性能指标：暂停时间</h3><p>“暂停时间”是指一个时间段内应用程序线程暂停，让 GC 线程执行的状态。</p>
<ul>
<li>例如，GC 期间 100 毫秒的暂停时间意味着在这 100 毫秒期间内没有应用程序线程是活动的。</li>
</ul>
<p>暂停时间优先，意味着尽可能让单次 STW 的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5</p>
<p><img src="/images/java/jvm/%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4.png" alt="暂停时间.png"></p>
<h3 id="吞吐量-vs-暂停时间"><a href="#吞吐量-vs-暂停时间" class="headerlink" title="吞吐量 vs 暂停时间"></a>吞吐量 vs 暂停时间</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p>
<p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，<strong>有时候甚至短暂的 200 毫秒暂停都可能打断终端用户体验</strong>。因此，具有低的较大暂停时间是非常重要的，特别是对于一个<strong>交互式应用程序</strong>。</p>
<p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p>
<ul>
<li><p>因为如果选择以吞吐量优先，那么<strong>必然需要降低内存回收的执行频率</strong>，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。</p>
</li>
<li><p>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又<strong>引起了年轻代内存的缩减和导致程序吞吐量的下降</strong>。</p>
</li>
</ul>
<p>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p>
<p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p>
<h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><p>垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p>
<p>那么，Java 常见的垃圾收集器有哪些？</p>
<blockquote>
<p>GC 垃圾收集器是和 JVM 一脉相承的，它是和 JVM 进行搭配使用，在不同的使用场景对应的收集器也是有区别</p>
</blockquote>
<h3 id="垃圾回收器发展史"><a href="#垃圾回收器发展史" class="headerlink" title="垃圾回收器发展史"></a>垃圾回收器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是 Garbage Collection，对应的产品我们称为 Garbage Collector。</p>
<ul>
<li>1999 年随 JDK 1.3.1 一起来的是串行方式的 Serial GC ，它是第一款 GC。ParNew 垃圾收集器是 Serial 收集器的多线程版本。</li>
<li>2002 年 2 月 26 日，Parallel GC 和 Concurrent Mark Sweep GC 跟随 JDK 1.4.2 一起发布。</li>
<li>Parallel GC 在 JDK 6 之后成为 HotSpot 默认 GC。</li>
<li>2012 年，在 JDK 1.7u4 版本中，G1 可用。</li>
<li>2017 年，JDK 9 中 G1 变成默认的垃圾收集器，以替代 CMS。</li>
<li>2018 年 3 月，JDK 10 中 G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>2018 年 9 月，JDK 11 发布。引入 Epsilon 垃圾回收器，又被称为 “No-Op（无操作）”回收器。同时，引入 ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li>
<li>2019 年 3 月，JDK 12 发布。增强 G1，自动返回未用堆内存给操作系统。同时，引入 Shenandoah GC：低停顿时间的 GC（Experimental）。</li>
<li>2019 年 9 月，JDK 13 发布。增强 ZGC，自动返回未用堆内存给操作系统。</li>
<li>2020 年 3 月，JDK 14 发布。删除 CMS 垃圾回收器。扩展 ZGC 在 macOS 和 Windows 上的应用。</li>
</ul>
<h3 id="7-种经典的垃圾收集器"><a href="#7-种经典的垃圾收集器" class="headerlink" title="7 种经典的垃圾收集器"></a>7 种经典的垃圾收集器</h3><ul>
<li>串行回收器：Serial、Serial Old</li>
<li>并行回收器：ParNew、Parallel Scavenge、Parallel Old</li>
<li>并发回收器：CMS、G1</li>
</ul>
<p><img src="/images/java/jvm/%E4%B8%83%E6%AC%BE%E7%BB%8F%E5%85%B8%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="七款经典收集器.png"></p>
<h3 id="7-款经典收集器与垃圾分代之间的关系"><a href="#7-款经典收集器与垃圾分代之间的关系" class="headerlink" title="7 款经典收集器与垃圾分代之间的关系"></a>7 款经典收集器与垃圾分代之间的关系</h3><p>![7 款经典收集器与垃圾分代之间的关系.png](/images/java/jvm/7 款经典收集器与垃圾分代之间的关系.png)</p>
<p>新生代收集器：Serial、ParNew、Parallel Scavenge；</p>
<p>老年代收集器：Serial Old、Parallel Old、CMS；</p>
<p>整堆收集器：G1；</p>
<h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><p><img src="/images/java/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png" alt="垃圾收集器的组合关系.png"></p>
<ul>
<li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</li>
<li>其中 Serial Old 作为 CMS 出现”Concurrent Mode Failure”失败的后备预案。</li>
<li>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial + CMS、ParNew + Serial Old 这两个组合声明为废弃（JEP173），并在 JDK 9 中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>（绿色虚线）JDK 14 中：弃用 Parallel Scavenge 和 Serialold GC 组合（JEP366）。</li>
<li>（青色虚线）JDK 14 中：删除 CMS 垃圾回收器（JEP363）。</li>
</ul>
<blockquote>
<p>为什么 CMS GC 不可以和 Parallel Scavenge GC 搭配使用？</p>
<p>答：Parallel Scavenge GC 底层框架和其他垃圾回收器不同。</p>
</blockquote>
<p>为什么要有很多收集器，一个不够吗？因为 Java 的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>
<p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以<strong>我们选择的只是对具体应用最合适的收集器</strong>。</p>
<h3 id="如何查看默认垃圾收集器"><a href="#如何查看默认垃圾收集器" class="headerlink" title="如何查看默认垃圾收集器"></a>如何查看默认垃圾收集器</h3><p>-XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</p>
<p>使用命令行指令：jinfo -flag  相关垃圾回收器参数  进程 ID</p>
<h2 id="Serial-回收器：串行回收"><a href="#Serial-回收器：串行回收" class="headerlink" title="Serial 回收器：串行回收"></a>Serial 回收器：串行回收</h2><p>Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK 1.3 之前回收新生代唯一的选择。</p>
<p>Serial 收集器作为 HotSpot 中 Client 模式下的默认新生代垃圾收集器。</p>
<p><strong>Serial 收集器采用复制算法、串行回收和”Stop-The-World”机制的方式执行内存回收。</strong></p>
<p>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。<strong>Serial Old 收集器同样也采用了串行回收和”Stop The World”机制，只不过内存回收算法使用的是标记-压缩算法。</strong></p>
<ul>
<li>Serial Old 是运行在 Client 模式下默认的老年代的垃圾回收器</li>
<li>Serial Old 在 Server 模式下主要有两个用途：<ul>
<li>与新生代的 Parallel Scavenge 配合使用</li>
<li>作为老年代 CMS 收集器的后备垃圾收集方案</li>
</ul>
</li>
</ul>
<p><img src="/images/java/jvm/Serial%E3%80%81SerialOld%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Serial、SerialOld收集器.png"></p>
<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它<strong>只会使用一个 CPU 或一条收集线程去完成垃圾收集工作</strong>，更重要的是在它进行垃圾收集时，<strong>必须暂停其他所有的工作线程</strong>，直到它收集结束（Stop The World）。</p>
<p>优势：<strong>简单而高效</strong>（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<ul>
<li>运行在 Client 模式下的虚拟机是个不错的选择。</li>
</ul>
<p>在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB），可以在较短时间内完成垃圾收集（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。</p>
<p>在 HotSpot 虚拟机中，使用 -XX：+UseSerialGC 参数可以指定年轻代和老年代都使用串行收集器。</p>
<p>等价于新生代用 Serial GC，且老年代用 Serial Old GC。</p>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核 CPU 才可以用。现在都不是单核的了。</p>
<p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在 Java Web 应用程序中是不会采用串行垃圾收集器的。</p>
<h2 id="ParNew-回收器：并行回收"><a href="#ParNew-回收器：并行回收" class="headerlink" title="ParNew 回收器：并行回收"></a>ParNew 回收器：并行回收</h2><p>如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。</p>
<ul>
<li>Par 是 Parallel 的缩写，New：只能处理的是新生代</li>
</ul>
<p>ParNew 收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是<strong>采用复制算法</strong>、”Stop-The-World”机制。</p>
<p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器。</p>
<p><img src="/images/java/jvm/ParNew%E3%80%81SerialOld%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="ParNew、SerialOld收集器.png"></p>
<ul>
<li>对于新生代，回收次数频繁，使用并行方式高效。</li>
<li>对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行需要切换线程，串行可以省去切换线程的资源）。</li>
</ul>
<p>由于 ParNew 收集器是基于并行回收，那么是否可以断定 ParNew 收集器的回收效率在任何场景下都会比 Serial 收集器更高效？</p>
<ul>
<li>ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>但是在<strong>单个 CPU 的环境下，ParNew 收集器不比 Serial 收集器更高效</strong>。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁得做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
</ul>
<p>除 Serial Old GC 外，目前只有 ParNew GC 能与 CMS 收集器配合工作（JDK 8 中 Serial Old GC 移除对 ParNew GC 的支持，JDK 9 版本中已经明确提示 UserParNewGC was deprecated，将在后续版本中被移除，JDK 14 中移除 CMS GC）。</p>
<p>在程序中，开发人员可以通过选项”-XX：+UseParNewGC”手动指定使用 ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
<p>-XX:ParallelGCThreads 限制线程数量，默认开启和 CPU 数据相同的线程数。</p>
<h2 id="Parallel-回收器：吞吐量优先"><a href="#Parallel-回收器：吞吐量优先" class="headerlink" title="Parallel 回收器：吞吐量优先"></a>Parallel 回收器：吞吐量优先</h2><p>HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样也采用了<strong>复制算法、并行回收和”Stop The World”机制</strong>。</p>
<p>那么 Parallel 收集器的出现是否多此一举？</p>
<ul>
<li>和 ParNew 收集器不同，Parallel Scavenge 收集器的目标则是达到<strong>一个可控制的吞吐量（Throughput）</strong>，它也被称为吞吐量优先的垃圾收集器。</li>
<li>自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别。</li>
</ul>
<p>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要<strong>适合在后台运算而不需要太多交互的任务</strong>。因此，常见在服务器环境中使用。<strong>例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</strong></p>
<p>Parallel 收集器在 JDK 1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p>
<p>Parallel Old 收集器采用了<strong>标记-压缩算法</strong>，但同样也是基于并行回收和”Stop-The-World”机制。</p>
<p>![Parallel Scavenge、Parallel Old收集器.png](/images/java/jvm/Parallel Scavenge、Parallel Old收集器.png)</p>
<p>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。在 Java 8 中，默认是此垃圾收集器。</p>
<h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>-XX：+UseParallelGC 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务。</p>
<p>-XX：+UseParalleloldGC 手动指定老年代都是使用并行回收收集器。</p>
<ul>
<li>分别适用于新生代和老年代。默认 JDK 8 是开启的。</li>
<li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li>
</ul>
<p>-XX:ParallelGcrhreads 设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。</p>
<p>在默认情况下，当 CPU 数量小于 8 个，ParallelGCThreads 的值等于 CPU 数量。</p>
<p>当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU_Count] / 8]</p>
<p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即 STW 的时间）。单位是毫秒。</p>
<ul>
<li>为了尽可能地把停顿时间控制在 MaxGCPauseMills 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制。该参数使用需谨慎。</li>
</ul>
<p>-XX:GCTimeRatio 垃圾收集时间占总时间的比例（= 1 /（N+1））。用于衡量吞吐量的大小。</p>
<ul>
<li><p>取值范围（0，100）。默认值 99，也就是垃圾回收时间不超过 1%。</p>
</li>
<li><p>与前一个 -XX:MaxGCPauseMillis 参数有一定矛盾性。暂停时间越长，Radio 参数就容易超过设定的比例。</p>
</li>
</ul>
<p>-XX:+UseAdaptiveSizePolicy 设置 Parallel Scavenge 收集器具有<strong>自适应调节策略。</strong></p>
<ul>
<li><p>在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p>
</li>
<li><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。</p>
</li>
</ul>
<h2 id="CMS-回收器：低延迟"><a href="#CMS-回收器：低延迟" class="headerlink" title="CMS 回收器：低延迟"></a>CMS 回收器：低延迟</h2><p>在 JDK 1.5 时期，HotSpot 推出了一款在<strong>强交互应用</strong>中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<strong>这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p>
<p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<ul>
<li><strong>目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，</strong>以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</li>
</ul>
<p>CMS 的垃圾收集算法采用<strong>标记-清除</strong>算法，并且也会”Stop-The-World”。</p>
<p>不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</p>
<p>在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC。</p>
<p><img src="/images/java/jvm/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS收集器.png"></p>
<p>CMS 整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即<strong>初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</strong>。(涉及STW的阶段主要是：初始标记 和 重新标记)</p>
<ul>
<li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-The-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是<strong>标记出 GC Roots 能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快。</strong></li>
<li><strong>并发标记</strong>（Concurrent-Mark）阶段：从 GC Roots 的<strong>直接关联对象开始遍历整个对象图的过程</strong>，这个过程<strong>耗时较长</strong>但是<strong>不需要停顿用户线程</strong>，可以与垃圾收集线程一起并发运行。</li>
<li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<strong>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段<strong>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</strong>。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li>
</ul>
<p>尽管 CMS 收集器采用的是并发回收（非独占式），但是在其<strong>初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”</strong>机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-The-World”，只是尽可能地缩短暂停时间。</p>
<p><strong>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</strong></p>
<p>另外，由于在垃圾收集阶段用户线程没有中断，所以<strong>在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用</strong>。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是<strong>当堆内存使用率达到某一阈值时，便开始进行回收</strong>，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次<strong>“Concurrent Mode Failure”</strong>失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
<p>CMS 收集器的垃圾收集算法采用的是<strong>标记-清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会<strong>产生一些内存碎片</strong>。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p>
<h3 id="CMS-为什么不使用标记整理（压缩）算法？"><a href="#CMS-为什么不使用标记整理（压缩）算法？" class="headerlink" title="CMS 为什么不使用标记整理（压缩）算法？"></a>CMS 为什么不使用标记整理（压缩）算法？</h3><p>因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响。Mark Compact 更适合“Stop The World”这种场景下使用。</p>
<h3 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h3><ul>
<li>并发收集</li>
<li>低延迟</li>
</ul>
<h3 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p><strong>会产生内存碎片</strong>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 Full GC。</p>
</li>
<li><p><strong>CMS 收集器对 CPU 资源非常敏感</strong>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</p>
</li>
<li><p><strong>CMS 收集器无法处理浮动垃圾</strong>。可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。</p>
</li>
</ul>
<h3 id="CMS-收集器可以设置的参数"><a href="#CMS-收集器可以设置的参数" class="headerlink" title="CMS 收集器可以设置的参数"></a>CMS 收集器可以设置的参数</h3><ul>
<li><p>-XX：+UseConcMarkSweepGC 手动指定使用 CMS 收集器执行内存回收任务。</p>
<ul>
<li>开启该参数后会自动将 -XX：+UseParNewGC 打开。即：ParNew（Young区用）+ CMS（Old 区用）+ Serial Old 的组合。</li>
</ul>
</li>
<li><p>-XX:CMSInitiatingoccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p>
<ul>
<li>JDK 5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次 CMS 回收。<strong>JDK 6 及以上版本默认值为92%</strong></li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此<strong>通过该选项便可以有效降低 Full GC 的执行次数。</strong></li>
</ul>
</li>
<li><p>-XX：+UseCMSCompactAtFullCollection 用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p>
</li>
<li><p>-XX:CMSFullGCsBeforecompaction 设置在执行多少次 Full GC 后对内存空间进行压缩整理。</p>
</li>
<li><p>-XX:ParallelcMSThreads 设置 CMS 的线程数量。</p>
<ul>
<li>CMS 默认启动的线程数是（ParallelGCThreads + 3）/ 4，ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
</ul>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>HotSpot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 GC 有什么不同呢？</p>
<p>请记住以下口令：</p>
<ul>
<li>如果你想要最小化地使用内存和并行开销，请选 Serial GC；</li>
<li>如果你想要最大化应用程序的吞吐量，请选 Parallel GC；</li>
<li>如果你想要最小化 GC 的中断或停顿时间，请选 CMS GC。</li>
</ul>
<h3 id="JDK-后续版本中-CMS-的变化"><a href="#JDK-后续版本中-CMS-的变化" class="headerlink" title="JDK 后续版本中 CMS 的变化"></a>JDK 后续版本中 CMS 的变化</h3><p>JDK 9 新特性：CMS 被标记为 Deprecate 了（JEP291）</p>
<ul>
<li>如果对 JDK 9 及以上版本的 HotSpot 虚拟机使用参数 -XX：+UseConcMarkSweepGC 来开启 CMS 收集器的话，用户会收到一个警告信息，提示 CMS 未来将会被废弃。</li>
</ul>
<p>JDK 14 新特性：删除 CMS 垃圾回收器（JEP363）移除了 CMS 垃圾收集器，如果在 JDK 14 中使用 XX：+UseConcMarkSweepGC 的话，JVM 不会报错，只是给出一个 Warning 信息，但是不会 exit，JVM 会自动回退以默认 GC 方式启动 JVM。</p>
<blockquote>
<p>OpenJDK 64-bit Server VM Warning: Ignoring option UseConcMarkSweepGC; support was removed in 14.0 and the VM will continue execution using the default collector.</p>
</blockquote>
<h2 id="G1-回收器：区域化分代式"><a href="#G1-回收器：区域化分代式" class="headerlink" title="G1 回收器：区域化分代式"></a>G1 回收器：区域化分代式</h2><h3 id="既然我们已经有了前面几个强大的-GC，为什么还要发布-Garbage-First（G1）？"><a href="#既然我们已经有了前面几个强大的-GC，为什么还要发布-Garbage-First（G1）？" class="headerlink" title="既然我们已经有了前面几个强大的 GC，为什么还要发布 Garbage First（G1）？"></a>既然我们已经有了前面几个强大的 GC，为什么还要发布 Garbage First（G1）？</h3><p>原因就在于应用程序所应对的<strong>业务越来越庞大、复杂，用户越来越多</strong>，没有 GC 就不能保证应用程序正常进行，而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。G1（Garbage-First）垃圾回收器是在 Java7 update 4 之后引入的一个新的垃圾回收器，<strong>是当今收集器技术发展的最前沿成果之一</strong>。</p>
<p>与此同时，为了适应现在<strong>不断扩大的内存和不断增加的处理器数量</strong>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p>
<p><strong>官方给 G1 设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</strong>。</p>
<h3 id="为什么名字叫-Garbage-First（G1-）呢？"><a href="#为什么名字叫-Garbage-First（G1-）呢？" class="headerlink" title="为什么名字叫 Garbage First（G1)）呢？"></a>为什么名字叫 Garbage First（G1)）呢？</h3><p>因为 G1 是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的 Region 来表示 Eden、幸存者 0 区，幸存者 1 区，老年代等。</p>
<p>G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的 Region。</strong></p>
<p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给 G1 一个名字：垃圾优先（Garbage First）。</p>
<p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<strong>主要针对配备多核 CPU 及大容量内存的机器</strong>，以极高概率满足 GC 停顿时间的同时，还兼具高吞吐量的性能特征。</p>
<p>在 JDK 1.7 版本正式启用，移除了 Experimental 的标识，<strong>是 JDK 9 以后的默认垃圾回收器</strong>，取代了 CMS 回收器以及 Parallel + Parallel Old 组合。被 Oracel 官方称为<strong>“全功能的垃圾收集器”</strong>。</p>
<p>与此同时，CMS 已经在 JDK 9 中被标记为废弃（Deprecated）。在 JDK 8 中还不是默认的垃圾回收器，需要使用 -XX：+UseG1GC 来启用。</p>
<h3 id="G1-垃圾收集器的优点"><a href="#G1-垃圾收集器的优点" class="headerlink" title="G1 垃圾收集器的优点"></a>G1 垃圾收集器的优点</h3><p>与其他 GC 收集器相比，G1 使用了全新的分区算法，其特点如下所示：</p>
<h4 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h4><ul>
<li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程 STW。</li>
<li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</li>
</ul>
<h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><ul>
<li>从分代上看，<strong>G1 依然属于分代型垃圾回收器</strong>，它会区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li>将<strong>堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</strong></li>
<li>和之前的各类回收器不同，它<strong>同时兼顾年轻代和老年代</strong>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>
</ul>
<p>G1 所谓的分代，已经不是下面这样的了</p>
<p><img src="/images/java/jvm/G1%E4%B8%8D%E5%86%8D%E6%98%AF%E4%BC%A0%E7%BB%9F%E5%88%86%E4%BB%A3%E6%96%B9%E5%BC%8F.png" alt="G1不再是传统分代方式.png"></p>
<p>而是这样的一个区域</p>
<p><img src="/images/java/jvm/G1%E6%96%B0%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F.png" alt="G1新的分配方式.png"></p>
<h4 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h4><ul>
<li>CMS：“标记-清除”算法、内存碎片、若干次 GC 后进行一次碎片整理</li>
<li>G1 将内存划分为一个个的 Region。内存的回收是以 Region 作为基本单位的。<strong>Region 之间是复制算法，</strong>但整体上实际可看作是<strong>标记-压缩（Mark-Compact）算法</strong>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</li>
</ul>
<h4 id="可预测的停顿时间模型（即：软实时-Soft-Real-Time）"><a href="#可预测的停顿时间模型（即：软实时-Soft-Real-Time）" class="headerlink" title="可预测的停顿时间模型（即：软实时 Soft Real-Time）"></a>可预测的停顿时间模型（即：软实时 Soft Real-Time）</h4><p>这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p>
<ul>
<li>由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的 Region</strong> 。保证了 G1 收集器在有限的时间内可以<strong>获取尽可能高的收集效率</strong>。</li>
<li>相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
<h3 id="G1-垃圾收集器的缺点"><a href="#G1-垃圾收集器的缺点" class="headerlink" title="G1 垃圾收集器的缺点"></a>G1 垃圾收集器的缺点</h3><p>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。</p>
<p>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势。平衡点在 6~8GB 之间。</p>
<h3 id="G1-参数设置"><a href="#G1-参数设置" class="headerlink" title="G1 参数设置"></a>G1 参数设置</h3><ul>
<li>-XX:+UseG1GC：手动指定使用 G1 垃圾收集器执行内存回收任务</li>
<li>-XX:G1HeapRegionSize：设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的 1/2000。</li>
<li>-XX:MaxGCPauseMillis：设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到），默认值是 200ms。</li>
<li>-XX:+ParallelGcThread：设置 STW 工作线程数的值，最多设置为 8。</li>
<li>-XX:ConcGCThreads：设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右。</li>
<li>-XX:InitiatingHeapOccupancyPercent：设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC，默认值是 45。</li>
</ul>
<h3 id="G1-收集器的常见操作步骤"><a href="#G1-收集器的常见操作步骤" class="headerlink" title="G1 收集器的常见操作步骤"></a>G1 收集器的常见操作步骤</h3><p>G1 的设计原则就是简化 JVM 性能调优，开发人员只需要简单的三步即可完成调优：</p>
<ul>
<li>第一步：开启 G1 垃圾收集器</li>
<li>第二步：设置堆的最大内存</li>
<li>第三步：设置最大的停顿时间</li>
</ul>
<p>G1 中提供了三种垃圾回收模式：YoungGC、Mixed GC 和 Full GC，在不同的条件下被触发。</p>
<h3 id="G1-收集器的适用场景"><a href="#G1-收集器的适用场景" class="headerlink" title="G1 收集器的适用场景"></a>G1 收集器的适用场景</h3><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p>
<p>最主要的应用是需要低 GC 延迟，并具有大堆的应用程序提供解决方案；</p>
<p>如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于 0.5 秒；（G1 通过每次只清理一部分而不是全部的 Region 的增量式清理来保证每次 GC 停顿时间不会过长）。<br>用来替换掉 JDK 1.5 中的 CMS 收集器；在下面的情况时，使用 G1 可能比 CMS 好：</p>
<ul>
<li>超过 50% 的 Java 堆被活动数据占用；</li>
<li>对象分配频率或年代提升频率变化很大；</li>
<li>GC 停顿时间过长（长于 0.5 至 1 秒）</li>
</ul>
<p>HotSpot 垃圾收集器里，除了 G1 以外，其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p>
<h3 id="分区-Region：化整为零"><a href="#分区-Region：化整为零" class="headerlink" title="分区 Region：化整为零"></a>分区 Region：化整为零</h3><p>使用 G1 收集器时，它将整个 Java 堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32MB 之间，且为 2 的 N 次幂，即 1MB、2MB、4MB、8MB、16MB、32MB。可以通过 -XX:G1HeapRegionSize 设定。<strong>所有的 Region 大小相同，且在 JVM 生命周期内不会被改变。</strong></p>
<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合，通过 Region 的动态分配方式实现逻辑上的连续。</p>
<p><img src="/images/java/jvm/G1%E6%96%B0%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F2.png" alt="G1新的分配方式2.png"></p>
<p>一个 Region 有可能属于 Eden、Survivor 或者 Old/Tenured 内存区域。但是一个 Region 只可能属于一个角色。图中的 E 表示该 Region 属于 Eden 内存区域，S 表示属于 Survivor 内存区域，O 表示属于 Old 内存区域。图中空白的表示未使用的内存空间。</p>
<p>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过 0.5 个 Region，就放到 H。</p>
<p><strong>设置 H 的原因：</strong>对于堆中的对象，默认直接会被分配到老年代，<strong>但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响</strong>。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放大对象。如果一个 H 区装不下一个大对象，那么 G1 会寻找连续的 H 区来存储。为了能找到连续的 H 区，有时候不得不启动 Full GC。G1 的大多数行为都把 H 区作为老年代的一部分来看待。</p>
<p>每个 Region 都是通过指针碰撞来分配空间</p>
<h3 id="G1-垃圾回收器的回收过程"><a href="#G1-垃圾回收器的回收过程" class="headerlink" title="G1 垃圾回收器的回收过程"></a>G1 垃圾回收器的回收过程</h3><p>G1 GC 的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li><p>年轻代 GC（Young GC）</p>
</li>
<li><p>老年代并发标记过程（Concurrent Marking）</p>
</li>
<li><p>混合回收（Mixed GC）</p>
</li>
<li><p>（如果需要，单线程、独占式、高强度的 Full GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。）</p>
</li>
</ul>
<p>![G1 垃圾回收器的回收过程.png](/images/java/jvm/G1 垃圾回收器的回收过程.png)</p>
<p>顺时针，Young GC -&gt; Young GC + Concurrent Mark -&gt; Mixed GC 顺序，进行垃圾回收。</p>
<p>应用程序分配内存，<strong>当年轻代的 Eden 区用尽时开始年轻代回收过程</strong>；G1 的年轻代收集阶段是一个<strong>并行</strong>的<strong>独占式</strong>收集器。在年轻代回收期，G1 GC 暂停所有应用程序线程，启动多线程执行年轻代回收。然后<strong>从年轻代区间移动存活对象到 Survivor 区间或者老年区间，也有可能是两个区间都会涉及。</strong></p>
<p>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程。</p>
<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的 G1 回收器和其他 GC 不同，<strong>G1 的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的 Region 就可以了</strong>。同时，这个老年代 Region 是和年轻代一起被回收的。</p>
<p>举个例子：一个 Web 服务器，Java 进程最大堆内存为 4G，每分钟响应 1500 个请求，每 45 秒钟会新分配大约 2G 的内存。G1 会每 45 秒钟进行一次年轻代回收，每 31 个小时整个堆的使用率会达到 45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>
<h3 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h3><p>一个对象被不同区域引用的问题</p>
<p>一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中对象引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？</p>
<p>在其他的分代收集器，也存在这样的问题（而 G1 更突出）回收新生代也不得不同时扫描老年代？这样的话会降低 Minor GC 的效率；</p>
<p><strong>解决方法：</strong></p>
<p>无论 G1 还是其他分代收集器，JVM 都是使用 Remembered Set 来避免全局扫描：</p>
<p>每个 Region 都有一个对应的 Remembered Set ；每次 Reference 类型数据写操作时，都会产生一个 Write Barrier 暂时中断操作；</p>
<p>然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）；如果不同，通过 CardTable 把相关引用信息记录到引用指向对象的所在 Region 对应的 Remembered Set 中；当进行垃圾收集时，在 GC 根节点的枚举范围加入 Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>
<p>![Remembered Set.png](/images/java/jvm/Remembered Set.png)</p>
<h3 id="G1-回收过程一：年轻代-GC"><a href="#G1-回收过程一：年轻代-GC" class="headerlink" title="G1 回收过程一：年轻代 GC"></a>G1 回收过程一：年轻代 GC</h3><p>JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程。</p>
<p>年轻代垃圾回收只会回收 Eden 区和 Survivor 区。</p>
<p>首先 G1 停止应用程序的执行（Stop-The-World），G1 创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段。</p>
<p>![G1 回收过程一：年轻代 GC.png](/images/java/jvm/G1 回收过程一：年轻代 GC.png)</p>
<p>然后开始如下回收过程：</p>
<h4 id="第一阶段，扫描根"><a href="#第一阶段，扫描根" class="headerlink" title="第一阶段，扫描根"></a><strong>第一阶段，扫描根</strong></h4><p>根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。</p>
<h4 id="第二阶段，更新-RSet"><a href="#第二阶段，更新-RSet" class="headerlink" title="第二阶段，更新 RSet"></a><strong>第二阶段，更新 RSet</strong></h4><p>处理 Dirty Card Queue（见备注）中的 Card，更新 RSet。此阶段完成后，<strong>RSet 可以准确的反映老年代对所在的内存分段中对象的引用。</strong></p>
<blockquote>
<p>对于应用程序的引用赋值语句 <code>object.field = object</code>，JVM 会在之前和之后执行特殊的操作以在 Dirty Card Queue 中入队一个保存了对象引用信息的 Card。在年轻代回收的时候，G1 会对 Dirty Card Queue 中所有的 Card 进行处理，以更新 RSet，保证 RSet 实时准确的反映引用关系。</p>
<p>那为什么不在引用赋值语句处直接更新 RSet 呢？这是为了性能的需要，RSet 的处理需要线程同步，开销会很大，使用队列性能会好很多。</p>
</blockquote>
<h4 id="第三阶段，处理-RSet"><a href="#第三阶段，处理-RSet" class="headerlink" title="第三阶段，处理 RSet"></a>第三阶段，处理 RSet</h4><p>识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</p>
<h4 id="第四阶段，复制对象"><a href="#第四阶段，复制对象" class="headerlink" title="第四阶段，复制对象"></a>第四阶段，复制对象</h4><p>此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加 1，达到阀值会被会被复制到 Old 区中空的内存分段。如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间。</p>
<h4 id="第五阶段，处理引用"><a href="#第五阶段，处理引用" class="headerlink" title="第五阶段，处理引用"></a>第五阶段，处理引用</h4><p>处理 Soft，Weak，Phantom，Final，JNI Weak 等引用。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>
<h3 id="G1-回收过程二：并发标记过程（主要针对老年代）"><a href="#G1-回收过程二：并发标记过程（主要针对老年代）" class="headerlink" title="G1 回收过程二：并发标记过程（主要针对老年代）"></a>G1 回收过程二：并发标记过程（主要针对老年代）</h3><ol>
<li><strong>初始标记阶段</strong>：标记从根节点直接可达的对象。这个阶段是 STW 的，并且会触发一次年轻代 GC。</li>
<li><strong>根区域扫描（Root Region Scanning）</strong>：G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 Young GC 之前完成。</li>
<li><strong>并发标记（Concurrent Marking）</strong>：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 Young GC 中断。在并发标记阶段，<strong>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</strong>。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>
<li><strong>再次标记（Remark）</strong>：由于应用程序持续进行，需要修正上一次的标记结果，这个过程是 STW 的。G1 中采用了比 CMS 更快的初始快照算法：Snapshot-At-The-Beginning（SATB）。</li>
<li><strong>独占清理（cleanup，STW）</strong>：计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。这个过程是 STW 的。这个阶段并不会实际上去做垃圾的收集。</li>
<li><strong>并发清理阶段</strong>：识别并清理完全空闲的区域。</li>
</ol>
<h3 id="G1-回收过程三：混合回收"><a href="#G1-回收过程三：混合回收" class="headerlink" title="G1 回收过程三：混合回收"></a>G1 回收过程三：混合回收</h3><p>当越来越多的对象晋升到老年代 Old Region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC ，该算法并不是一个 Old GC，除了回收整个 Young Region，还会回收一部分的 Old Region。这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>。可以选择哪些 Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC 并不是 Full GC。</p>
<p>![G1 回收过程三：混合回收.png](/images/java/jvm/G1 回收过程三：混合回收.png)</p>
<p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分 8 次（可以通过 -XX:G1MixedGCCountTarget 设置）被回收。</p>
<p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p>
<p>由于老年代中的内存分段默认分 8 次回收，G1 会优先回收垃圾多的内存分段。<strong>垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，</strong> -XX:G1MixedGCLiveThresholdPercent，默认为 65%，意思是垃圾占内存分段比例要达到 65% 才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p>
<p>混合回收并不一定要进行 8 次。有一个阈值 -XX:G1HeapWastePercent，默认值为 10%，意思是允许整个堆内存中有 10% 的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于 10%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少。</p>
<h3 id="G1-回收可选的过程四：Full-GC"><a href="#G1-回收可选的过程四：Full-GC" class="headerlink" title="G1 回收可选的过程四：Full GC"></a>G1 回收可选的过程四：Full GC</h3><p>G1 的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会<strong>停止应用程序的执行</strong>（Stop-The-World），使用<strong>单线程</strong>的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
<p>要避免 Full GC 的发生，一旦发生需要进行调整。什么时候会发生 Full GC 呢？比如堆内存太小，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到 Full GC ，这种情况可以通过增大内存解决。<br>导致 G1 Full GC 的原因可能有两个：</p>
<ul>
<li>Evacuation 的时候没有足够的 To-Space 来存放晋升的对象；</li>
<li>并发处理过程完成之前空间耗尽。</li>
</ul>
<h3 id="G1-回收的优化建议"><a href="#G1-回收的优化建议" class="headerlink" title="G1 回收的优化建议"></a>G1 回收的优化建议</h3><p> 从 Oracle 官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到 G1 只是回收一部分 Region，停顿时间是用户可控制的，所以并不迫切去实现，而<strong>选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中</strong>。另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<p>年轻代大小</p>
<ul>
<li>避免使用 -Xmn 或 -XX:NewRatio 等相关选项显式设置年轻代大小</li>
<li>固定年轻代的大小会覆盖暂停时间目标</li>
</ul>
<p>暂停时间目标暂停时间目标不要太过严苛</p>
<ul>
<li>G1 GC 的吞吐量目标是 90% 的应用程序时间和 10% 的垃圾回收时间</li>
<li>评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
</ul>
<h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结*"></a>垃圾回收器总结*</h2><p>截止 JDK 1.8，一共有 7 款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<p><img src="/images/java/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93.png" alt="垃圾回收器总结.png"></p>
<p>GC 发展阶段：Serial =&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p>
<p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot 虚拟机在 JDK7/8 后所有收集器及组合如下图：</p>
<p><img src="/images/java/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png" alt="垃圾收集器的组合关系.png"></p>
<ul>
<li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1。</li>
<li>其中 Serial Old 作为 CMS 出现”Concurrent Mode Failure”失败的后备预案。</li>
<li>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial + CMS、ParNew + Serial Old 这两个组合声明为废弃（JEP173），并在 JDK 9 中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>（绿色虚线）JDK 14 中：弃用 Parallel Scavenge 和 Serialold GC 组合（JEP366）。</li>
<li>（青色虚线）JDK 14 中：删除 CMS 垃圾回收器（JEP363）。</li>
</ul>
<h3 id="怎么选择垃圾回收器？"><a href="#怎么选择垃圾回收器？" class="headerlink" title="怎么选择垃圾回收器？"></a>怎么选择垃圾回收器？</h3><p>Java 垃圾收集器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾收集器可以让 JVM 的性能有一个很大的提升。怎么选择垃圾收集器？</p>
<ul>
<li>优先调整堆的大小让 JVM 自适应完成。</li>
<li>如果内存小于100M，使用串行收集器。</li>
<li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器。</li>
<li>如果是多 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择。</li>
<li>如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器。</li>
<li>官方推荐 G1，性能高。<strong>现在互联网的项目，基本都是使用 G1。</strong></li>
</ul>
<p>最后需要明确一个观点：</p>
<ul>
<li>没有最好的收集器，更没有万能的收集</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ul>
<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。<br>这里较通用、基础性的部分如下：</p>
<ul>
<li><p>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</p>
</li>
<li><p>垃圾收集器工作的基本流程。</p>
</li>
</ul>
<p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</p>
<h2 id="GC-日志分析"><a href="#GC-日志分析" class="headerlink" title="GC 日志分析"></a>GC 日志分析</h2><p>通过阅读 GC 日志，我们可以了解 Java 虚拟机内存分配与回收策略。<br>内存分配与垃圾回收的参数列表</p>
<ul>
<li>-XX:+PrintGC 输出 GC 日志。类似：-verbose:gc</li>
<li>-XX:+PrintGCDetails 输出 GC 的详细日志</li>
<li>-XX:+PrintGCTimestamps 输出 GC 的时间戳（以基准时间的形式）</li>
<li>-XX:+PrintGCDatestamps 输出 GC 的时间戳（以日期的形式，如 2013-05-04T21：53：59.234+0800）</li>
<li>-XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息</li>
<li>-Xloggc:../logs/gc.log 日志文件的输出路径</li>
</ul>
<h3 id="verbose-gc"><a href="#verbose-gc" class="headerlink" title="verbose:gc"></a>verbose:gc</h3><p>打开 GC 日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-verbose:gc</span><br></pre></td></tr></table></figure>

<p>这个只会显示总的 GC 堆的变化，如下：</p>
<p><img src="/images/java/jvm/%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E4%B9%8Bverbose%EF%BC%9Agc.png" alt="查看日志之verbose：gc.png"></p>
<p>参数解析</p>
<p><img src="/images/java/jvm/%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E4%B9%8Bverbose%EF%BC%9Agc%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90.png" alt="查看日志之verbose：gc参数解析.png"></p>
<h3 id="PrintGCDetails"><a href="#PrintGCDetails" class="headerlink" title="PrintGCDetails"></a>PrintGCDetails</h3><p>打开 GC 日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<p>输入信息如下</p>
<p><img src="/images/java/jvm/%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E4%B9%8BPrintGCDetails.png" alt="查看日志之PrintGCDetails.png"></p>
<p>参数解析</p>
<p><img src="/images/java/jvm/%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E4%B9%8BPrintGCDetails%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90.png" alt="查看日志之PrintGCDetails参数解析.png"></p>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>打开 GC 日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps</span><br></pre></td></tr></table></figure>

<p>输入信息如下：</p>
<p><img src="/images/java/jvm/%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E4%B9%8BPrintGCTimeStamps%E3%80%81PrintGCDateStamps.png" alt="查看日志之PrintGCTimeStamps、PrintGCDateStamps.png"></p>
<p>说明：带上了日期和时间</p>
<h3 id="GC-日志"><a href="#GC-日志" class="headerlink" title="GC 日志"></a>GC 日志</h3><p>把 GC 日志保存到文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xloggc:&#x2F;path&#x2F;to&#x2F;gc.log</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>“[GC”和”[Full GC”说明了这次垃圾收集的停顿类型，如果有”Full”则说明 GC 发生了”Stop The World”</li>
<li>使用 Serial 收集器在新生代的名字是 Default New Generation，因此显示的是”[DefNew”</li>
<li>使用 ParNew 收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</li>
<li>使用 Parallel Scavenge 收集器在新生代的名字是”[PSYoungGen”</li>
<li>老年代的收集和新生代道理一样，名字也是收集器决定的</li>
<li>使用 G1 收集器的话，会显示为”Garbage-First Heap”</li>
</ul>
<p><strong>Allocation Failure</strong></p>
<ul>
<li>表明本次引起 GC 的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</li>
</ul>
<p><strong>[PSYoungGen：5986K-&gt;696K（8704K）]5986K-&gt;704K（9216K）中括号内：</strong></p>
<ul>
<li>GC 回收前年轻代大小，回收后大小，（年轻代总大小）</li>
<li>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li>
</ul>
<p><strong>user 代表用户态回收耗时，sys 内核态回收耗时，rea 实际耗时。由于多核的原因，时间总和可能会超过 real 时间</strong></p>
<p><img src="/images/java/jvm/GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90.png" alt="GC日志分析.png"></p>
<h3 id="Young-GC-Minor-GC"><a href="#Young-GC-Minor-GC" class="headerlink" title="Young GC(Minor GC)"></a>Young GC(Minor GC)</h3><p>![Young GC日志分析.png](/images/java/jvm/Young GC日志分析.png)</p>
<h3 id="Full-GC-1"><a href="#Full-GC-1" class="headerlink" title="Full GC"></a>Full GC</h3><p>![Full GC日志分析.png](/images/java/jvm/Full GC日志分析.png)</p>
<h3 id="GC-回收举例"><a href="#GC-回收举例" class="headerlink" title="GC 回收举例"></a>GC 回收举例</h3><p>我们编写一个程序，用来说明 GC 收集的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GC垃圾收集过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCUseTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> [] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> *_1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> *_1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> *_1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> *_1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们设置 JVM 启动参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<p>首先我们会将 3 个 2M 的数组存放到 Eden 区，然后后面 4M 的数组来了后，将无法存储，因为 Eden 区只剩下2M 的剩余空间了，那么将会进行一次 Young GC 操作，将原来 Eden 区的内容，存放到 Survivor 区，但是Survivor 区也存放不下，那么就会直接晋级存入 Old 区。</p>
<p>![GC 回收举例1.png](/images/java/jvm/GC 回收举例1.png)</p>
<p>然后我们将 4M 对象存入到 Eden 区中</p>
<p>![GC 回收举例2.png](/images/java/jvm/GC 回收举例2.png)</p>
<p>可以用一些工具去分析这些 GC 日志</p>
<p>常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat 等</p>
<p><strong>GCViewer</strong></p>
<p><img src="/images/java/jvm/GCViewer.png" alt="GCViewer.png"></p>
<p><strong>GC easy</strong></p>
<h2 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h2><p>GC 仍然处于飞速发展之中，目前的默认选项 <strong>G1 GC 在不断的进行改进</strong>，很多我们原来认为的缺点，例如串行的 Full GC、Card Table 扫描的低效等，都已经被大幅改进，例如，JDK 10 以后，Full GC 已经是并行运行，在很多场景下，其表现还略优于 Parallel GC 的并行 Full GC 实现。</p>
<p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<strong>在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台。</strong></p>
<p>比较不幸的是 CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在 JDK 9 中已经被标记为废弃，并在 JDK 14 版本中移除。</p>
<p>Epsilon:A No-Op GarbageCollector（Epsilon 垃圾回收器，”No-Op（无操作）”回收器）<a href="http://openidk.iava.net/iep" target="_blank" rel="noopener">http://openidk.iava.net/iep</a> s/318</p>
<p>ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）</p>
<p>现在 G1 回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK 11 出现）和 Shenandoah（Open JDK 12）</p>
<ul>
<li>主打特点：低停顿时间</li>
</ul>
<h3 id="Open-JDK-12-的-Shenandoash-GC"><a href="#Open-JDK-12-的-Shenandoash-GC" class="headerlink" title="Open JDK 12 的 Shenandoash GC"></a>Open JDK 12 的 Shenandoash GC</h3><p>Open JDK 12 的 Shenandoash GC：低停顿时间的 GC（实验性）。</p>
<p><strong>Shenandoah，无疑是众多 GC 中最孤独的一个</strong>。是第一款不由 Oracle 公司团队领导开发的 HotSpot 垃圾收集器。不可避免的受到官方的排挤。比如号称 Open JDK 和 Oracle JDK 没有区别的 Oracle 公司仍拒绝在 Oracle JDK 12 中支持 Shenandoah。</p>
<p>Shenandoah 垃圾回收器最初由 RedHat 进行的一项垃圾收集器研究项目 Pauseless GC 的实现，旨在针对 JVM 上的内存回收实现低停顿的需求。在 2014 年贡献给 Open JDK。</p>
<p>Red Hat 研发 Shenandoah 团队对外宣称，<strong>Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB，99.9% 的目标都可以把垃圾收集的停顿时间限制在十毫秒以内</strong>，不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<p>![Shenandoah 开发团队在实际应用中的测试数据.png](/images/java/jvm/Shenandoah 开发团队在实际应用中的测试数据.png)</p>
<p>这是 RedHat 在 2016 年发表的论文数据，测试内容是使用 ES 对 200GB 的维基百科数据进行索引。从结果看：</p>
<ul>
<li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li>
<li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li>
</ul>
<h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><ul>
<li>Shenandoah GC 的弱项：高运行负担下的吞吐量下降。</li>
<li>shenandoah GC 的强项：低延迟时间。</li>
</ul>
<h3 id="革命性的-ZGC"><a href="#革命性的-ZGC" class="headerlink" title="革命性的 ZGC"></a>革命性的 ZGC</h3><p>ZGC 与 Shenandoah 目标高度相似，<strong>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</strong></p>
<p>《深入理解 Java 虚拟机》一书中这样定义 ZGC：ZGC 收集器是一款基于 Region 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现<strong>可并发的标记-压缩算法</strong>的，以低延迟为首要目标的一款垃圾收集器。</p>
<p>ZGC 的工作过程可以分为 4 个阶段：<strong>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</strong>等。</p>
<p>ZGC 几乎在所有地方并发执行的，除了初始标记的是 STW 的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>
<p>停顿时间对比</p>
<p><img src="/images/java/jvm/ZGC%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%E5%AF%B9%E6%AF%94.png" alt="ZGC停顿时间对比.png"></p>
<p>在 ZGC 的强项停顿时间测试上，塔毫不留情的将 Parallel、G1 拉开了两个数量级的差距。无论平均挺对、95% 停顿、99% 停顿、99.9% 停顿，还是最大停顿时间，ZGC 都能毫不费劲控制在 10 毫秒以内。</p>
<p>虽然 ZGC 还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。<br><strong>未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</strong></p>
<p>JDK 14 之前，ZGC 仅 Linux 才支持。</p>
<p>尽管许多使用 ZGC 的用户都使用类 Linux 的环境，但在 Windows 和 macOS 上，人们也需要 ZGC 进行开发部署和测试。许多桌面应用也可以从 ZGC 中受益。因此，ZGC 特性被移植到了 Windows 和 macOS 上。</p>
<p>现在 mac 或 Windows 上也能使用 ZGC 了，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions-XX：+UseZGC</span><br></pre></td></tr></table></figure>

<h3 id="AliGC"><a href="#AliGC" class="headerlink" title="AliGC"></a>AliGC</h3><p>AliGC 是阿里巴巴 JVM 团队基于 G1 算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p>
<p>![AliGC 指定场景对比.png](/images/java/jvm/AliGC 指定场景对比.png)</p>
<p>当然，其它厂商也提供了各种别具一格的 GC 实现，例如比较有名的低延迟 GC——Zing。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
